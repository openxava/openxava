<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Appendix D: Automated testing - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <h1 id="toc0"> <span id="breadcrumbs"> <span id="openxava"> <a
              href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava </a> </span> / <a
            href="index_en.html">documentation</a> / </span> Appendix D: Automated testing </h1>
      <strong>Course</strong>: <a class="wiki_link" href="getting-started_en.html">1. Getting started</a> | <a
        class="wiki_link" href="basic-domain-model1_en.html">2. Basic domain model (1)</a> |&nbsp;<a
        class="wiki_link" href="basic-domain-model2_en.html">3. Basic domain model (2)</a> | <a
        class="wiki_link" href="refining-user-interface_en.html">4. Refining the user interface</a> | <a
        class="wiki_link" href="agile-development_en.html">5. Agile development</a> | <a
        class="wiki_link" href="mapped-superclass-inheritance_en.html">6. Mapped superclass inheritance</a> | <a
        class="wiki_link" href="entity-inheritance_en.html">7. Entity inheritance</a> | <a
        class="wiki_link" href="view-inheritance_en.html">8. View inheritance</a> | <a
        class="wiki_link" href="java-properties_en.html">9. Java properties</a> | <a
        class="wiki_link" href="calculated-properties_en.html">10. Calculated properties </a> | <a
        class="wiki_link" href="defaultvaluecalculator-in-collections_en.html">11. @DefaultValueCalculator in collections</a><strong> </strong> | <a
        class="wiki_link" href="calculation-and-collections-total_en.html">12. </a><a
        class="wiki_link" href="calculation-and-collections-total_en.html">@Calculation and collections totals</a> | <a
        class="wiki_link" href="defaultvaluecalculator-from-file_en.html">13. @DefaultValueCalculator from file</a> | <a
        class="wiki_link" href="manual-schema-evolution_en.html">14. Manual schema evolution</a> | <a
        class="wiki_link" href="multi-user-default-value-calculation_en.html">15. Multi user default value calculation</a> | <a
        class="wiki_link" href="synchronize-persistent-and-computed-properties_en.html">16. Synchronize persistent and computed propierties</a> | <a
        class="wiki_link" href="logic-from-database_en.html">17. Logic from database&nbsp;</a> |<span
        style="color: #0000ee;"></span><span style="color: #0000ee;"> </span><a
        class="wiki_link" href="validating-with-entityvalidator_en.html">18. Validating with @EntityValidator&nbsp;</a> |&nbsp; <a
        class="wiki_link" href="validation-alternatives_en.html">19. Validation alternatives&nbsp;</a> | <a
        class="wiki_link" href="validation-on-remove_en.html">20. Validation on remove&nbsp;</a> |&nbsp;<a
        class="wiki_link" href="custom-bean-validation-annotation_en.html"> 21. Custom Bean Validation annotation&nbsp;</a> | <a
        class="wiki_link" href="rest-service-call-from-validation_en.html">22. REST service call from validation&nbsp;</a> | <a
        class="wiki_link" href="attributes-in-annotations_en.html">23. Attributes in annotations&nbsp;</a> | <a
        class="wiki_link" href="refining-standard-behavior_en.html">24. Refining the standard behavior</a> | <a
        class="wiki_link" href="business-logic-behavior_en.html">25. Behavior &amp; business logic</a> | <a
        class="wiki_link" href="references-collections_en.html">26. References &amp; collections</a> | <a
        class="wiki_link" href="philosophy_en.html">A. Architecture &amp; philosophy</a> | <a
        class="wiki_link" href="jpa_en.html">B. Java Persistence API</a> | <a
        class="wiki_link" href="annotations_en.html">C. Annotations</a> |<a
        class="wiki_link" href="basic-domain-model2_en.html"></a> <strong>D. Automated testing </strong>
      <hr>
      <div id="toc">
        <h1 class="nopad">Table of contents</h1>
        <div style="margin-left: 1em;"><a href="#Lesson%203:%20Automated%20testing">Appendix D: Automated testing</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%203:%20Automated%20testing-JUnit">JUnit</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%203:%20Automated%20testing-ModuleTestBase%20for%20testing%20the%20modules">ModuleTestBase for testing the modules</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%203:%20Automated%20testing-ModuleTestBase%20for%20testing%20the%20modules-The%20code%20for%20the%20test">The code for the test</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%203:%20Automated%20testing-ModuleTestBase%20for%20testing%20the%20modules-Executing%20the%20tests%20from%20OpenXava%20Studio">Executing the tests from OpenXava Studio</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%203:%20Automated%20testing-Creating%20test%20data%20using%20JPA">Creating test data using JPA</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%203:%20Automated%20testing-Creating%20test%20data%20using%20JPA-Using%20setUp%28%29%20and%20tearDown%28%29%20methods">Using setUp() and tearDown() methods</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%203:%20Automated%20testing-Creating%20test%20data%20using%20JPA-Creating%20data%20with%20JPA">Creating data with JPA</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%203:%20Automated%20testing-Creating%20test%20data%20using%20JPA-Removing%20data%20with%20JPA">Removing data with JPA</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%203:%20Automated%20testing-Creating%20test%20data%20using%20JPA-Filtering%20data%20from%20list%20mode%20in%20a%20test">Filtering data from list mode in a test</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%203:%20Automated%20testing-Creating%20test%20data%20using%20JPA-Using%20entity%20instances%20inside%20a%20test">Using entity instances inside a test</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%203:%20Automated%20testing-Using%20existing%20data%20for%20testing">Using existing data for testing</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%203:%20Automated%20testing-Testing%20collections">Testing collections</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%203:%20Automated%20testing-Testing%20collections-Breaking%20down%20tests%20in%20several%20methods">Breaking down tests in several methods</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%203:%20Automated%20testing-Testing%20collections-Asserting%20default%20values">Asserting default values</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%203:%20Automated%20testing-Testing%20collections-Data%20entry">Data entry</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%203:%20Automated%20testing-Testing%20collections-Verifying%20the%20data">Verifying the data</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%203:%20Automated%20testing-Suite">Suite</a></div>
        <div style="margin-left: 2em;"><a href="#source-code-until-lesson-5">Source code until lesson 5</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%204:%20Inheritance-Inheritance%20in%20JUnit%20tests">Inheritance in JUnit tests</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Inheritance%20in%20JUnit%20tests-Creating%20an%20abstract%20module%20test">Creating an abstract module test</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Inheritance%20in%20JUnit%20tests-Using%20the%20abstract%20module%20test%20to%20create%20concrete%20module%20tests">Using the abstract module test to create concrete module tests</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Inheritance%20in%20JUnit%20tests-Adding%20new%20tests%20to%20the%20extended%20module%20test">Adding new tests to the extended module test</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%205:%20Basic%20business%20logic-JUnit%20tests">Testing basic business logic</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%205:%20Basic%20business%20logic-JUnit%20tests-Modifying%20existing%20tests">Modifying existing tests</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%205:%20Basic%20business%20logic-JUnit%20tests-Testing%20default%20values,%20calculated%20and%20@Calculation%20properties">Testing default values, calculated and @Calculation properties</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%205:%20Basic%20business%20logic-JUnit%20tests-Testing%20@Formula">Testing @Formula</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%205:%20Basic%20business%20logic-JUnit%20tests-Testing%20calculated%20and%20persistent%20synchronized%20properties">Testing calculated and persistent synchronized properties</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%206:%20Advanced%20validation-JUnit%20tests">Testing validation</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-JUnit%20tests-Testing%20validation%20for%20adding%20to%20a%20collection">Testing validation for adding to a collection</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-JUnit%20tests-Testing%20validation%20assigning%20a%20reference%20and%20validation%20on%20removal">Testing validation assigning a reference and validation on removal</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-JUnit%20tests-Testing%20the%20custom%20Bean%20Validation">Testing the custom Bean Validation</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-JUnit%20tests">Testing of refining the standard behavior</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-JUnit%20tests-Testing%20the%20customized%20delete%20behavior">Testing the customized delete behavior</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%207:%20Refining%20the%20standard%20behavior-JUnit%20tests-Testing%20several%20modules%20in%20the%20same%20test%20method">Testing several modules in the same test method</a></div>
        <div style="margin-left: 2em;"><a href="#testing-behavior-business-logic">Testing behavior &amp; business logic</a></div>
        <div style="margin-left: 3em;"><a href="#testing-the-detail-mode-action">Testing the detail mode action</a></div>
        <div style="margin-left: 3em;"><a href="#finding-an-entity-for-testing-using-list-mode-and-jpa">Finding an entity for testing using list mode and JPA</a></div>
        <div style="margin-left: 3em;"><a href="#testing-hiding-of-the-action">Testing hiding of the action</a></div>
        <div style="margin-left: 3em;"><a href="#testing-the-list-mode-action">Testing the list mode action</a></div>
        <div style="margin-left: 3em;"><a href="#asserting-test-data">Asserting test data</a></div>
        <div style="margin-left: 3em;"><a href="#testing-exceptional-cases">Testing exceptional cases</a></div>
        <div style="margin-left: 2em;"><a href="#testing-references-collections">Testing references &amp; collections<br>
          </a></div>
        <div style="margin-left: 3em;"><a href="#adapting-ordertest">Adapting OrderTest</a></div>
        <div style="margin-left: 3em;"><a href="#testing-the-searchaction">Testing the @SearchAction</a></div>
        <div style="margin-left: 3em;"><a href="#testing-the-onchangesearch">Testing the @OnChangeSearch</a></div>
        <div style="margin-left: 3em;"><a href="#adapting-invoicetest">Adapting InvoiceTest</a></div>
        <div style="margin-left: 3em;"><a href="#testing-the-addaction">Testing the @AddAction</a></div>
        <div style="margin-left: 3em;"><a href="#testing-the-action-to-add-elements-to-the-collection">Testing the action to add elements to the collection</a></div>
        <div style="margin-left: 2em;"><a href="#junit4-support">JUnit 4 support (since v7.6.2)</a></div>
        <div style="margin-left: 2em;"><a href="#summary">Summary</a></div>
      </div>
      Good testing is the most important part of software development. It does not matter how beautiful, or fast, or high-tech your application is, if it crashes, you leave a poor impression and, crucially, your customer can lose valuable data.<br>
      Manual testing of the application as an end user is not a viable way to test, because the real problem is not the code you have written, but the existing code. Usually you test the code you have just written, but you do not retest all the already existing code in your application. And you know that when you touch any part of the code you can break any other part of the application.<br>
      While making any changes to your code, you want to handle it with the immense responsibility to keep the application from breaking. The best way to accomplish this is by using automatic testing. We are going to use automatic testing by means of JUnit.</div>
    <div class="wiki" style="display: block;"><b><span style="color: green;">The source code below is to write on top of code from section <i>Modeling with Java</i> (until lesson 5), until new notice.</span></b><br>
      <h2 id="toc1"><a name="Lesson 3: Automated testing-JUnit"></a>JUnit</h2>
      JUnit is a popular tool for doing automated testing. This tool comes integrated with OpenXava Studio, so you do not need to download it. OpenXava extends the capacities of JUnit, allowing you to test an OpenXava module exactly in the same way an end user would. In fact, OpenXava uses HtmlUnit, software that simulates a real browser (including JavaScript) from Java. All this is available from the OpenXava class <em>ModuleTestBase</em>. It allows you to automate the test you would do by hand using a real browser in a simple way.<br>
      The best way to understand testing in OpenXava is to see it in action.<br>
      <h2 id="toc2"><a name="Lesson 3: Automated testing-ModuleTestBase for testing the modules"></a>ModuleTestBase for testing the modules</h2>
      The way to create a test for an OpenXava module is by extending the <em>ModuleTestBase</em> class from <em>org.openxava.tests</em> package. It connects to the OpenXava module as a real browser, and has a lot of methods that allows you to test your module. Let's create the test for your <em>Customer</em> module.<br>
      <h3 id="toc3"><a name="Lesson 3: Automated testing-ModuleTestBase for testing the modules-The code for the test"></a>The code for the test</h3>
      Create a new package named <em>com.yourcompany.invoicing.tests</em> and then create a new class named <em>CustomerTest</em> inside it with the next code:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.tests;
 
import org.openxava.tests.*;
 
public class CustomerTest extends ModuleTestBase { // Must extend from ModuleTestBase
 
    public CustomerTest(String testName) {
        super(testName, "invoicing", // We indicate the application name (invoicing)
                "Customer"); // and the module name (Customer)
    }
 
    // The test methods must start with 'test'
    public void testCreateReadUpdateDelete() throws Exception {
        login("admin", "admin"); // The user sign in to access the module
 
        // Create
        execute("CRUD.new"); // Clicks on 'New' button
        setValue("number", "77"); // Types 77 as the value for the 'number' field
        setValue("name", "JUNIT Customer"); // Sets the value for the 'name' field
        setValue("address.street", "JUNIT Street"); // Note the dot notation
                                                // to access a reference member
        setValue("address.zipCode", "77555"); // Etc
        setValue("address.city", "The JUNIT city"); // Etc
        setValue("address.state", "The JUNIT state"); // Etc
        execute("CRUD.save"); // Clicks on 'Save' button
        assertNoErrors(); // Verifies that the application does not show errors
        assertValue("number", ""); // Verifies the 'number' field is empty
        assertValue("name", ""); // Verifies the 'name' field is empty
        assertValue("address.street", ""); // Etc
        assertValue("address.zipCode", ""); // Etc
        assertValue("address.city", ""); // Etc
        assertValue("address.state", ""); // Etc
 
        // Read
        setValue("number", "77"); // Types 77 as the value for the 'number' field
        execute("CRUD.refresh"); // Clicks on 'Refresh' button
        assertValue("number", "77"); // Verifies the 'number' field has 77
        assertValue("name", "JUNIT Customer"); // and 'name' has 'JUNIT Customer'
        assertValue("address.street", "JUNIT Street"); // Etc
        assertValue("address.zipCode", "77555"); // Etc
        assertValue("address.city", "The JUNIT city"); // Etc
        assertValue("address.state", "The JUNIT state"); // Etc
 
        // Update
        setValue("name", "JUNIT Customer MODIFIED"); // Changes the value
                                                    // of 'name' field
        execute("CRUD.save"); // Clicks on 'Save' button
        assertNoErrors(); // Verifies that the application does not show errors
        assertValue("number", ""); // Verifies the 'number' field is empty
        assertValue("name", ""); // Verifies the 'name' field is empty
 
        // Verify if modified
        setValue("number", "77"); // Types 77 as the value for 'number' field
        execute("CRUD.refresh"); // Clicks on 'Refresh' button
        assertValue("number", "77"); // Verifies the 'number' field has 77
        assertValue("name", "JUNIT Customer MODIFIED"); // and 'name'
                                        // has 'JUNIT Customer MODIFIED'
 
        // Delete
        execute("CRUD.delete"); // Clicks on 'Delete' button
        assertMessage("Customer deleted successfully"); // Verifies that the
                // message 'Customer deleted successfully' is shown to the user
    }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;"> This test creates a new customer, searches it, modifies it, and finally deletes it. You see how you can use methods such as <em>execute()</em> or <em>setValue()</em> for simulating user actions, and the methods like <em>assertValue()</em>, <em>assertNoErrors()</em> or <em>assertMessage()</em> to verify the state of the user interface. Your test acts as the hands and eyes of the user:<br>
      <img src="files/testing_en010.png" alt="testing_en010.png" title="testing_en010.png"><br>
      In <em>execute()</em> you must specify the qualified name of the action, that means <em>ControllerName.actionName</em>. How can you know it? Simple, put your mouse over an action link, and you will see in the status bar of your browser a JavaScript code that includes the qualified action name:<br>
      <img src="files/testing_en020.png" alt="testing_en020.png" title="testing_en020.png"><br>
      Now, you know how to create a test for testing the basic CRUD operations of a module. It's not required to write an exhaustive test at first. Just test the basic things, those that you usually test using the browser. Your test will naturally grows with your application and as the user feedback grows.<br>
      <br>
      <strong>Note:</strong> Since version 7.6.2, you can also write tests using <a href="#junit4-support">JUnit 4 style</a> with annotations.<br>
      <br>
      Let's learn how to execute your test from OpenXava Studio.<br>
      <h3 id="toc4"><a name="Lesson 3: Automated testing-ModuleTestBase for testing the modules-Executing the tests from OpenXava Studio"></a>Executing the tests from OpenXava Studio</h3>
      As mentioned earlier, JUnit is integrated into OpenXava Studio, so running your tests is plain vanilla. In order your test works your application must be running, if not start it first. Then run the test with the mouse over the test class, and with the right button choose <em>Run As &gt; JUnit Test</em>:<br>
      <img src="files/testing_en030.png" alt="testing_en030.png" title="testing_en030.png"
        style="height: 288px; width: 800px;"><br>
      If the test does not pass, the bar will be red. You can try it. Edit the <em>CustomerTest</em> and comment the line that sets the value for the <em>name</em> field:<br>
    </div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">...
setValue("number", "77");
// setValue("name", "JUNIT Customer"); // Comment this line
setValue("address.street", "JUNIT Street");
...
</code></pre> </div>
    <div class="wiki" style="display: block;">Now, rerun the test. Since <em>name</em> is a required property, an error message will be shown to the user, and the object will not be saved:<br>
      <img src="files/testing_en040.png" alt="testing_en040.png" title="testing_en040.png"><br>
      The failed assert is <em>assertNoErrors()</em>, which in addition to failure shows the error on the console. So, in the execution console of your test you will see the message like this one:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="plaintext">16-jul-2019 18:03 org.openxava.tests.ModuleTestBase assertNoMessages
SEVERE: Error unexpected: Value for Name in Customer is required
</code></pre> </div>
    <div class="wiki" style="display: block;">
      <style type="text/css"><!--
/**
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 */
.text  {font-family:monospace;}
.text .imp {font-weight: bold; color: red;}
.text span.xtra { display:block; }

-->
</style> The problem is clear. The customer is not saved because the name is required, and it's not specified.<br>
      You have seen how the test behaves when it fails. Now, you can uncomment back the guilty line and run the test again to verify that everything is OK.<br>
      <h2 id="toc5"><a name="Lesson 3: Automated testing-Creating test data using JPA"></a>Creating test data using JPA</h2>
      In your first test, <em>CustomerTest</em>, the test itself starts creating the data that is used in the rest of the test. This is a good way to go, especially if you want to test the data entry functionality too. But, if you want to test only a small buggy case, or your module simply does not allow adding new objects, you can create the data you need for testing using JPA from your test.<br>
      <h3 id="toc6"><a name="Lesson 3: Automated testing-Creating test data using JPA-Using setUp() and tearDown() methods"></a>Using setUp() and tearDown() methods</h3>
      We are going to use <em>ProductTest</em> to learn how to use JPA for creating test data. We'll create some products before each test execution and remove them afterwards. Let's see the code for <em>ProductTest</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.tests;
 
import java.math.*;
import com.yourcompany.invoicing.model.*;
import org.openxava.tests.*;
import static org.openxava.jpa.XPersistence.*;
 
public class ProductTest extends ModuleTestBase {
 
    private Author author; // We declare the entities to be created
    private Category category; // as instance members in order
    private Product product1; // to be available from inside any test method
    private Product product2; // and to be removed at the end of each test
 
    public ProductTest(String testName) {
        super(testName, "invoicing", "Product");
    }
 
    protected void setUp() throws Exception { // setUp() is always executed
                                              // before each test
        super.setUp(); // It's needed because ModuleTestBase uses it for
                        // initializing, even JPA is initialized here.
        createProducts(); // Creates the data used in the tests
    }
 
    protected void tearDown() throws Exception { // tearDown() is always
                                                 // executed after each test
        super.tearDown(); // It's needed, ModuleTestBase closes resources here
        removeProducts(); // The data used for testing is removed
    }
 
    public void testRemoveFromList() throws Exception { ... }
 
    public void testUploadPhotos() throws Exception { ... }
 
    private void createProducts() { ... }
 
    private void removeProducts() { ... }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Here we are overwriting the <em>setUp()</em> and <em>tearDown()</em> methods. These methods are JUnit methods that are executed just before and after each test execution. We create the testing data before each test execution, and remove the data after each test execution. Thus, each test can rely on the precise data to be executed. It does not matter if some other test removes or modifies the data, or the execution order of the test. Always, at the beginning of each test we have all the data ready to use.<br>
      <h3 id="toc7"><a name="Lesson 3: Automated testing-Creating test data using JPA-Creating data with JPA"></a>Creating data with JPA</h3>
      The <em>createProducts()</em> method is responsible for creating the test data using JPA. Let's examine it:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void createProducts() {
    // Creating the Java objects
    author = new Author(); // Regular Java objects are created
    author.setName("JUNIT Author"); // We use setters just as in plain Java
    category = new Category();
    category.setDescription("JUNIT Category");
    product1 = new Product();
    product1.setNumber(900000001);
    product1.setDescription("JUNIT Product 1");
    product1.setAuthor(author);
    product1.setCategory(category);
    product1.setPrice(new BigDecimal("10"));
    product2 = new Product();
    product2.setNumber(900000002);
    product2.setDescription("JUNIT Product 2");
    product2.setAuthor(author);
    product2.setCategory(category);
    product2.setPrice(new BigDecimal("20"));
 
    // Marking as persistent objects
    getManager().persist(author); // getManager() is from XPersistence
    getManager().persist(category); // persist() marks the object as persistent
    getManager().persist(product1); // so it will be saved to the database
    getManager().persist(product2);
 
    // Commit changes to the database
    commit(); // commit() is from XPersistence. It saves all object to the database
              // and commits the transaction
}
</code></pre> </div>
    <div class="wiki" style="display: block;">As you can see, first you create the Java objects in the Java conventional way. Note that you assign it to instance members. Thus you can use it inside tests. Then, you mark them as persistent, using the <em>persist()</em> method of the JPA <em>EntityManager</em>. To obtain the <em>EntityManager</em> you only have to write <em>getManager()</em> because you have the static import above:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import static org.openxava.jpa.XPersistence.*;
...
getManager().persist(author);
    // Thanks to the XPersistence static import it's the same as
XPersistence.getManager().persist(author);
...
commit();
    // Thanks to the XPersistence static import it's the same as
XPersistence.commit();
</code></pre> </div>
    <div class="wiki" style="display: block;">To finalize, <em>commit()</em> (also from <em>XPersistence</em>) saves all the data from objects to database and then commits the transaction. After that, the data is in the database ready to be used by your test.<br>
      <h3 id="toc8"><a name="Lesson 3: Automated testing-Creating test data using JPA-Removing data with JPA"></a>Removing data with JPA</h3>
      After the test is executed we remove the test data in order to leave the database clean. This is done by the <em>removeProducts()</em> method:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void removeProducts() { // Called from tearDown() so it's executed
                                // after each test
    remove(product1, product2, author, category); // remove() removes
    commit(); // Commits the changes to database, in this case deleting data
}
 
private void remove(Object ... entities) { // Using varargs argument
    for (Object entity : entities) { // Iterating for all arguments
        getManager().remove(getManager().merge(entity)); // Removing(1)
    }
}
</code></pre> </div>
    <div class="wiki" style="display: block;">It's a simple loop to remove all the entities used in the test. To remove an entity in JPA you have to use the <em>remove()</em> method, but in this case you have to use the <em>merge()</em> method too (shown as 1). This is because you cannot remove a detached entity. When you use <em>commit()</em> in <em>createProducts()</em> all saved entities become detached entities. This is because they continue being valid Java object but the persistent context (the union between entities and database) has been lost on <em>commit()</em>, so you must reattach them to the new persistent context. This concept is easy to understand seeing the next code:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">getManager().persist(author); // author is attached to the current persistence context
commit(); // The current persistence context is over, so author becomes detached
 
getManager().remove(author); // It fails because author is detached
 
author = getManager().merge(author); // Reattaches author to the current context
getManager().remove(author); // It works
</code></pre> </div>
    <div class="wiki" style="display: block;">Apart from this curious detail about <em>merge()</em>, the code for removing is quite simple.<br>
      <h3 id="toc9"><a name="Lesson 3: Automated testing-Creating test data using JPA-Filtering data from list mode in a test"></a>Filtering data from list mode in a test</h3>
      Now that you know how to create and remove the data for the tests, let's examine the test methods for your <em>Product</em> module. The first one is <em>testRemoveFromList()</em> that checks a row in list mode and clicks on <i>Delete selected</i> button. Let's see the code:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">public void testRemoveFromList() throws Exception {
    login("admin", "admin");
    setConditionValues("", "JUNIT"); // Put the values for filtering data
    setConditionComparators("=", "contains_comparator"); // Put the comparators for filtering data
    execute("List.filter"); // Clicks on filter button
    assertListRowCount(2); // Verifies that there are 2 rows
    checkRow(1); // We select row 1 (really the second one)
    execute("CRUD.deleteSelected"); // Clicks on the delete button
    assertListRowCount(1); // Verifies that now there is only 1 row
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Here we filter in list mode all products that contain the “JUNIT” word (remember that you have created two of them in <em>createProducts()</em> method), then we verify that there are two rows, select the second product, and remove it, verifying at the end that one product remains in the list.<br>
      You have learned how to select a row (using <em>checkRow()</em>) and how to assert the row count (using <em>assertListRowCount()</em>). The trickiest part might be filtering the list using <em>setConditionValues()</em> and <em>setConditionComparators()</em>. Both methods receive a variable number of string arguments with values and comparators for the condition, just as shown here:<br>
      <img src="files/testing_en050.png" alt="testing_en050.png" title="testing_en050.png"><br>
      The values are assigned to the list filter user interface sequentially (from left to right). In this case there are two values, but you can use all you need. You do not need to specify all values. The <em>setConditionValues()</em> method accepts any string value whereas <em>setConditionComparators()</em> accepts the next possible values: <em><em> contains_comparator, </em>starts_comparator, ends_comparator, not_contains_comparator, empty_comparator, not_empty_comparator, =, &lt;&gt;, &gt;=, &lt;=, &gt;,</em> <em>&lt;</em>, <em>in_comparator</em>, <em>not_in_comparator</em> and <em>range_comparator</em>.<br>
      <h3 id="toc10"><a name="Lesson 3: Automated testing-Creating test data using JPA-Using entity instances inside a test"></a>Using entity instances inside a test</h3>
      The remaining test, <em>testUploadPhotos()</em>, chooses a product and upload photos on it. We are going to use in the test an entity created in <em>createProducts()</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">public void testUploadPhotos() throws Exception { 
	login("admin", "admin");
 
	// Searching the product1
	execute("CRUD.new");
	setValue("number", Integer.toString(product1.getNumber())); // (1)
	execute("CRUD.refresh");
	assertFilesCount("photos", 0);
 
	// Uploading photos
	uploadFile("photos", "web/xava/images/add.gif"); // (2)
	uploadFile("photos", "web/xava/images/attach.gif"); // (2)
 
	// Verifying
	execute("CRUD.new");
	assertFilesCount("photos", 0);
	setValue("number", Integer.toString(product1.getNumber())); // (1)
	execute("CRUD.refresh");
	assertFilesCount("photos", 2);
	assertFile("photos", 0, "image");
	assertFile("photos", 1, "image");
	
	// Remove photos
	removeFile("photos", 1);
	removeFile("photos", 0);
}
</code></pre> </div>
    <div class="wiki" style="display: block;">The interesting thing in this test is to provide a value to number to search the product. We get the value using <em>product1.getNumber()</em> (shown as 1). Remember that <em>product1</em> is an instance variable of the test that is populated in <em>createProducts()</em>, which is called from <em>setUp()</em> so it is executed before each test. Also you have learned how to use the methods <i>uploadFile(), assertFileCount(), assertFile()</i> and <i>removeFile()</i> to work with photos. These methods work with any property that uploads files (IMAGES_GALLERY, PHOTO, IMAGE, FILE, FILES, etc). In this case we use images included in OpenXava, gifs from <i>web/xava/images </i>(shown as 2), but you can create your own folder with your own images for testing.<br>
      <br>
      You have a test class for <em>Product</em> and at the same time you have learned testing with test data created using JPA. Run it, it should be green.<br>
      <h2 id="toc11"><a name="Lesson 3: Automated testing-Using existing data for testing"></a>Using existing data for testing</h2>
      Sometimes you can simplify the test by relying on a test database which is populated with the data needed for testing. If you do not want to test data creation from the module itself, and you do not remove data in the test, this can be a good option.<br>
      For example, you can test <em>Author</em> and <em>Category</em> with a simple test like this one:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.tests;
 
import org.openxava.tests.*;
 
public class AuthorTest extends ModuleTestBase {
    public AuthorTest(String testName) {
        super(testName, "invoicing", "Author");
    }
 
    public void testReadAuthor() throws Exception {
        login("admin", "admin");
        assertValueInList(0, 0, "JAVIER CORCOBADO"); // The first author
                                        // in the list is JAVIER CORCOBADO
        execute("List.viewDetail", "row=0"); // We click the first object in the list
        assertValue("name", "JAVIER CORCOBADO");
        assertCollectionRowCount("products", 2); // It has 2 products
        assertValueInCollection("products", 0, // Row 0 of products
                                "number", "2"); // has “2” in “number” column
        assertValueInCollection("products", 0, "description", "Arco iris de lágrimas");
        assertValueInCollection("products", 1, "number", "3");
        assertValueInCollection("products", 1, "description", "Ritmo de sangre");
    }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">This test verifies that the first author in the list is “JAVIER CORCOBADO”, remember to create it before executing the test. It goes to the detail and asserts that it has a collection called "products" with 2 products: “Arco iris de lágrimas” and “Ritmo de sangre”, before executing the test create them and associate them to "JAVIER CORCOBADO". By the way, now you have learned how to use <em>assertValueInList()</em>, <em>assertValueInCollection()</em> and <em>assertCollectionRowCount()</em> methods.<br>
      We can use the same technique to test the <em>Category</em> module:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.tests;
 
import org.openxava.tests.*;
 
public class CategoryTest extends ModuleTestBase {
 
    public CategoryTest(String testName) {
        super(testName, "invoicing", "Category");
    }
 
    public void testCategoriesInList() throws Exception {
        login("admin", "admin");
        assertValueInList(0, 0, "MUSIC"); // Row 0 column 0 has “MUSIC”
        assertValueInList(1, 0, "BOOKS"); // Row 1 column 0 has “BOOKS”
        assertValueInList(2, 0, "SOFTWARE"); // Row 2 column 0 has “SOFTWARE”
    }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">In this case we see that in the list the first three categories are “MUSIC”, “BOOKS” and “SOFTWARE”. Remember to create them before executing the test.<br>
      You have seen how the technique of using pre-existing data from a test database allows you to create simpler tests. Starting from a simple test and further complicating it on demand is a good way to go. </div>
    <div class="wiki" style="display: block;">Remember to add the corresponding data using the modules before executing these tests.<br>
      <h2 id="toc12"><a name="Lesson 3: Automated testing-Testing collections"></a>Testing collections</h2>
      Now it's time to face the test for the main module of your application, the <em>InvoiceTest</em>. As of now the functionality of the <em>Invoice</em> module is limited. You can only add, remove and modify invoices. Even so, this is a big test. It contains a collection, so you will learn here how to test collections.<br>
      <h3 id="toc13"><a name="Lesson 3: Automated testing-Testing collections-Breaking down tests in several methods"></a>Breaking down tests in several methods</h3>
      The test for creating an <em>Invoice</em> is broken down into several methods:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.yourcompany.invoicing.tests;
 <br>import java.time.*;
import java.time.format.*;<br>import javax.persistence.*;
import org.openxava.tests.*;
import static org.openxava.jpa.XPersistence.*; // To use JPA
 
public class InvoiceTest extends ModuleTestBase {
 
    private String number; // To store the number of the tested invoice
 
    public InvoiceTest(String testName) {
        super(testName, "invoicing", "Invoice");
    }
 
    public void testCreate() throws Exception { // The test method
        login("admin", "admin");
        verifyDefaultValues();
        chooseCustomer();
        addDetails();
        setOtherProperties();
        save();
        verifyCreated();
        remove();
    }
 
    private void verifyDefaultValues() throws Exception { … }
 
    private void chooseCustomer() throws Exception { … }
 
    private void addDetails() throws Exception { … }
 
    private void setOtherProperties() throws Exception { … }
 
    private void save() throws Exception { … }
 
    private void verifyCreated() throws Exception { … }
 
    private void remove() throws Exception { … }
 
    private String getCurrentYear() { … }
 
    private String getCurrentDate() { … }
 
    private String getNumber() { … }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">The only test method in this class is <em>testCreate()</em>, but because this test is somewhat large, it is better to break it down into several shorter methods. In fact, it's a good object-oriented practice to write short methods.<br>
      Because this method is short you can see in a glance what it does. In this case the method verifies the default values for a new invoice, chooses a customer, adds the details, adds other properties, saves the invoice, verifies that it is correctly saved and finally deletes it. Let's dip into the details of these steps.<br>
      <h3 id="toc14"><a name="Lesson 3: Automated testing-Testing collections-Asserting default values"></a>Asserting default values</h3>
      First, it verifies whether the default values for a new invoice are correctly calculated or not. This is done by the <em>verifyDefaultValues()</em> method:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void verifyDefaultValues() throws Exception {
    execute("CRUD.new");
    assertValue("year", getCurrentYear());
    assertValue("number", getNumber());
    assertValue("date", getCurrentDate());
}
</code></pre> </div>
    <div class="wiki" style="display: block;">When the user clicks on <i>New</i>, the year, number and date field must be prefilled with valid data. The <em>verifyDefaultValues()</em> method tests this. It uses several utility methods to calculate the expected values:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private String getCurrentYear() { // Current year in string format
    return Integer.toString(LocalDate.now().getYear()); // The standard
                                                    // way to do it with Java
}
 
private String getCurrentDate() { // Current date as string in short format
    return LocalDate.now().format( // The standard way to do it with Java
        DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT));
}
 
private String getNumber() { // The invoice number for a new invoice
    if (number == null) { // We use lazy initialization
        Query query = getManager(). // A JPA query to get the last number
                createQuery("select max(i.number) from Invoice i where i.year = :year");
        query.setParameter("year", LocalDate.now().getYear());
        Integer lastNumber = (Integer) query.getSingleResult();
        if (lastNumber == null) lastNumber = 0;
        number = Integer.toString(lastNumber + 1); // Adding 1 to the last invoice number
    }
    return number;
}
</code></pre> </div>
    <div class="wiki" style="display: block;">The <em>getCurrentYear()</em> and <em>getCurrentDate()</em> methods use classic Java techniques to format the date as string.<br>
      The <em>getNumber()</em> method, on the other hand, is a little more complex. It uses JPA to calculate the last invoice number of the current year, then return this value plus one. Due to its access to the database it is heavier than a simple Java calculation, therefore we use lazy initialization. Lazy initialization delays the calculation until the first time it is needed, and stores it for future use. We do it by saving the value in the number field.<br>
      <h3 id="toc15"><a name="Lesson 3: Automated testing-Testing collections-Data entry"></a>Data entry</h3>
      Now it's time for the <em>chooseCustomer()</em> method of the invoice:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void chooseCustomer() throws Exception {
    setValue("customer.number", "1");
    assertValue("customer.name", "JAVIER PANIZA"); // The customer 1 should exist in DB
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Upon entry of the customer number the customer name is simply filled with the appropriate value. Since the test relies on customer 1 with name "JAVIER PANIZA" existing already, you should create it before running the test. With this the customer 1 is associated to the current invoice.<br>
      And now comes the most tricky part of the test: adding the detail lines:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void addDetails() throws Exception {
    assertCollectionRowCount("details", 0); // The collection is empty
 
    // Adding a detail line
    setValueInCollection("details", 0, // 0 means the first row
        "product.number", "1");
    assertValueInCollection("details", 0,
        "product.description", "Peopleware: Productive Projects and Teams");
    setValueInCollection("details", 0, "quantity", "2");
 
    // Adding another detail
    setValueInCollection("details", 1, "product.number", "2");
    assertValueInCollection("details", 1, "product.description", "Arco iris de lágrimas");
    setValueInCollection("details", 1, "quantity", "1");
 
    assertCollectionRowCount("details", 2); // Now we have 2 rows
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Testing a collection is the same as testing any other part of your application. You have to follow the same steps as an end user with a browser. You have methods such as <em>setValueInCollection()</em>, <em>assertValueInCollection()</em> or <em>assertCollectionRowCount()</em> to work with collections. Note how these methods have the collection name as first argument, and some of them receive the row number with 0 based index. Remember to create the product 1 and 2 with the corresponding descriptions before executing this test.<br>
      Now that we have the details added, we are going to fill the remaining data and save the invoice. The remaining data is set by <em>setOtherProperties()</em> method:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void setOtherProperties() throws Exception {
    setValue("remarks", "This is a JUNIT test");
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Here we give a value to the <em>remarks</em> field. Now we are ready to save the invoice:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void save() throws Exception {
    execute("CRUD.save");
    assertNoErrors();
    assertValue("customer.number", "");
    assertCollectionRowCount("details", 0);
    assertValue("remarks", "");
}
</code></pre> </div>
    <div class="wiki" style="display: block;">It simply clicks on <i>Save</i>, then verifies for any errors and makes sure that the view is clean.<br>
      <h3 id="toc16"><a name="Lesson 3: Automated testing-Testing collections-Verifying the data"></a>Verifying the data</h3>
      Now, we will search the newly created invoice to verify that it has been saved correctly. This is done by the <em>verifyCreated()</em> method:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void verifyCreated() throws Exception {
    setValue("year", getCurrentYear()); // The current year to year field
    setValue("number", getNumber()); // The invoice number of the test
    execute("CRUD.refresh"); // Load the invoice back from the database
 
    // In the rest of the test we assert that the values are the correct ones
    assertValue("year", getCurrentYear());
    assertValue("number", getNumber());
    assertValue("date", getCurrentDate());
    assertValue("customer.number", "1");
    assertValue("customer.name", "JAVIER PANIZA");
    assertCollectionRowCount("details", 2);
 
    // Row 0
    assertValueInCollection("details", 0, "product.number", "1");
    assertValueInCollection("details", 0, "product.description",
        "Peopleware: Productive Projects and Teams");
    assertValueInCollection("details", 0, "quantity", "2");
 
    // Row 1
    assertValueInCollection("details", 1, "product.number", "2");
    assertValueInCollection("details", 1, "product.description",
        "Arco iris de lágrimas");
    assertValueInCollection("details", 1, "quantity", "1");
    assertValue("remarks", "This is a JUNIT test");
}
</code></pre> </div>
    <div class="wiki" style="display: block;">After searching the created invoice we verify whether the values we have saved are there. If the test reaches this point your <em>Invoice</em> module works fine. The only thing remaining is to delete the created invoice so that the test can be executed again. We do that in the <em>remove()</em> method:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void remove() throws Exception {
    execute("CRUD.delete");
    assertNoErrors();
}
</code></pre> </div>
    <div class="wiki" style="display: block;">It just clicks on <i>Delete</i> and verifies that no errors are produced.<br>
      <br>
      Congratulations! You have your <em>InvoiceTest</em> completed. Execute it, it should be green; if not revise the data in the database, maybe you have to add the corresponding products, customer, etc.<br>
      <h2 id="toc17"><a name="Lesson 3: Automated testing-Suite"></a>Suite</h2>
      You have 5 test cases to preserve the quality of your application. When you finish some enhancement or fix of your application you must execute all your tests to ensure that your already existing functionality is not broken.<br>
      Traditionally, to execute all the test for your application you have to create a test suite, and execute it. A test suite is a class that aggregates all your JUnit tests so you can execute them all at once. Fortunately, with OpenXava Studio you do not need to write a test suite class, it allows you to execute all the tests for your application automatically:<br>
      <img src="files/testing_en060.png" alt="testing_en060.png" title="testing_en060.png"><br>
      That is, if you execute <em>Run As &gt; JUnit Test</em> on the project then all its JUnit tests are executed.</div>
    <div class="wiki" style="display: block;">
      <h2><a name="source-code-until-lesson-5"></a>Source code until lesson 5</h2>
      <p>The above test code is to be applied on top of code of lesson 5. Here you can download the source code of lesson 5 but including the above testing code:</p>
      <p><strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-testing_en.zip/download"
            rel="nofollow">Download source code until lesson 5 with testing</a></strong></p>
      <p>All the source code to download from lessons above the 5 already include the testing code, that you can also look with explanation in the rest of this appendix. </p>
      <h2 id="toc14"><a name="Lesson 4: Inheritance-Inheritance in JUnit tests"></a>Inheritance in JUnit tests</h2>
      <b><span style="color: green;">The source code below is to write on top of code from section <i>Inheritance</i>, until new notice.</span></b><br>
    </div>
    <div class="wiki" style="display: block;"><em>Invoice</em> has been refactored to use inheritance, also we have used inheritance to add a new <em>Order</em> entity. Moreover, this <em>Order</em> entity has a relationship with <em>Invoice</em>. You have a lot of new functionality, therefore you must test all the new features.<br>
      Because <em>Invoice</em> and <em>Order</em> have a lot of common stuff (the <em>CommercialDocument</em> part) we can refactor the tests in order to use inheritance, thus you avoid the harmful “copy and paste” in your test code as well.<br>
      <h3 id="toc15"><a name="Lesson 4: Inheritance-Inheritance in JUnit tests-Creating an abstract module test"></a>Creating an abstract module test</h3>
      If you examine the test for creating an invoice, from the <em>testCreate()</em> method of <em>InvoiceTest</em>. You can note that testing the creation of an invoice is exactly the same to testing the creation of an order. Because, both have year, number, date, customer, details and remarks. So, here inheritance is a good tool for code reuse.<br>
      We are going to rename <em>InvoiceTest</em> as <em>CommercialDocumentTest</em>, then we'll create <em>InvoiceTest</em> and <em>OrderTest</em> from it. See the UML diagram for this idea:<br>
      <img src="files/inheritance_en100.png" alt="inheritance_en100.png"
        title="inheritance_en100.png"><br>
      First rename your current <em>InvoiceTest</em> class to <em>CommercialDocumentTest</em>, then make the changes indicated in the next code:<br>
      <pre><code class="java">package com.yourcompany.invoicing.tests;
 
import java.time.*;
import java.time.format.*;
import javax.persistence.*;
import org.openxava.tests.*;
import static org.openxava.jpa.XPersistence.*;<br><br>abstract public class CommercialDocumentTest // Add abstract to class definition
    extends ModuleTestBase {
 
    private String number;
 
    public CommercialDocumentTest(
        String testName,
        String moduleName) // moduleName added as constructor argument
    {
        super(testName, "invoicing", moduleName); // Send moduleName
    }
 
    public void testCreate() throws Exception { ... } // As original
 
    private void addDetails() throws Exception { ... } // As original
 
    private String getNumber() {
        if (number == null) {
            Query query = getManager().createQuery(
                "select max(i.number) from " +
                    "CommercialDocument i " + // Invoice changed for CommercialDocument
                    "i where i.year = :year");
            query.setParameter("year", LocalDate.now().getYear());
            Integer lastNumber = (Integer) query.getSingleResult();
            if (lastNumber == null)    lastNumber = 0;
            number = Integer.toString(lastNumber + 1);
        }
        return number;
    }
 
    private void remove() throws Exception { ... } // As original
 
    private void verifyCreated() throws Exception { ... } // As original
 
    private void save() throws Exception { ... } // As original
 
    private void setOtherProperties() throws Exception { ... } // As original
 
    private void chooseCustomer() throws Exception { ... } // As original
 
    private void verifyDefaultValues() throws Exception { ... } // As original
 
    private String getCurrentYear() { ... } // As original
 
    private String getCurrentDate() { ... } // As original
 
}
</code></pre> As you see you have to do a few changes in order to adapt <em>CommercialDocumentTest</em>. First, you declared it as an abstract class. This way this class is not executed by OpenXava Studio as a JUnit test. It is only valid as base class for creating tests, but it is not a test itself.<br>
      Another important change is in the constructor, where you now use <em>moduleName</em> instead of “Invoice”, thus you can use this test for <em>Order</em>, <em>Invoice</em> or whatever other module you want. The other change is a simple detail: you have to change “Invoice” for “CommercialDocument” in the query to get the next number.<br>
      Now you have a base class ready to create the module tests for <em>Order</em> and <em>Invoice</em>. Let's do it.<br>
      <h3 id="toc16"><a name="Lesson 4: Inheritance-Inheritance in JUnit tests-Using the abstract module test to create concrete module tests"></a>Using the abstract module test to create concrete module tests</h3>
      Creating your first version of <em>OrderTest</em> and <em>InvoiceTest</em> is just a matter of extending from <em>CommercialDocumentTest</em>. Nothing more. See the <em>InvoiceTest</em> code:<br>
      <pre><code class="java">package com.yourcompany.invoicing.tests;
 
public class InvoiceTest extends CommercialDocumentTest {
 
    public InvoiceTest(String testName) {
        super(testName, "Invoice");
    }
 
}
</code></pre> And <em>OrderTest</em>:<br>
      <pre><code class="java">package com.yourcompany.invoicing.tests;
 
public class OrderTest extends CommercialDocumentTest {
 
    public OrderTest(String testName) {
        super(testName, "Order");
    }
 
}
</code></pre> Execute these two tests and you will see how <em>testCreate()</em>, inherited from <em>CommercialDocumentTest</em>, is executed in both cases, against its corresponding module. With this we are testing the common behavior of <em>Order</em> and <em>Invoice</em>. Let's test the different cases for them.<br>
      <h3 id="toc17"><a name="Lesson 4: Inheritance-Inheritance in JUnit tests-Adding new tests to the extended module test"></a>Adding new tests to the extended module test</h3>
      So far we tested how to create an invoice and an order. In this section we'll test also how to add orders to an invoice in the <em>Invoice</em> module, and how to set the invoice to an order from the <em>Order</em> module.<br>
      To test how to add an order to an invoice, add the <em>testAddOrders()</em> method to <em>InvoiceTest</em>:<br>
      <pre><code class="java">// This test assumes that at least one invoice and order order already exist
public void testAddOrders() throws Exception {
    login("admin", "admin");
    assertListNotEmpty(); // This test assumes that some invoices already exist
    execute("List.orderBy", "property=number"); // To always work with the same order
    execute("List.viewDetail", "row=0"); // Goes to detail mode editing the first invoice
    execute("Sections.change", "activeSection=1"); // Changes to tab 1
    assertCollectionRowCount("orders", 0); // This invoice has no orders
    execute("Collection.add", // Clicks on the button for adding a new order, this takes
        "viewObject=xava_view_section1_orders"); // you to a list of orders
    execute("AddToCollection.add", "row=0"); // Chooses the first order in the list
    assertCollectionRowCount("orders", 1); // Order added to the invoice
    checkRowCollection("orders", 0); // Checks the order, to remove it
    execute("Collection.removeSelected", // Removes the recently added order
        "viewObject=xava_view_section1_orders");
    assertCollectionRowCount("orders", 0); // The order has been removed
}
</code></pre> In this case we rely on the fact that there is at least one invoice, and that the first invoice in the list has no orders. Before running this test, if you have no invoices, create one with no orders, or if you already have invoices, be sure that the first one has no orders.<br>
      To test how to assign an invoice to an order add the <em>testSetInvoice()</em> method to <em>OrderTest</em>:<br>
      <pre><code class="java">public void testSetInvoice() throws Exception {
    login("admin", "admin");
    assertListNotEmpty(); // This test assumes that some orders already exist
    execute("List.viewDetail", "row=0"); // Goes to detail mode editing the first invoice
    execute("Sections.change", "activeSection=1"); // Changes to tab 1
    assertValue("invoice.number", ""); // This order has no
    assertValue("invoice.year", ""); // invoice assigned yet
    execute("Reference.search", // Clicks on the button to search the invoice, this
        "keyProperty=invoice.year"); // takes you to a list of invoices
    execute("List.orderBy", "property=number"); // To sort the list of invoices
    String year = getValueInList(0, "year"); // Stores the year and number of
    String number = getValueInList(0, "number"); // the first invoice in the list
    execute("ReferenceSearch.choose", "row=0"); // Chooses the first invoice
    assertValue("invoice.year", year); // On return to order detail we verify
    assertValue("invoice.number", number); // the invoice has been selected
}
</code></pre> In this case we rely on the fact that there is at least one order, and that the first order in the list has no invoice. Before running this test, if you have no orders, create one with no invoice, or if you already have orders, be sure that the first one has no invoice.<br>
      With this you have your tests ready. Just execute them, and you'll get the next result:<br>
      <img src="files/inheritance_en110.png" alt="inheritance_en110.png"
        title="inheritance_en110.png"><br>
      Note that the base test <em>CommercialDocumentTest</em> is not shown because it is abstract. And the <em>testCreate()</em> method of <em>CommercialDocumentTest</em> is executed for both <em>InvoiceTest</em> and <em>OrderTest</em>.<br>
      Not only have you adapted your testing code to the improved code for <em>invoicing</em>, but you have also learned how to use inheritance in the test code as well. </div>
    <div class="wiki" style="display: block;">
      <h2 id="Lesson%205:%20Basic%20business%20logic-JUnit%20tests">Testing basic business logic</h2>
      <b><span style="color: green;">The source code below is to write on top of code from section <i>Basic business logic</i>, until new notice.</span></b></div>
    <div class="wiki" style="display: block;">We are going to write the JUnit code for the <i>Basic business logic</i> section. Remember, the code is not done if it has no tests. You can write the tests before, during or after coding. But you always have to write the tests.<br>
      The test code here is not only to give you a good example, but also to teach you ways to test different cases in your OpenXava application.<br>
      <h3 id="toc11"><a name="Lesson 5: Basic business logic-JUnit tests-Modifying existing tests"></a>Modifying existing tests</h3>
      Creating a new test for each new case seems like a good idea from a structural viewpoint, but in most cases it is not practical because in doing so your test code would grow very fast, and execution of all the tests for your application would take a substantial amount of time.<br>
      The more pragmatic approach is to modify the existing test code to cover all the new cases we have developed. Let's do it in this way.<br>
      In our case, most of the code for this lesson applies to <em>CommercialDocument</em>, so we are going to modify the <em>testCreate()</em> method of <em>CommercialDocumentTest</em> to match the new functionality. We leave the <em>testCreate()</em> method as you see in the next code:<br>
      <pre><code class="java">public void testCreate() throws Exception {
    login("admin", "admin");
    calculateNumber(); // Added to calculate the next document number first
    verifyDefaultValues();
    chooseCustomer();
    addDetails();
    setOtherProperties();
    save();
    verifyEstimatedProfit(); // To test @Formula
    verifyCreated();
    remove();
}
</code></pre> As you see, we add a new line in the beginning to calculate the next document number, and call the new <em>verifyEstimatedProfit()</em> method.<br>
      Now it's more convenient to calculate the next document number in the beginning to use it during the test. To do this, change the old <em>getNumber()</em> method for the following two methods:<br>
      <pre><code class="java">private void calculateNumber() {
    Query query = getManager().createQuery("select max(i.number) from " +
        model + // We change CommercialDocument for a variable
        " i where i.year = :year");
    query.setParameter("year", LocalDate.now().getYear());
    Integer lastNumber = (Integer) query.getSingleResult();
    if (lastNumber == null) lastNumber = 0;
    number = Integer.toString(lastNumber + 1);
}
 
private String getNumber() {
    return number;
}
</code></pre> Previously we only had <em>getNumber()</em> to calculate and return the number, now we have a method to calculate (<em>calculateNumber()</em>), and another one to return the result (<em>getNumber()</em>). You can note that the calculation logic has a little change, instead of using “CommercialDocument” as the source of the query we use <em>model</em>, a variable. This is because now the numeration for invoices and orders are separated. We fill this variable, a field of the test class, in the test constructor, just as shows in the next code:<br>
      <pre><code class="java">private String model; // The model name to use in the query. Can be “Invoice” or “Order”
 
public CommercialDocumentTest(String testName, String moduleName) {
    super(testName, "invoicing", moduleName);
    this.model = moduleName; // In this case module name matches model
}
</code></pre> In this case module name, <i>Invoice</i> or <i>Order</i>, coincides with model name, <i>Invoice</i> or <i>Order</i>, so the easiest way to get the model name is from the module name.<br>
      Let's see the actual testing of the new functionality.<br>
      <h3 id="toc12"><a name="Lesson 5: Basic business logic-JUnit tests-Testing default values, calculated and @Calculation properties"></a>Testing default values, calculated and <i>@Calculation</i> properties</h3>
      In this lesson we have done some modifications related to default values. Now the default value for number is not calculated by means of <em>@DefaultValueCalculator</em> instead we use a JPA callback method. To test this case we have to modify the <em>verifyDefaultValues()</em> method as you see:<br>
      <pre><code class="java">private void verifyDefaultValues() throws Exception {
    execute("CRUD.new");
    assertValue("year", getCurrentYear());
    // assertValue("number", getNumber()); // Now number has no initial value
    assertValue("number", ""); // on create a new document
    assertValue("date", getCurrentDate());
}
</code></pre>We verify that <i>number</i> the has no initial value, because now the number is not calculated until the document is saved (<a
        class="wiki_link" href="basic-business-logic_en.html#Lesson%205:%20Basic%20business%20logic-JPA%20callback%20methods-Multiuser%20safe%20default%20value%20calculation">Multiuser safe default value calculation</a> section). When the document (invoice or order) will be saved we'll verify that the <em>number</em> is calculated.
      <div class="wiki" style="display: block;">When the detail is added we can test the <em>amount</em> for <em>Detail</em> calculation (<a
          class="wiki_link" href="basic-business-logic_en.html#Lesson%205:%20Basic%20business%20logic-Calculated%20properties-Simple%20calculated%20property">Simple calculated property</a> section), the default value calculation for <em>pricePerUnit</em> (<a
          class="wiki_link" href="basic-business-logic_en.html#Lesson%205:%20Basic%20business%20logic-Calculated%20properties-Using%20@DefaultValueCalculator">Using @DefaultValueCalculator</a> section) and the amount properties of the document (<a
          class="wiki_link" href="basic-business-logic_en.html#Lesson%205:%20Basic%20business%20logic-Calculated%20properties-Total%20properties%20of%20a%20collection">Total properties of a collection</a> section). Among the total properties we test <i>vatPercentage</i> whose default value is calculated reading from a properties file. We'll test all this with a few modifications in the already existing <em>addDetails()</em> method:<br>
        <pre><code class="java">private void addDetails() throws Exception {
    assertCollectionRowCount("details", 0);<br><br>    // Before running this test code make sure<br>    //   product 1 has 19 as price, and <br>    //   product 2 has 20 as price<br><br>   &nbsp;// Adding a detail line
    setValueInCollection("details", 0, "product.number", "1");
    assertValueInCollection("details", 0,
        "product.description", "Peopleware: Productive Projects and Teams");
    assertValueInCollection("details", 0,
        "pricePerUnit", "19.00"); // @DefaultValueCalculator
    setValueInCollection("details", 0, "quantity", "2");
    assertValueInCollection("details", 0,
        "amount", "38.00"); // Calculated property, section 'Simple calculated property'
 
    // Verifying total properties of collection
    assertTotalInCollection("details", 0, "amount", "38.00"); // Sum of amounts using +
    assertTotalInCollection("details", 1, "amount", "21"); // Default value from properties file
    assertTotalInCollection("details", 2, "amount", "7.98"); // VAT, with @Calculation
    assertTotalInCollection("details", 3, "amount", "45.98"); // Total amount, with @Calculation
 
    // Adding another detail
    setValueInCollection("details", 1, "product.number", "2");
    assertValueInCollection("details", 1, "product.description", "Arco iris de lágrimas");
    assertValueInCollection("details", 1, "pricePerUnit", "20.00"); 
    setValueInCollection("details", 1, "pricePerUnit", "10.00"); // Modifying the default value
    setValueInCollection("details", 1, "quantity", "1");
    assertValueInCollection("details", 1, "amount", "10.00");
 
    assertCollectionRowCount("details", 2); // Now we have 2 rows
 
    // Verifying total properties of collection
    assertTotalInCollection("details", 0, "amount", "48.00");
    assertTotalInCollection("details", 1, "amount", "21");
    assertTotalInCollection("details", 2, "amount", "10.08");
    assertTotalInCollection("details", 3, "amount", "58.08");
}
</code></pre> As you see, with these simple modifications we test most of our new code. What remains is only the <em>estimatedProfit</em> and <i>deliveryDays</i> properties. We'll test them in the next sections.<br>
        <h3 id="toc13"><a name="Lesson 5: Basic business logic-JUnit tests-Testing @Formula"></a>Testing <em>@Formula<br>
          </em></h3>
        In section <a class="wiki_link" href="basic-business-logic_en.html#Lesson%205:%20Basic%20business%20logic-Database%20logic%20%28@Formula%29">Database logic (@Formula)</a> we have created a property that uses <em>@Formula</em>, <em>estimatedProfit</em>. This property is shown only in list mode.<br>
        Obviously, the simplest way to test it is by going to list mode and verifying that the value for this property is the expected one. You have already seen that in <em>testCreate()</em> we call the <em>verifyEstimatedProfit()</em>. Let's see its code:<br>
        <pre><code class="java">private void verifyEstimatedProfit() throws Exception {
    execute("Mode.list"); // Changes to list mode
    setConditionValues(new String [] { // Filters to see in the list
        getCurrentYear(), getNumber() // only the newly created document
    });
    execute("List.filter"); // Does the filter
    assertValueInList(0, 0, getCurrentYear()); // Verifies that
    assertValueInList(0, 1, getNumber()); // the filter has worked
    assertValueInList(0, "estimatedProfit", "5.81"); // Asserts estimatedProfit
    execute("List.viewDetail", "row=0"); // Goes to detail mode
}
</code></pre> Because we now go to list mode and then we go back to detail. We have to make a small modification to the <em>verifyCreated()</em> method, that is executed just after <em>verifyEstimatedProfit()</em>. Let's see the modification in the next code:<br>
        <pre><code class="java">private void verifyCreated() throws Exception {
    // setValue("year", getCurrentYear()); // We delete these lines
    // setValue("number", getNumber()); // for searching the document
    // execute("CRUD.refresh"); // because we already searched it with list mode
 
    // The rest of the test...
    ...
</code></pre> We remove these lines because now it's not necessary to search the newly created document. Now in the <em>verifyEstimatedProfit()</em> method we went to list mode and chose the document, so we are already editing the document.</div>
      <div class="wiki" style="display: block;">
        <h3><a name="Lesson 5: Basic business logic-JUnit tests-Testing calculated and persistent synchronized properties"></a>Testing calculated and persistent synchronized properties<em></em></h3>
        In the <a class="wiki_link" href="basic-business-logic_en.html#Lesson%205:%20Basic%20business%20logic-JPA%20callback%20methods-Synchronizing%20persistent%20and%20calculated%20properties">Synchronizing persistent and calculated properties</a> section we used a JPA callback method in <em>Order</em> to have a persistent property, <em>deliveryDays</em><em></em>, synchronized with a calculated one, <em>estimatedDeliveryDays</em>. The <em>deliveryDays</em> property is only shown in list mode.<br>
        Go to <i>OrderTest</i> class and add a new method <i>testDeliveryDays()</i>:<br>
        <pre><code class="java">public void testDeliveryDays() throws Exception {
    login("admin", "admin");
    assertListNotEmpty(); 
    execute("List.viewDetail", "row=0"); 
	
    setValue("date", "6/5/20");
    assertValue("estimatedDeliveryDays", "1");
    setValue("date", "6/6/20");
    assertValue("estimatedDeliveryDays", "3");
    setValue("date", "6/7/20");
    assertValue("estimatedDeliveryDays", "2");
    execute("CRUD.save");
    execute("Mode.list"); // To verify that deliveryDays is synchronized
    assertValueInList(0, "deliveryDays", "2"); 

    execute("List.viewDetail", "row=0");
    setValue("date", "1/13/20");
    assertValue("estimatedDeliveryDays", "7");
    execute("CRUD.save");
    execute("Mode.list"); // To verify that deliveryDays is synchronized
    assertValueInList(0, "deliveryDays", "7");        
}
</code></pre> We try several values for <i>date</i> in order to verify that <i>estimatedDeliveryDays</i> is correctly calculated each time, moreover we go to list mode to verify that <i>deliveryDays</i> has the correct value so both properties are synchronized.</div>
      <div class="wiki" style="display: block;"><br>
      </div>
      <div class="wiki" style="display: block;">Congratulations! Now you have your tests up to date with your code. It's a good time to run all the tests for your application.<br>
        <h2 id="Lesson%206:%20Advanced%20validation-JUnit%20tests">Testing validation</h2>
      </div>
      <div class="wiki" style="display: block;"><b><span style="color: green;">The source code below is to write on top of code from section <i>Advanced validation</i>, until new notice.</span></b></div>
      <div class="wiki" style="display: block;">Our goal is not to develop a huge quantity of software, but to create quality software. At the end of the day, if you create quality software you will deliver more functionality, because you will spend more time on new and exciting things and less time on debugging legions of bugs. And you know that the only way to quality is automated testing, so lets update our test code.<br>
        <h3 id="toc17"><a name="Lesson 6: Advanced validation-JUnit tests-Testing validation for adding to a collection"></a>Testing validation for adding to a collection</h3>
        Recall that we have refined the code in a way that the user cannot assign orders to an invoice if the orders are not marked as delivered yet. After that, your current <em>testAddOrders()</em> of <em>InvoiceTest</em> can fail, because it tries to add the first order, and this first order might not be marked as delivered yet.<br>
        Let's modify the test method to run correctly and also to test your new validation functionality:<br>
        <pre><code class="java">public void testAddOrders() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=number");
    execute("List.viewDetail", "row=0");
    execute("Sections.change", "activeSection=1");
    assertCollectionRowCount("orders", 0);
    execute("Collection.add",
        "viewObject=xava_view_section1_orders");
    // execute("AddToCollection.add", "row=0"); // Now we don't select randomly
 
    checkFirstOrderWithDeliveredEquals("Delivered"); // Selects one delivered order
    checkFirstOrderWithDeliveredEquals(""); // Selects one not delivered order
    execute("AddToCollection.add"); // We try to add both
    assertError( // An error, because the not delivered order cannot be added
        "ERROR! 1 element(s) NOT added to Orders of Invoice");
    assertMessage( // A confirm message, because the delivered order has been added
        "1 element(s) added to Orders of Invoice");
 
    assertCollectionRowCount("orders", 1);
    checkRowCollection("orders", 0);
    execute("Collection.removeSelected",
        "viewObject=xava_view_section1_orders");
    assertCollectionRowCount("orders", 0);
}
</code></pre> We have modified the part for selecting orders to add. Before we selected the first order, no matter if it's delivered or not. Now we select one order delivered and one order not delivered. In this way we test if the delivered one is added and the not delivered one is rejected.<br>
        The missing piece here is the way to check the orders. This is the task of the <em>checkFirstOrderWithDeliveredEquals()</em> method:<br>
        <pre><code class="java">private void checkFirstOrderWithDeliveredEquals(String value) throws Exception {
    int c = getListRowCount(); // The total displayed rows in list
    for (int i=0; i&lt;c; i++) {
        if (value.equals(
            getValueInList(i, 12))) // 12 is the 'delivered' column
        {
            checkRow(i);
            return;
        }
    }
    fail("There must be at least one row with delivered=" + value);
}
</code></pre> Here you see a good technique to do a loop over the displayed list elements in order to check them, get data or do whatever you want with the list data. In order this test works the first invoice has to have no deliveries and moreover it must be at least one order delivered, but not the first one.<br>
        <h3 id="toc18"><a name="Lesson 6: Advanced validation-JUnit tests-Testing validation assigning a reference and validation on removal"></a>Testing validation assigning a reference and validation on removal</h3>
        From the <em>Invoice</em> module the user cannot add orders to an invoice if they are not delivered yet, therefore, from the <em>Order</em> module the user cannot assign an invoice to an order if the order is not delivered. That is, we have to test the other side of the association too. We'll do it by modifying the existing <em>testSetInvoice()</em> of <em>OrderTest</em>.<br>
        Moreover, we'll use this case to test the remove validation we introduced in sections <a
          class="wiki_link" href="validation_en.html#toc7">Validating on removal with @RemoveValidator</a> and <a
          class="wiki_link" href="validation_en.html#toc8">Validating on removal with a JPA callback method</a>. There we modified the application to prevent the user from removing an order which has an invoice associated with it. Now we will test this restriction.<br>
        The revision of <em>testSetInvoice()</em> of <i>OrderTest</i> with all these enhancements is below:<br>
        <pre><code class="java">public void testSetInvoice() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=number"); // To set the list order
    execute("List.viewDetail", "row=0");
    assertValue("delivered", "false"); // The order must be not delivered
    execute("Sections.change", "activeSection=1");
    assertValue("invoice.number", "");
    assertValue("invoice.year", "");
    execute("Reference.search",
        "keyProperty=invoice.year");
    execute("List.orderBy", "property=number");
    String year = getValueInList(0, "year");
    String number = getValueInList(0, "number");
    execute("ReferenceSearch.choose", "row=0");
    assertValue("invoice.year", year);
    assertValue("invoice.number", number);
 
    // Not delivered order cannot have invoice
    execute("CRUD.save");
    assertErrorsCount(1); // We cannot save because it is not delivered
    setValue("delivered", "true");
    execute("CRUD.save"); // With delivered=true we can save the order
    assertNoErrors();
 
    // Order with invoice cannot be deleted
    execute("Mode.list"); // We go to list and
    execute("CRUD.deleteRow", "row=0"); // we delete the saved order
    assertError("Impossible to remove Order because: " + // We cannot delete because
        "An order with an invoice cannot be deleted"); // it has an invoice associated
 
    // Restoring original values
    execute("List.viewDetail", "row=0");
    setValue("invoice.year", "");
    setValue("delivered", "false");
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> The original test only searched for an invoice, but did not even save. Now, we added test code at the end which tries to save the order with delivered=false and with delivered=true, in this way we test the validation. After that, we try to delete the order, that has an invoice. Thus we test the validation on removal too. Before running this test make sure that first order is not delivered and has not invoice.<br>
        <h3 id="toc19"><a name="Lesson 6: Advanced validation-JUnit tests-Testing the custom Bean Validation"></a>Testing the custom <em>Bean Validation</em></h3>
        The last step is to test the <em>ISBN Bean Validation</em>, which uses a REST service to do validation. We simply have to write a test case that tries to assign an incorrect, a nonexistent and a correct ISBN to a product and checks the results for these cases. To do so let's add a <em>testISBNValidator()</em> method to <em>ProductTest</em>.<br>
        <pre><code class="java">public void testISBNValidator() throws Exception {
    login("admin", "admin");
 
    // Searching the product1
    execute("CRUD.new");
    setValue("number", Integer.toString(product1.getNumber()));
    execute("CRUD.refresh");
    assertValue("description", "JUNIT Product 1");
    assertValue("isbn", "");
 
    // With incorrect ISBN format
    setValue("isbn", "1111");
    execute("CRUD.save"); // Fails because of format (apache commons validator)
    assertError("1111 is not a valid value for ISBN of " +
        "Product: ISBN invalid or nonexistent");
 
    // ISBN does not exist though it has correct format
    setValue("isbn", "9791034369997");
    execute("CRUD.save"); // Fails because it does not exist (REST service)
    assertError("9791034369997 is not a valid value for ISBN of " +
        "Product: ISBN invalid or nonexistent");
 
    // ISBN exists
    setValue("isbn", "9780932633439");
    execute("CRUD.save"); // It does not fail
    assertNoErrors();
}
</code></pre> Surely the manual testing you were doing during the development of the <em>@ISBN</em> validator was like the one above. Therefore, if <a
          href="http://www.extremeprogramming.org/rules/testfirst.html"
          rel="nofollow">you write your JUnit test before the application code</a>, you can use it as you proceed. This is more efficient than repeating the test procedures by hand using the browser over and over again.<br>
        Note that if you use <i>@ISBN(search=false)</i> this test will not work because it checks the result of the REST service. So, you have to use the <em>@ISBN</em> annotation of the <i>isbn </i>property without the search attribute in order to run this test successfully.<br>
        Now execute all the tests for your <i>invoicing</i> application to verify that everything works as expected.</div>
      <div class="wiki" style="display: block;">
        <h2 id="Lesson%207:%20Refining%20the%20standard%20behavior-JUnit%20tests">Testing of refining the standard behavior</h2>
        <b><span style="color: green;">The source code below is to write on top of code from section <i>Refining the standard behavior</i>, until new notice.</span></b></div>
      <div class="wiki" style="display: block;"> We have refined the way your application deletes entities, moreover we added two custom modules, the trash modules. Before we move ahead, we must write the tests for the new features.<br>
        <h3 id="toc21"><a name="Lesson 7: Refining the standard behavior-JUnit tests-Testing the customized delete behavior"></a>Testing the customized delete behavior</h3>
        We do not have to write new tests for the deletion, because the current testing code already tests the delete functionality. Usually, when you change the implementation of some functionality but not their use from the user viewpoint, as in our current case, you do not need to add new tests.<br>
        Just run all the tests for your application, and adjust the needed details in order for them to work properly. In fact you only need to change “CRUD.delete” to “Invoicing.delete” and “CRUD.deleteSelected” to “Invoicing.deleteSelected” in a few tests. The next code summarizes the changes you need to apply to your current test code:<br>
        <pre><code class="java">// In CustomerTest.java file
public class CustomerTest extends ModuleTestBase {
    ...
    public void testCreateReadUpdateDelete() throws Exception {
        ...
        // Delete
        // execute("CRUD.delete");
        execute("Invoicing.delete");
        assertMessage("Customer deleted successfully");
    }
    ...
}
 
// In CommercialDocumentTest.java file
abstract public class CommercialDocumentTest extends ModuleTestBase {
    ...
    private void remove() throws Exception {
        // execute("CRUD.delete");
        execute("Invoicing.delete");
        assertNoErrors();
    }
    ...
}
 
// In ProductTest.java file
public class ProductTest extends ModuleTestBase {
    ...
    public void testRemoveFromList() throws Exception {
        ...
        // execute("CRUD.deleteSelected");
        execute("Invoicing.deleteSelected");
        ...
    }
    ...
}
 
// In OrderTest.java file
public class OrderTest extends CommercialDocumentTest {
    ...
    public void testSetInvoice() throws Exception {
        ...
        //execute("CRUD.deleteRow", "row=0");
        execute("Invoicing.deleteRow", "row=0");
        ...
    }
}
</code></pre> After these changes all your tests will work properly, and this verifies that your refined delete actions preserve the original semantics. Only the implementation has changed.<br>
        <h3 id="toc22"><a name="Lesson 7: Refining the standard behavior-JUnit tests-Testing several modules in the same test method"></a>Testing several modules in the same test method</h3>
        You also have to test the new custom modules, <em>OrderTrash</em> and <em>InvoiceTrash</em>. Additionally, we will also verify that the removal logic works fine, and that the entities are only marked as deleted and not actually removed.<br>
        To test the InvoiceTrash module we will follow the steps below:<br>
        <ul>
          <li>Start in the Invoice module.</li>
          <li>Delete an invoice from detail mode and verify that it has been deleted.</li>
          <li>Delete an invoice from list mode and verify that it has been deleted.</li>
          <li>Go to the InvoiceTrash module.</li>
          <li>Verify that it contains the two deleted invoices.</li>
          <li>Restore them and verify that they disappear from the trash list.</li>
          <li>Come back to the Invoice module.</li>
          <li>Verify that the two restored invoices are in the list.</li>
        </ul>
        You can see that we start in the <em>Invoice</em> module. Moreover, you surely have realized that the logic to test the <em>Order</em> module is exactly the same. So instead of creating the new test classes, <i>OrderTrashTest</i> and <i>InvoiceTrashTest</i>, we'll just add the test in the already existing <em>CommercialDocumentTest</em>. Thus we reuse the same code for testing <em>OrderTrash</em>, <em>InvoiceTrash</em>, and the custom delete logic. Add the next <em>testTrash()</em> method to <em>CommercialDocumentTest</em>:<br>
        <pre><code class="java">public void testTrash() throws Exception {
    login("admin", "admin");
    assertListOnlyOnePage(); // Only one page in the list, that is less than 10 rows
    execute("List.orderBy", "property=number"); // We order the list by number
 
    // Deleting from detail mode
    int initialRowCount = getListRowCount();
    String year1 = getValueInList(0, 0);
    String number1 = getValueInList(0, 1);
    execute("List.viewDetail", "row=0");
    execute("Invoicing.delete");
    execute("Mode.list");
    assertListRowCount(initialRowCount - 1); // There is one row less
    assertDocumentNotInList(year1, number1); // The deleted entity is not in the list
 
    // Deleting from list mode
    String year2 = getValueInList(0, 0);
    String number2 = getValueInList(0, 1);
    checkRow(0);
    execute("Invoicing.deleteSelected");
    assertListRowCount(initialRowCount - 2); // There are 2 fewer rows
    assertDocumentNotInList(year2, number2); // The other deleted entity is not in the list now
 
    // Verifying deleted entities are in the trash module
    changeModule(model + "Trash"); // model can be 'Invoice' or 'Order'
    assertListOnlyOnePage();
    int initialTrashRowCount = getListRowCount();
    assertDocumentInList(year1, number1); // We verify that the deleted entities
    assertDocumentInList(year2, number2); // are in the trash module list
    // Restoring using row action
    int row1 = getDocumentRowInList(year1, number1);
    execute("Trash.restore", "row=" + row1);
    assertListRowCount(initialTrashRowCount - 1); // 1 row less after restoring
    assertDocumentNotInList(year1, number1); // The restored entity is no longer shown
                // in the trash module list
    // Restoring by checking a row and using the bottom button
    int row2 = getDocumentRowInList(year2, number2);
    checkRow(row2);
    execute("Trash.restore");
    assertListRowCount(initialTrashRowCount - 2); // 2 fewer rows
    assertDocumentNotInList(year2, number2); // The restored entity is no longer shown
                // in the trash module list
    // Verifying entities are restored
    changeModule(model);
    assertListRowCount(initialRowCount); // After restoring we have the original
    assertDocumentInList(year1, number1); // rows again
    assertDocumentInList(year2, number2);
}
</code></pre> As you see the <em>testTrash()</em> follows the aforesaid steps. Note how using the <i>changeModule()</i> method from <i>ModuleTestBase</i> your test can change to another module. We use it to switch to the trash module, and then come back.<br>
        In our tests we're using a few auxiliary methods you have to add to <em>CommercialDocumentTest</em>. The first is <em>assertListOnlyOnePage()</em> to assert that the list is adequate for running this test.<br>
        <pre><code class="java">private void assertListOnlyOnePage() throws Exception {
    assertListNotEmpty(); // This is from ModuleTestBase
    assertTrue("Must be less than 10 rows to run this test",
        getListRowCount() &lt; 10);
}
</code></pre> We need to have less than 10 rows, because the <i>getListRowCount()</i> method only informs about rows that are displayed. If you have more than 10 rows (10 is the default row count per page) you cannot take advantage of <i>getListRowCount()</i>, it would always return 10.<br>
        The remaining methods are for verifying if some order or invoice is (or is not) in the list. See them:<br>
        <pre><code class="java">private void assertDocumentNotInList(String year, String number)
    throws Exception
{
    assertTrue(
        "Document " + year + "/" + number +" must not be in list",
        getDocumentRowInList(year, number) &lt; 0);
}
 
private void assertDocumentInList(String year, String number)
    throws Exception
{
    assertTrue(
        "Document " + year + "/" + number + " must be in list",
        getDocumentRowInList(year, number) &gt;= 0);
}
 
private int getDocumentRowInList(String year, String number)
    throws Exception
{
    int c = getListRowCount();
    for (int i=0; i&lt;c; i++) {
        if ( year.equals(getValueInList(i, 0)) &amp;&amp;
            number.equals(getValueInList(i, 1)))
        {
            return i;
        }
    }
    return -1;
}
</code></pre> You can see in <em>getDocumentRowInList()</em> how to create a loop for searching after a specific value in a list.<br>
        Now you can run all the tests for your <i>invoicing</i> application. Everything should be green.</div>
      <div class="wiki" style="display: block;">
        <h2 id="testing-behavior-business-logic">Testing behavior &amp; business logic</h2>
      </div>
      <div class="wiki" style="display: block;"><b><span style="color: green;">The source code below is to write on top of code from section <i>Behavior &amp; business logic</i>, until new notice.</span></b></div>
      <div class="wiki" style="display: block;">The code we have written in the <i>Behavior &amp; business logic</i> section is not complete until we write the tests. Remember, all new code must have its corresponding test code. Let's write tests for the two new actions.
        <h3><a name="testing-the-detail-mode-action"></a>Testing the detail mode action</h3>
        First we'll test the <i>Order.createInvoice</i> action, the action for creating an invoice from the displayed order in detail mode. Then next image shows how this process works:<br>
        <img src="files/business-logic-behavior_en010.png" alt="business-logic-behavior_en010.png"
          title="business-logic-behavior_en010.png"><br>
        Now we're going to write a test to verify that it really works in this way. Add the <i>testCreateInvoiceFromOrder()</i> method to the <i>OrderTest</i> class:
        <pre><code class="java">public void testCreateInvoiceFromOrder() throws Exception {
    login("admin", "admin");      
    
    // Looking for the order
    searchOrderSusceptibleToBeInvoiced(); // Locates an order
    assertValue("delivered", "true"); // The order is delivered
    int orderDetailsCount = getCollectionRowCount("details"); // Takes note of the
                                                     // details count of the order
    execute("Sections.change", "activeSection=1"); // The section of the invoice
    assertValue("invoice.year", ""); // There is no invoice yet
    assertValue("invoice.number", ""); // in this order

    // Creating the invoice
    execute("Order.createInvoice"); // Executes the action under test (1)
    String invoiceYear = getValue("invoice.year"); // Verifies that now
    assertTrue("Invoice year must have value", // there is an invoice in
        !Is.emptyString(invoiceYear)); // the invoice tab (2)
    String invoiceNumber = getValue("invoice.number");
    assertTrue("Invoice number must have value",
        !Is.emptyString(invoiceNumber)); // Is.emptyString() is from org.openxava.util
    assertMessage("Invoice " + invoiceYear + "/" + invoiceNumber +
        " created from current order"); // The confirmation message (3)
    assertCollectionRowCount("invoice.details", // The newly created invoice
        orderDetailsCount); // has the same details count as the order (4)

    // Restoring the order for running the test the next time
    setValue("invoice.year", "");
    assertValue("invoice.number", "");
    assertCollectionRowCount("invoice.details", 0);
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> As you can see, the test clicks the button for executing <i> Order.createInvoice</i> action (1), then verifies that an invoice has been created, is displayed in the invoice tab (2), and has the same number of detail lines as the current order (4). The test also verifies that the correct confirmation message is generated (3).<br>
        To run this test it's needed to choose an order suitable to be invoiced. This is done in the <i>searchOrderSusceptibleToBeInvoiced()</i> method that we are going to examine in the next section.
        <h3><a name="finding-an-entity-for-testing-using-list-mode-and-jpa"></a>Finding an entity for testing using list mode and JPA</h3>
        To select an order suitable for our test we'll use JPA to determine the year and number of that order, and then we'll use the list mode to select the order to be edited in detail mode. Below the methods to implement this:
        <pre><code class="java">private void searchOrderSusceptibleToBeInvoiced() throws Exception {
    searchOrderUsingList("delivered = true and invoice = null"); // Sends
} // the condition, in this case to search for a delivered order with no invoice

private void searchOrderUsingList(String condition) throws Exception {
    Order order = findOrder(condition); // Finds the order with the condition using JPA
    String year = String.valueOf(order.getYear());
    String number = String.valueOf(order.getNumber());
    setConditionValues(new String [] { year, number }); // Fills the year and number
    execute("List.filter"); // and clicks the filter button of the list
    assertListRowCount(1); // Only one row corresponding to the desired order
    execute("List.viewDetail", "row=0"); // To see the order in detail mode
    assertValue("year", year); // Verifies that the edited order
    assertValue("number", number); // is the desired one
}

private Order findOrder(String condition) {
    Query query = XPersistence.getManager().createQuery( // Creates a JPA query
        "from Order o where o.deleted = false and " // from the condition. Note the
        + condition); // deleted = false for excluding deleted orders
    List&lt;Order&gt; orders = query.getResultList();
    if (orders.isEmpty()) { // It's needed at least one order with the condition
        fail("To run this test you must have some order with " + condition);
    }
    return orders.get(0);
}
</code></pre> Also you have the next imports to <i>OrderTest</i> in order it compiles:
        <pre><code class="java">import java.util.*;
import javax.persistence.*;
import org.openxava.jpa.*;
import org.openxava.util.*;
import com.yourcompany.invoicing.model.*;
</code></pre> The <i>searchOrderSusceptibleToBeInvoiced()</i> method simply calls a more generic method, <i>searchOrderUsingList()</i>, to locate an entity from a condition. The <i>searchOrderUsingList()</i> method obtains an <i>Order</i> entity by means of <i>findOrder()</i>, then it uses the list to filter by year and number of this <i>Order</i> before finally going to detail mode. The <i>findOrder()</i> method uses plain JPA for searching.<br>
        Combining list mode and JPA can be a very useful technique in some cases. We will continue to use the methods <i>searchOrderUsingList()</i> and <i>findOrder()</i> in the remaining tests.
        <h3><a name="testing-hiding-of-the-action"></a>Testing hiding of the action</h3>
        We refined the <i>Order</i> module to show the action for creating an invoice only when the displayed order would be suitable to be invoiced. This is the test method for this, add it to <i>OrderTest</i>:
        <pre><code class="java">public void testHidesCreateInvoiceFromOrderWhenNotApplicable() throws Exception {
    login("admin", "admin");
    searchOrderUsingList(
        "delivered = true and invoice &lt;&gt; null"); // If the order already has an invoice
    assertNoAction("Order.createInvoice"); // it cannot be invoiced again

    execute("Mode.list");

    searchOrderUsingList(
        "delivered = false and invoice = null"); // If the order is not delivered
    assertNoAction("Order.createInvoice"); // it cannot be invoiced

    execute("CRUD.new"); // If the order is not saved yet
    assertNoAction("Order.createInvoice"); // it cannot be invoiced
}
</code></pre> We test three cases when the button for creating an invoice should not be visible. Note the usage of <i>assertNoAction()</i> for asking if a link or button for an action is not present in the user interface. Here we are reusing the <i>searchOrderUsingList()</i> method developed in the previous section.<br>
        We have already implicitly tested that the button is present when applicable in our previous test, because <i>execute()</i> fails if the action is not in the user interface.
        <h3><a name="testing-the-list-mode-action"></a>Testing the list mode action</h3>
        Now we'll test the <i>Order.createInvoiceFromSelectedOrders</i> action, the action for creating an invoice from multiple selected orders in list mode. Remember that this process works in this way: <br>
        <img src="files/business-logic-behavior_en030.png" alt="business-logic-behavior_en030.png"
          title="business-logic-behavior_en030.png"><br>
        Let's write a test to verify that it works in just this way. Add the <i> testCreateInvoiceFromSelectedOrders()</i> method to the <i>OrderTest</i> class:
        <pre><code class="java">public void testCreateInvoiceFromSelectedOrders() throws Exception {
    login("admin", "admin");
    assertOrder(2021, 3, 2, "162.14"); // Order 2021/3 has 2 lines and 162.14 as total amount
    assertOrder(2021, 4, 1, "48.40"); // Order 2021/4 has 1 line and 48.40 as total amount

    execute("List.orderBy", "property=number"); // Sorts the list by number
    checkRow( // Checks the row from the row number
        getDocumentRowInList("2021", "3") // Obtains the row from order year and number
	); // So, this line checks the order 2021/3 in the list (1)
    checkRow(
        getDocumentRowInList("2021", "4")
    ); // Checks the order 2021/4 in the list (1)

    execute("Order.createInvoiceFromSelectedOrders"); // Executes the action we
                                                      // are currently testing (2)
    String invoiceYear = getValue("year"); // We are now in detail mode of the
    String invoiceNumber = getValue("number"); // newly created invoice
    assertMessage("Invoice " + invoiceYear + "/" + invoiceNumber +
        " created from orders: [2021/3, 2021/4]"); // The confirmation message
    assertCollectionRowCount("details", 3); // Asserts that the line count of the new
                        // invoice equals the sum of lines from the source orders (3)
    assertValue("totalAmount", "210.54"); // Asserts that total amount of the new
                    // invoice equals the sum of the amounts of the source orders (4)
    execute("Sections.change", "activeSection=1"); // Changes to the orders tab of invoice
    assertCollectionRowCount("orders", 2); // The new invoice has 2 associated orders (5)
    assertValueInCollection("orders", 0, 0, "2021"); // and they should be the correct 
    assertValueInCollection("orders", 0, 1, "3"); // ones
    assertValueInCollection("orders", 1, 0, "2021");
    assertValueInCollection("orders", 1, 1, "4");

    assertAction("InvoiceEdition.save"); // The SAVE (6)
    assertAction("InvoiceEdition.close"); // and CLOSE buttons (6)

    checkRowCollection("orders", 0); // We select the 2 orders
    checkRowCollection("orders", 1);
    execute("Collection.removeSelected", // and remove them, in order to be able to
        "viewObject=xava_view_section1_orders"); // repeat this test using the same orders
    assertNoErrors();

    execute("InvoiceEdition.close"); // Closes the dialog and returns to the orders list (7)
    assertDocumentInList("2021", "3"); // Asserts that we are really in orders list
    assertDocumentInList("2021", "4");
}
</code></pre> This test checks two orders (1) and clicks the CREATE INVOICE FROM SELECTED ORDERS (2). Then it verifies that a new invoice is created with the correct number of lines (3), total amount (4) and list of orders (5). Furthermore the test verifies that the SAVE and CLOSE actions are available (6) and uses the latter for returning to the orders list (7).<br>
        We use <i>getDocumentRowInList()</i> and <i>assertDocumentInList()</i>, methods from <i>CommercialDocumentTest</i> base class. They were originally defined as private, therefore we must redefine them as protected to use them from <i>OrderTest</i>. Edit <i>CommercialDocumentTest</i> and make the next changes:
        <pre><code class="java">// private void assertDocumentInList(String year, String number) ...
protected void assertDocumentInList(String year, String number) ...

// private int getDocumentRowInList(String year, String number) ...
protected int getDocumentRowInList(String year, String number) ...
</code></pre> The only remaining detail is the <i>assertOrder()</i> method that we'll see in the next section.
        <h3><a name="asserting-test-data"></a>Asserting test data</h3>
        In the lesson about automated testing you learned how to use data existing in the database for your tests. Obviously, if your database is accidentally altered, your test, albeit correct, will not pass. So, asserting the database values before running a test that relies on them is a good practice. In our example we do this by calling <i>assertOrder()</i> at the beginning. Add it to <i>OrderTest</i>:<br>
        <pre><code class="java">private void assertOrder(
    int year, int number, int detailsCount, String totalAmount)
{
    Order order = findOrder("year = " + year + " and number=" + number);
    assertEquals("To run this test the order " +
        order + " must have " + detailsCount + " details",
        detailsCount, order.getDetails().size());
    assertTrue("To run this test the order " +
        order + " must have " + totalAmount + " as total amount",
        order.getTotalAmount().compareTo(new BigDecimal(totalAmount)) == 0);
    assertTrue("To run this test the order " + order + " must be delivered",
        order.isDelivered());        
}
</code></pre> This method finds an order and verifies its details count, the total amount and if the order is delivered. Using this method has the advantage that if the required orders for the test are not in the database with the correct values you get a precise message. Thus, you will not waste time figuring out what is wrong. This is especially useful if the test is not performed by the original developer. By the way, if you find difficult to create the orders with the data to fit this test (order number, details count, amount), just adapt the values of the test to your current orders.<br>
        <h3><a name="testing-exceptional-cases"></a>Testing exceptional cases</h3>
        Given that the action for creating the invoice is hidden if the order is not ready to be invoiced, we cannot test the code from detail mode we wrote for handling exceptional cases. In list mode however, the user still has the option of choosing any order for invoicing. Therefore, we will create the invoice for verifying the correct behavior in exceptional cases from list mode. Add the next code to <i> OrderTest</i>:
        <pre><code class="java">public void testCreateInvoiceFromOrderExceptions() throws Exception {
    login("admin", "admin");      
    assertCreateInvoiceFromOrderException( // Verifies that when the order already has (1)
        "delivered = true and invoice &lt;&gt; null", // an invoice the correct error is produced
        "Impossible to execute Create invoice from selected orders action: " +
            "The order already has an invoice"
    );
    assertCreateInvoiceFromOrderException( // Verifies that when the order is not (2)
        "delivered = false and invoice = null", // delivered the correct error is produced
        "Impossible to execute Create invoice from selected orders action: " +
            "The order is not delivered yet"
    );
}

private void assertCreateInvoiceFromOrderException(
    String condition, String message) throws Exception
{
    Order order = findOrder(condition); // Finds an order satisfying the condition (3)
    int row = getDocumentRowInList( // and obtains the row number for that order (4)
        String.valueOf(order.getYear()),
        String.valueOf(order.getNumber())
    );
    checkRow(row); // Checks the row (5)
    execute("Order.createInvoiceFromSelectedOrders"); // Tries to create the invoice(6)
    assertError(message); // Is the expected message shown? (7)
    uncheckRow(row); // Uncheck the row so we can call this method again
}
</code></pre> The test verifies that the message is the correct one when trying to create an invoice from an order that already has an invoice (1), and also from an order not delivered yet (2). To do these verifications it calls the method <i>assertCreateInvoiceFromOrderException()</i>. This method finds an <i>Order</i> entity using the condition (3), locates the row where the entity is displayed (4) and checks it (5). Afterward, the test executes the action (6) and asserts that the expected message is shown (7).</div>
      <div class="wiki" style="display: block;">
        <h2 id="testing-references-collections">Testing references &amp; collections</h2>
      </div>
      <div class="wiki" style="display: block;"><b><span style="color: green;">The source code below is to write on top of code from section <i>References &amp; collections</i>.</span></b></div>
      <div class="wiki" style="display: block;">We still are in the healthy habit of doing some application code, then some testing code. And now it's time to write the test code for the new features we added in the <i>References &amp; collections</i> section.
        <h3><a name="adapting-ordertest"></a>Adapting <i>OrderTest</i></h3>
        If you run <i>OrderTest</i> right now it does not pass. This is because our test code relies in some details that have changed. Therefore, we have to modify the current test code. Edit the <i>testSetInvoice()</i> method of <i> OrderTest</i> and apply the next changes:
        <pre><code class="java">public void testSetInvoice() throws Exception {

    ...
	
    assertValue("invoice.number", "");
    assertValue("invoice.year", "");
    // execute("Reference.search", // The standard action for invoice searching
    //    "keyProperty=invoice.year"); // is no longer used
    execute("Order.searchInvoice", // Instead we use our custom action (1)
        "keyProperty=invoice.number");
    execute("List.orderBy", "property=number");

    ...
	
    // Restore values
    
    setValue("invoice.year", ""); // Now we need to type a year
    setValue("invoice.number", ""); // and a number to search the invoice (2)
    setValue("delivered", "false");
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> Remember that we annotated the invoice reference in <i>Order </i>with <i>@SearchAction("Order.searchInvoice")</i>, so we have to modify the test to call <i>Order.searchInvoice</i> (1) instead of <i>Reference.search</i>. Also we added <i>@SearchKey</i> to year and number of <i>CommercialDocument</i>, therefore our test has to indicate both year and number to get (or clear in this case) an invoice (2). Because of this last point we also have to modify <i>testCreateInvoiceFromOrder()</i> of <i>OrderTest</i>:
        <pre><code class="java">public void testCreateInvoiceFromOrder() throws Exception {

    ...

    // Restoring the order for running the test the next time
    setValue("invoice.year", ""); // Now we need to type a year
    setValue("invoice.number", ""); // and a number to search the invoice (2)
    assertValue("invoice.number", "");
    assertCollectionRowCount("invoice.details", 0);
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> After these changes the <i>OrderTest</i> must pass. However, we still have to add the testing of the new functionality of <i>Order</i> module.
        <h3><a name="testing-the-searchaction"></a>Testing the <i>@SearchAction</i></h3>
        We have used <i>@SearchAction</i> in the <i>invoice </i>reference of <i>Order</i> for showing in the search list only the invoices from the customer of the current order. Add the next method to <i>OrderTest</i> to test of this functionality:
        <pre><code class="java">public void testSearchInvoiceFromOrder() throws Exception {
    login("admin", "admin");      
    execute("CRUD.new");
    setValue("customer.number", "1"); // If the customer is 1...
    execute("Sections.change", "activeSection=1");
    execute("Order.searchInvoice", // ...when the user clicks to choose an invoice...
        "keyProperty=invoice.number");
    assertCustomerInAllRows("1"); // ...only the invoices of customer 1 are shown
    execute("ReferenceSearch.cancel");
    execute("Sections.change", "activeSection=0");
    setValue("customer.number", "2"); // And if the customer is 2...
    execute("Sections.change", "activeSection=1");
    execute("Order.searchInvoice", // ...when the user clicks to choose an invoice...
        "keyProperty=invoice.number");
    assertCustomerInAllRows("2"); // ...only the invoices of customer 2 are shown
}
</code></pre> The trickier part is to assert the invoices list, this is the work for <i>assertCustomerInAllRows()</i> in <i>OrderTest</i>:
        <pre><code class="java">private void assertCustomerInAllRows(String customerNumber) throws Exception {
    assertListNotEmpty();
    int c = getListRowCount();
    for (int i=0; i&lt;c; i++) { // A loop over all rows
        if (!customerNumber.equals(getValueInList(i, "customer.number"))) {
            fail("Customer in row " + i + // If the customer is not the expected one it fails
                " is not " + customerNumber);
        }
    }
}
</code></pre> It consists in a loop over all rows verifying the customer number.
        <h3><a name="testing-the-onchangesearch"></a>Testing the <i>@OnChangeSearch</i></h3>
        We used <i>@OnChangeSearch</i> in the <i> invoice</i> reference of <i>Order</i> for assigning automatically the customer of the chosen invoice to the current order when the order has no customer yet, or for verifying that the invoice and order customer matches, if the order already has a customer. This is the test method in <i>OrderTest</i>:
        <pre><code class="java">public void testOnChangeInvoice() throws Exception {
    login("admin", "admin");
    execute("CRUD.new"); // We are creating a new order
    assertValue("customer.number", ""); // so it has no customer yet
    execute("Sections.change", "activeSection=1");
    execute("Order.searchInvoice", // Looks for the invoice using a list
        "keyProperty=invoice.number");
		
    execute("List.orderBy", "property=customer.number"); // It orders by customer
    String customer1Number = getValueInList(0, "customer.number"); // Memorizes..
    String invoiceYear1 = getValueInList(0, "year"); // ..the data of the...
    String invoiceNumber1 = getValueInList(0, "number"); // ...first invoice
    execute("List.orderBy", "property=customer.number"); // It orders by customer
    String customer2Number = getValueInList(0, "customer.number"); // Memorizes..
    String customer2Name = getValueInList(0, "customer.name"); // ..the data of
                                                           // ...the last invoice
    assertNotEquals("Must be invoices of different customer",
    customer1Number, customer2Number); // The 2 memorized invoices aren't the same
	
    execute("ReferenceSearch.choose","row=0");// The invoice is chosen using the list (1)
    execute("Sections.change", "activeSection=0");
    assertValue("customer.number", customer2Number); // The customer data is
    assertValue("customer.name", customer2Name); // filled automatically (2)
    execute("Sections.change", "activeSection=1");
    setValue("invoice.year", invoiceYear1); // We try to put an invoice of another...
    setValue("invoice.number", invoiceNumber1); // ...customer (3)
	
    assertError("Customer Nº " + customer1Number + " of invoice " + // It shows
        invoiceYear1 + "/" + invoiceNumber1 + // an error message... (4)
        " does not match with customer Nº " +
        customer2Number + " of the current order");
		
    assertValue("invoice.year", ""); // ...and resets the invoice data (5)
    assertValue("invoice.number", "");
    assertValue("invoice.date", "");
}
</code></pre> Here we test that our on-change action fills the customer data (3) on choosing an invoice (2), and that if the customer is already set, an error message is shown (4) and the invoice is cleared in the view (5). Note how the first time we use the list (1) to choose the invoice and the second time we do it typing the year and number (3).
        <h3><a name="adapting-invoicetest"></a>Adapting <i>InvoiceTest</i></h3>
        As in the case of <i>OrderTest</i>, <i>InvoiceTest</i> also fails to pass. You have to do a little adjustments so it works fine. Edit <i>testAddOrders()</i> of <i> InvoiceTest</i> and apply the next changes:
        <pre><code class="java">public void testAddOrders() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=number");
    execute("List.viewDetail", "row=0");
    execute("Sections.change", "activeSection=1");
    assertCollectionRowCount("orders", 0);
    // execute("Collection.add", // The standard action for adding orders is no longer used
    execute("Invoice.addOrders", // Instead we use our custom action
        "viewObject=xava_view_section1_orders");
    // checkFirstOrderWithDeliveredEquals("Delivered"); // Now all orders in the list are
    // checkFirstOrderWithDeliveredEquals(""); // delivered so it makes no sense
    // execute("AddToCollection.add"); // Instead of the standard action...
    execute("AddOrdersToInvoice.add", "row=0"); // ...now we have our custom one
    // assertError("ERROR! 1 element(s) NOT added to Orders of Invoice"); // It is
                             // impossible because the use cannot chose incorrect orders
    assertMessage("1 element(s) added to Orders of Invoice");
    assertCollectionRowCount("orders", 1);
    checkRowCollection("orders", 0);
    execute("Collection.removeSelected",
        "viewObject=xava_view_section1_orders");
    assertCollectionRowCount("orders", 0);
}
</code></pre> The <i>checkFirstOrderWithDeliveredEquals()</i> method is no longer necessary, therefore we can remove it from <i>InvoiceTest</i>:
        <pre><code class="java">// Remove checkFirstOrderWithDeliveredEquals() from InvoiceTest
// private void checkFirstOrderWithDeliveredEquals(String value)
//     throws Exception { ... }
</code></pre> After these changes the <i>InvoiceTest</i> must pass. However, we still have to add the testing of the new functionality of <i>Invoice</i> module.
        <h3><a name="testing-the-addaction"></a>Testing the <i>@AddAction</i></h3>
        In this lesson we annotated the <i>orders</i> collection of <i>Invoice</i> with <i>@AddAction</i> to refine the list of orders to be added to the collection. In this way only delivered orders of the customer of the current invoice and with no invoice yet are shown. We are going to test this, and at the same time, we'll learn how to refactor the existing code in order to reuse it. <br>
        First, we want to verify that the list to add orders only contains orders of the current customer. The next code shows the changes in <i>testAddOrders()</i> of <i>InvoiceTest</i> to accomplish this.
        <pre><code class="java">public void testAddOrders() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=number");
    execute("List.viewDetail", "row=0");
    String customerNumber = getValue("customer.number"); // We take note of the
    execute("Sections.change", "activeSection=1");   // customer of the invoice
    assertCollectionRowCount("orders", 0);
    execute("Invoice.addOrders", 
	    "viewObject=xava_view_section1_orders");
    assertCustomerInAllRows(customerNumber); // We assert all customers in list
                                          // matches the invoice customer
    ...

}
</code></pre> Now we have to write the <i>assertCustomerInAllRows()</i> method. But, wait a minute, we already have written this method in <i>OrderTest</i>. We are in <i>InvoiceTest</i> so we cannot call this method, fortunately both <i>InvoiceTest</i> and <i>OrderTest</i> extend the <i>CommercialDocumentTest</i>, therefore we only need to pull up the method. To do it copy the <i>assertCustomerInAllRows()</i> method from <i>OrderTest</i> and paste it in <i>CommercialDocumentTest</i>, changing <i>private</i> to <i>protected</i>, just as shown:
        <pre><code class="java">abstract public class CommercialDocumentTest extends ModuleTestBase {

    protected void // We change private to protected
        assertCustomerInAllRows(String customerNumber) throws Exception {

        ...
		
    }

    ...
	
}
</code></pre>Now you can remove the <i>assertCustomerInAllRows()</i> method from <i>OrderTest</i>:
        <pre><code class="java">// Remove assertCustomerInAllRows() from OrderTest
// private void assertCustomerInAllRows(String customerNumber)
//     throws Exception { ... }
</code></pre> After these changes the <i>testAddOrders()</i> method compiles and works. We not only want to test if the orders in list are from the correct customer, but also that they are delivered. The first primary impulse is to copy and paste <i>assertCustomerInAllRows()</i> for creating an <i>assertDeliveredInAllRowsList()</i> method. However, we resist the temptation, instead we are going to create a reusable method. First, we copy and paste&nbsp;<i><i>assertCustomerInAllRows(</i>)</i> as <i>assertValueInAllRows()</i>. Here you can see these two methods in <i>CommercialDocumentTest</i>:
        <pre><code class="java">protected void assertCustomerInAllRows(String customerNumber) throws Exception {
    assertListNotEmpty();
    int c = getListRowCount();
    for (int i=0; i&lt;c; i++) { // A loop over all rows
        if (!customerNumber.equals(
		    getValueInList(i, "customer.number"))) // We ask "ad hoc" for customer
		{ 
            fail("Customer in row " + i + 
                " is not " + customerNumber);
        }
    }
}

protected void assertValueInAllRows(int column, String value) throws Exception {
    assertListNotEmpty();
    int c = getListRowCount();
    for (int i=0; i&lt;c; i++) {
        if (!value.equals(
            getValueInList(i, column))) // We ask for the column sent as parameter
        {
            fail("Column " + column + " in row " + i + " is not " + value);
        }
    }
}
</code></pre>You can see how with a very slight modification we have turned <i><i>assertCustomerInAllRows(</i>)</i> in a generic method to ask for the value of any column, not just customer number. Now we have to remove the redundant code, you can either remove <i>assertCustomerInList()</i> or reimplementing it using the new one. The following code in <i>CommercialDocumentTest</i> shows the later option:
        <pre><code class="java">protected void assertCustomerInAllRows(String customerNumber) throws Exception {
    assertValueInAllRows(3, customerNumber); // Customer number is in column 3
}
</code></pre> Let's use <i>assertValueInAllRows()</i> to assert the orders list contains only delivered orders. The next code shows the needed modification in <i>testAddOrders()</i> of <i>InvoiceTest</i>:
        <pre><code class="java">public void testAddOrders() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=number");
    execute("Mode.detailAndFirst");
    String customerNumber = getValue("customer.number");
    execute("Sections.change", "activeSection=1");
    assertCollectionRowCount("orders", 0);
    execute("Invoice.addOrders",
        "viewObject=xava_view_section1_orders");
    assertCustomerInAllRows(customerNumber);
    assertValueInAllRows(12, "Delivered"); // All cells of column 12 contain 'Delivered'

    ...
	
}
</code></pre> Moreover, we want to test that only orders with no invoice are shown in the list. A simple way to do it is verifying that after adding an order to the current invoice, the list of orders has an entry fewer. The following code shows the needed changes to <i>testAddOrders()</i> of <i>InvoiceTest</i> to do this testing:
        <pre><code class="java">public void testAddOrders() throws Exception {

    ...

    assertCustomerInAllRows(customerNumber);
    assertValueInAllRows(12, "Delivered");
    int ordersRowCount = getListRowCount(); // We take note of orders count
    execute("AddOrdersToInvoice.add", "row=0"); // when the list is shown
    assertMessage("1 element(s) added to Orders of Invoice");
    assertCollectionRowCount("orders", 1); // An order was added
    execute("Invoice.addOrders", // We show the orders list again
        "viewObject=xava_view_section1_orders");
    assertListRowCount(ordersRowCount - 1); // Now we have an order fewer in the list
    execute("AddToCollection.cancel");

    ... 
	
}
</code></pre> With the code of this section we have tested the <i>@AddAction</i> of <i>orders</i> collection, and at the same time we have seen how it's not needed to develop generic code from start, because it's not difficult to convert the concrete code into generic on demand.
        <h3><a name="testing-the-action-to-add-elements-to-the-collection"></a>Testing the action to add elements to the collection</h3>
        In this lesson we also learned how the refine the action that adds orders to the invoice, now it's the moment of testing it. Remember that this action copies the lines from selected orders to the current invoice. The next code shows the changes in <i>testAddOrders()</i> of <i>InvoiceTest</i> for testing of our custom action to add orders: <br>
        <pre><code class="java">public void testAddOrders() throws Exception {

    ...

    String customerNumber = getValue("customer.number");
    assertCollectionRowCount("details", 0); // An invoice with no details for this test 
    assertValue("totalAmount", "0.00"); // With no details total amount is 0
    execute("Sections.change", "activeSection=1");
    assertCollectionRowCount("orders", 0);
    execute("Invoice.addOrders", // When we show the order list (2) ...
        "viewObject=xava_view_section1_orders");
    assertCustomerInAllRows(customerNumber);
    assertValueInAllRows(12, "Delivered");
    String firstOrderTotalAmount = getValueInList(0, 7); // ...we take note of amount
    int ordersRowCount = getListRowCount(); // amount of first order in the list (3)

    ...
	
    assertCollectionRowCount("orders", 1);
    execute("Sections.change", "activeSection=0");
    assertCollectionNotEmpty("details"); // There are details, they have been copied (4)
    assertValue("totalAmount", firstOrderTotalAmount); // The total amount of the
    execute("Sections.change", "activeSection=1"); // invoice matches with the one
                                                   // of the recently added order (5)
    ...

    execute("Sections.change", "activeSection=0"); // back to invoice details tab 
    removeRows(); // remove rows that were added
    waitAJAX(); // we wait any background JS process to complete 
    assertCollectionRowCount("details", 0); // then we verify that there are no more rows
    assertValue("totalAmount", "0,00");
    execute("CRUD.save");
}
</code></pre> We verify that the invoice for this test has no details. Afterwards, we add an order (2), taking note of its total amount (3), then we verify that current invoice has details (4) and its total amount is the same of the added order (5), finally we delete the rows that were added to details (6). Add the following code in the same class:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="java">protected void removeRows() throws Exception {
	// count the number of rows in the table, for this example, the number of elements in the table must be less than 100
  int count = getHtmlPage().getElementById("ox_invoicing_Invoice__details") // (1)
                              .getChildElements().iterator().next().getChildElementCount()-7; //(2)
  for (int i=0; i &lt; count; i++) {
	HtmlElement boton = (HtmlElement)getHtmlPage().getElementById("ox_invoicing_Invoice__details___0") // (3)
		    .getChildElements().iterator().next()
		    .getChildElements().iterator().next()
		    .getChildElements().iterator().next()
		    .getChildElements().iterator().next(); // (4)
	boton.click(); // (5)
   }
}</code></pre>
        <div class="wiki" style="display: block;">Normally to execute a button, we use "controller.action", for example to save we use <i>"CRUD.save"</i>, but in this case, the button that removes the row is a JavaScript function, so we cannot execute it this way. To achieve this we must use HtmlUnit library.<br>
          To know the number of rows in the table <i>details</i>, we access the html code with <i>getHtmlPage()</i> and filter the elements of the page by id with <i>getElementById()</i> passing the id of the table as a parameter: <i>"ox_invoicing_Invoice__details"</i> (1 ), <i>getChildElements()</i> will give us the child element, that is the body of the table, each row of the table is represented as an element in the body, so we use <i>getChildElementCount()</i> to know how many elements it has and subtract 7 which are the rows that are always present (2).<br>
          Now we are going to delete all the rows of the table, if you do it manually you will notice that when you delete a row, the bottom one goes up, keep this in mind.<br>
          We are going to iterate as many times as necessary using the counter, but this time we will pass as a parameter the id of the first row <i>"ox_invoicing_Invoice__details___0"</i> (3), <i>0 </i>is the numbering of the row but as we just said, when deleting a row, the one below goes up, so it is enough to always deleting the first row. Then we will arrive at the element where the button function has (4) and that is where we stop and click on it (5).</div>
        <div class="wiki" style="display: block;">The <i>testAddOrders()</i> method is finished. This is its definitive code:
          <pre><code class="java">public void testAddOrders() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=number");
    execute("List.viewDetail", "row=0");
    String customerNumber = getValue("customer.number");
    assertCollectionRowCount("details", 0);
    assertValue("totalAmount", "0.00");
    execute("Sections.change", "activeSection=1");
    assertCollectionRowCount("orders", 0);
    execute("Invoice.addOrders",
        "viewObject=xava_view_section1_orders");
    assertCustomerInAllRows(customerNumber);
    assertValueInAllRows(12, "Delivered");
    String firstOrderTotalAmount = getValueInList(0, 7);
    int ordersRowCount = getListRowCount();
    execute("AddOrdersToInvoice.add", "row=0");
    assertMessage("1 element(s) added to Orders of Invoice");
    assertCollectionRowCount("orders", 1);
    execute("Sections.change", "activeSection=0");
    assertCollectionNotEmpty("details");
    assertValue("totalAmount", firstOrderTotalAmount);
    execute("Sections.change", "activeSection=1");
    execute("Invoice.addOrders",
        "viewObject=xava_view_section1_orders");
    assertListRowCount(ordersRowCount - 1);
    execute("AddToCollection.cancel");
    checkRowCollection("orders", 0);
    execute("Collection.removeSelected",
        "viewObject=xava_view_section1_orders");
    assertCollectionRowCount("orders", 0);
    execute("Sections.change", "activeSection=0");    
    removeRows();
    waitAJAX();
    assertCollectionRowCount("details", 0);
    assertValue("totalAmount", "0,00");
    execute("CRUD.save");
    }</code>
</pre> We have finished the test code. Now it's time to execute all the tests for your project. They must be green.</div>
      </div>
      <h2 id="junit4-support">JUnit 4 support (since v7.6.2)</h2>
      <div class="wiki" style="display: block;">
        Since OpenXava 7.6.2, you can write your tests using JUnit 4 style with annotations instead of the traditional JUnit 3 style. This allows you to use modern JUnit features like <code>@Test</code>, <code>@Before</code>, and <code>@After</code> annotations.<br>
        <br>
        The <em>ModuleTestBase</em> class has been enhanced to support both JUnit 3 and JUnit 4 styles, so you can migrate your tests gradually. Here's an example of a test written in JUnit 4 style:
      </div>
      <div class="wiki" style="display: block;">
        <pre><code class="java">package com.yourcompany.invoicing.tests;

import org.junit.*;
import org.openxava.tests.*;

public class CustomerTest extends ModuleTestBase {

    public CustomerTest() {
        super("Customer"); // No test name needed for JUnit 4
    }

    @Test // Use @Test annotation instead of naming convention
    public void testCreateReadUpdateDelete() throws Exception {
        login("admin", "admin");

        // Create
        execute("CRUD.new");
        setValue("number", "77");
        setValue("name", "JUNIT Customer");
        setValue("address.street", "JUNIT Street");
        setValue("address.zipCode", "77555");
        setValue("address.city", "The JUNIT city");
        setValue("address.state", "The JUNIT state");
        execute("CRUD.save");
        assertNoErrors();

        // Read
        setValue("number", "77");
        execute("CRUD.refresh");
        assertValue("number", "77");
        assertValue("name", "JUNIT Customer");

        // Delete
        execute("CRUD.delete");
        assertMessage("Customer deleted successfully");
    }

    @Test
    public void testAnotherFeature() throws Exception {
        // Another test method
    }
}
</code></pre>
      </div>
      <div class="wiki" style="display: block;">
        The main differences from JUnit 3 style are:
        <ul>
          <li><strong>Constructor:</strong> Use <code>super("ModuleName")</code> instead of <code>super(testName, "ApplicationName", "ModuleName")</code>. The test name parameter is not needed.</li>
          <li><strong>Test methods:</strong> Annotate test methods with <code>@Test</code> instead of relying on the <code>test</code> prefix naming convention (although the prefix still works).</li>
          <li><strong>Setup and teardown:</strong> The <code>setUp()</code> and <code>tearDown()</code> methods are automatically called thanks to <code>@Before</code> and <code>@After</code> annotations in <em>ModuleTestBase</em>. You can still override them if needed.</li>
          <li><strong>Import:</strong> Add <code>import org.junit.*;</code> to use JUnit 4 annotations.</li>
        </ul>
        Both JUnit 3 and JUnit 4 styles can coexist in the same project, allowing you to migrate your tests gradually as needed.<br>
      </div>
      <h2 id="summary">Summary</h2>
      You have automated the tests for all the functionality of your application. This test code seems to be more verbose and boring than the real application code. But remember, the test code is the most valuable asset you have. Right now you may not believe me, but try to do tests and once they save your life, you will not develop without test code any more.<br>
      What to test? Don't do an exhaustive test at first. It's better to test a little than to test nothing. If you try to do exhaustive testing you will end up testing nothing. Start doing a little testing of all your code, and with any new feature or fix also write the test for it. In the end, you will have a very powerful test suite. Test little but test always.<br>
      <br>
      <strong>Any problem with this lesson? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/419690/"
          rel="nofollow">Ask in the forum</a></strong><strong></strong> </div>
  </body>
</html>
