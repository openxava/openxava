<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Mapeo objeto/relacional - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link href="highlight/highlight.css" rel="stylesheet"/>
    <link href="highlight/highlightjs-copy.css" rel="stylesheet"/><script src="highlight/highlight.js"></script>
    <script src="highlight/highlightjs-copy.js"></script><script>window.addEventListener('DOMContentLoaded',function(){hljs.addPlugin(new CopyButtonPlugin({ autohide: false }));hljs.highlightAll();});</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <h1 id="toc0"><a name="Mapeo objeto/relacional"></a> <span id="breadcrumbs"> <span

            id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava </a> </span> / <a

            href="index_es.html">documentación</a> / </span> Mapeo objeto/relacional</h1>
      <strong>Guía de referencia</strong>: <a class="wiki_link" href="model_es.html">Modelo</a> | <a

        class="wiki_link" href="view_es.html">Vista</a> | <a class="wiki_link"

        href="tab_es.html">Datos tabulares</a> | <strong>Mapeo objeto/relacional</strong> | <a

        class="wiki_link" href="controllers_es.html">Controladores</a> | <a

        class="wiki_link" href="application_es.html">Aplicación</a> | <a

        class="wiki_link" href="customizing_es.html">Personalización</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">Tabla de contenidos</h1>
        <div style="margin-left: 1em;"><a href="#Mapeo%20objeto/relacional">Mapeo objeto/relacional</a></div>
        <div style="margin-left: 2em;"><a href="#Mapeo%20objeto/relacional-Mapeo%20de%20entidad">Mapeo de entidad</a></div>
        <div style="margin-left: 2em;"><a href="#Mapeo%20objeto/relacional-Mapeo%20propiedad">Mapeo propiedad</a></div>
        <div style="margin-left: 2em;"><a href="#Mapeo%20objeto/relacional-Mapeo%20de%20referencia">Mapeo de referencia</a></div>
        <div style="margin-left: 2em;"><a href="#Mapeo%20objeto/relacional-Mapeo+de+coleccion">Mapeo de colección</a></div>
        <div style="margin-left: 2em;"><a href="#Mapeo%20objeto/relacional-Mapeo%20de%20referencia%20incrustada">Mapeo de referencia incrustada</a></div>
        <div style="margin-left: 2em;"><a href="#Mapeo%20objeto/relacional-Conversion+de+tipo">Conversión de tipo</a></div>
        <div style="margin-left: 3em;"><a href="#Mapeo%20objeto/relacional-Conversion+de+tipo-Conversion+de+propiedad">Conversión de propiedad</a></div>
        <div style="margin-left: 3em;"><a href="#Mapeo%20objeto/relacional-Conversion+de+tipo-Conversion+con+multiples+columnas">Conversión con múltiples columnas</a></div>
        <div style="margin-left: 3em;"><a href="#Mapeo%20objeto/relacional-Conversion+de+tipo-Conversion+de+referencia">Conversión de referencia</a></div>
        <div style="margin-left: 2em;"><a href="#Mapeo%20objeto/relacional-Restricciones+de+valor+unico">Restricciones de valor único</a></div>
        <div style="margin-left: 3em;"><a href="#Mapeo%20objeto/relacional-Restricciones+de+valor+unico-Otros+dialectos">Otros dialectos</a></div>
      </div>
      Con el mapeo objeto relacional declaramos en que tablas y columnas de nuestra base de datos relacional se guarda la información de nuestra entidad.<br>
      Las herramientas O/R nos permiten trabajar con objetos, en vez de con tablas y columnas y generan automáticamente el código SQL necesario para leer y actualizar la base de datos. De esta forma no necesitamos acceder directamente a la base de datos con SQL, pero para eso tenemos que definir con precisión como se mapean nuestras clases a nuestras tablas, y eso es lo que se hace en las anotaciones de mapeo JPA.<br>
      Las entidades OpenXava son entidades JPA, por lo tanto el mapeo objeto/relacional en OpenXava se hace mediante <a

        class="wiki_link_ext" href="http://en.wikipedia.org/wiki/Java_Persistence_API"

        rel="nofollow">Java Persistence API</a> (JPA). Este capítulo muestra las técnicas más básicas y algunos casos especiales. Si queremos aprender más sobre JPA podemos consultar <a

        class="wiki_link_ext" href="http://www.hibernate.org/hib_docs/annotations/reference/en/html/entity.html"

        rel="nofollow">la documentación de Hibernate Annotations</a> (la implementación de JPA usada por OpenXava por defecto), o cualquier otro manual de JPA que queramos. OpenXava 6.1 o superior usa JPA 2.2.<br>
      <h2 id="toc1"><a name="Mapeo objeto/relacional-Mapeo de entidad"></a>Mapeo de entidad</h2>
      La anotación <em><a class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/Table.html"

          rel="nofollow">@Table</a></em> especifica la tabla principal para la entidad. Se pueden especificar tablas adicionales usando <em><a

          class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/SecondaryTable.html"

          rel="nofollow">@SecondaryTable</a></em> o <em><a class="wiki_link_ext"

          href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/SecondaryTables.html"

          rel="nofollow">@SecondaryTables</a></em>.<br>
      Si no se especifica <em>@Table</em> para una entidad se aplicaran los valores por defecto.<br>
      Ejemplo:<br>
<pre><code class="language-java">@Entity
@Table(name="CLI", schema="XAVATEST")
public class Cliente {</code></pre>
      <h2 id="toc2"><a name="Mapeo objeto/relacional-Mapeo propiedad"></a>Mapeo propiedad</h2>
      La anotación <em><a class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/Column.html"

          rel="nofollow">@Column</a></em> se usa para especificar como mapear una propiedad persistente. Si no se especifica <em>@Column</em> se aplican los valores por defecto.<br>
      Un ejemplo sencillo:<br>
<pre><code class="language-java">@Column(name="DESC", length=512)
private String descripcion;</code></pre>
      Un ejemplo anotando el <em>getter</em>:<br>
<pre><code class="language-java">@Column(name="DESC", nullable=false, length=512)
public String getDescripcion() { return descripcion; }</code></pre>
      Otros ejemplos:<br>
<pre><code class="language-java">@Column(name="DESC",
 columnDefinition="CLOB NOT NULL",
 table="EMP_DETAIL")
@Lob
private String descripcion;

@Column(name="ORDER_COST", updatable=false, precision=12, scale=2)
private BigDecimal coste;</code></pre>
      <h2 id="toc3"><a name="Mapeo objeto/relacional-Mapeo de referencia"></a>Mapeo de referencia</h2>
      La anotación <em><a class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/JoinColumn.html"

          rel="nofollow">@JoinColumn</a></em> se usa para especificar el mapeo de una columna para una referencia.<br>
      Ejemplo:<br>
<pre><code class="language-java">@ManyToOne
@JoinColumn(name="CLI_ID")
private Cliente cliente;</code></pre>
      Si necesitamos definir un mapeo para una clave foranea compuesta hemos de usar varias <i>@JoinColumn</i>. En este caso tanto el atributo <em>name</em> como <em>referencedColumnName</em> tienen que especificarse en cada anotación <em>@JoinColumn</em>.<br>
      Ejemplo:<br>
      <div class="wiki" id="content_view">
<pre><code class="language-java">@ManyToOne
@JoinColumn(name="FAC_AÑO", referencedColumnName="AÑO")
@JoinColumn(name="FAC_NUMERO", referencedColumnName="NUMERO")
private Factura factura;</code></pre>
      </div>
      Si usas una versión de OpenXava anterior a 6.1 (que usaba el viejo JPA 2.1) has de usar <em><a

          class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/JoinColumns.html"

          rel="nofollow">@JoinColumns</a></em>. Esta anotación agrupa anotaciones <em>@JoinColumn</em> para la misma referencia.<br>
      Ejemplo:<br>
<pre><code class="language-java">@ManyToOne
@JoinColumns({ // Sólo necesario hasta OpenXava 6.0.2/JPA 2.1
  @JoinColumn(name="FAC_AÑO", referencedColumnName="AÑO"),
  @JoinColumn(name="FAC_NUMERO", referencedColumnName="NUMERO")
})
private Factura factura;</code></pre>
      <h2 id="toc4"><a name="Mapeo objeto/relacional-Mapeo+de+coleccion"></a>Mapeo de colección</h2>
      Cuando usamos <em><a class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/OneToMany.html"

          rel="nofollow">@OneToMany</a></em> para una colección el mapeo depende de la referencia usada en la otra parte de la asociación, es decir, normalmente no es necesario hacer nada. Pero si estamos usando <em><a

          class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/ManyToMany.html"

          rel="nofollow">@ManyToMany</a></em>, quizás nos sea útil declarar la tabla de unión (<em><a

          class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/JoinTable.html"

          rel="nofollow">@JoinTable</a></em>), como sigue:<br>
<pre><code class="language-java">@ManyToMany
@JoinTable(name="CLIENTE_PROVINCIA",
 joinColumns=@JoinColumn(name="CLIENTE"),
 inverseJoinColumns=@JoinColumn(name="PROVINCIA")
)
private Collection&lt;Provincia&gt; provincias;</code></pre>
      Si omitimos <em>@JoinTable</em> se aplican los valores por defecto.<br>
    </div>
    <div class="wiki" style="display: block;"><br>
    </div>
    <div class="wiki" style="display: block;">Cuando usamos <em><a class="wiki_link_ext"

          href="http://docs.oracle.com/javaee/6/api/javax/persistence/ElementCollection.html"

          rel="nofollow">@ElementCollection</a></em> <em>(nuevo en v5.0)</em> para una colección podemos usar <em><a

          class="wiki_link_ext" href="http://docs.oracle.com/javaee/6/api/javax/persistence/CollectionTable.html"

          rel="nofollow">@CollectionTable</a></em> y <em><a class="wiki_link_ext"

          href="http://docs.oracle.com/javaee/6/api/javax/persistence/AttributeOverride.html"

          rel="nofollow">@AttributeOverride</a></em>, como sigue:<br>
      <div class="wiki" id="content_view">
<pre><code class="language-java">@ElementCollection
@CollectionTable(name="CASAS") // Usa "join column" por defecto
@AttributeOverride(name="calle",
    column=@Column(name="CASA_CALLE"))
@AttributeOverride(name="localidad",
    column=@Column(name="CASA_LOCALIDAD"))
@AttributeOverride(name="provincia",
    column=@Column(name="CASA_PROVINCIA"))
private Collection&lt;Direccion&gt; casasVacaciones;</code></pre>
        Si usas una versión de OpenXava anterior a 6.1 (con JPA 2.1) has de agrupar las <i>@AttributeOverride</i> con <em><a

            class="wiki_link_ext" href="http://docs.oracle.com/javaee/6/api/javax/persistence/AttributeOverrides.html"

            rel="nofollow">@AttributeOverrides</a></em>, así:</div>
<pre><code class="language-java">@ElementCollection
@CollectionTable(name="CASAS") // Usa "join column" por defecto
@AttributeOverrides({ // Sólo hasta OpenXava 6.0.2/JPA 2.1
    @AttributeOverride(name="calle",
        column=@Column(name="CASA_CALLE")),
    @AttributeOverride(name="localidad",
        column=@Column(name="CASA_LOCALIDAD")),
    @AttributeOverride(name="provincia",
        column=@Column(name="CASA_PROVINCIA"))
})
private Collection&lt;Direccion&gt; casasVacaciones;</code></pre>
      Si omitimos <em>@CollectionTable</em> y <em>@AttributeOverride</em> se aplican los valores por defecto.<br>
      <h2 id="toc5"><a name="Mapeo objeto/relacional-Mapeo de referencia incrustada"></a>Mapeo de referencia incrustada</h2>
      Una <a class="wiki_link" href="model_es.html#Modelo-Referencias-Referencias%20incrustadas">referencia incrustada</a> contiene información que en el modelo relacional se guarda en la misma tabla que la entidad principal. Por ejemplo si tenemos un incrustable <em>Direccion</em> asociado a un <em>Cliente</em>, los datos de la dirección se guardan en la misma tabla que los del cliente. ¿Cómo se expresa eso con JPA? </div>
    <div class="wiki" style="display: block;">Es muy sencillo, usando varias anotaciones <em><a

          class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/AttributeOverride.html"

          rel="nofollow">@AttributeOverride</a></em>, de esta forma:<br>
      <div class="wiki">
<pre><code class="language-java">@Embedded
@AttributeOverride(name="calle", column=@Column("DIR_CALLE"))
@AttributeOverride(name="codigoPostal", column=@Column("DIR_CP"))
@AttributeOverride(name="poblacion", column=@Column("DIR_POB"))
@AttributeOverride(name="pais", column=@Column("DIR_PAIS"))
private Direccion direccion;</code></pre>
        Con un OpenXava anterior a 6.1 (JPA 2.) has de usar <em><a class="wiki_link_ext"

            href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/AttributeOverrides.html"

            rel="nofollow">@AttributeOverrides</a></em>:</div>
<pre><code class="language-java">@Embedded
@AttributeOverrides({ // Sólo hasta OpenXava 6.0.2/JPA 2.1
  @AttributeOverride(name="calle", column=@Column("DIR_CALLE")),
  @AttributeOverride(name="codigoPostal", column=@Column("DIR_CP")),
  @AttributeOverride(name="poblacion", column=@Column("DIR_POB")),
  @AttributeOverride(name="pais", column=@Column("DIR_PAIS"))
})
private Direccion direccion;</code></pre>
      Si no usamos <em>@AttributeOverride</em> se asumen valores por defectos.<br>
      <h2 id="toc6"><a name="Mapeo objeto/relacional-Conversion+de+tipo"></a>Conversión de tipo</h2>
      La conversión de tipos entre Java y la base de datos relacional es un trabajo de la implementación de JPA (OpenXava usa Hibernate por defecto). Normalmente, la conversión de tipos por defecto es buena para la mayoría de los casos, pero si trabajamos con bases de datos legadas quizás necesitemos algunos de los trucos que aquí se muestran.<br>
      Dado que OpenXava usa la facilidad de conversión de tipos de Hibernate podemos aprender más en la documentación de <a

        class="wiki_link_ext" href="http://www.hibernate.org/" rel="nofollow">Hibernate</a>.<br>
      <h3 id="toc7"><a name="Mapeo objeto/relacional-Conversion+de+tipo-Conversion+de+propiedad"></a>Conversión de propiedad</h3>
      Cuando el tipo de una propiedad Java y el tipo de su columna correspondiente en la base de datos no coincide necesitamos escribir un <em>Hibernate Type</em> para poder hacer nuestra conversión de tipo personalizada.<br>
      Por ejemplo, si tenemos una propiedad de tipo <em>String []</em>, y queremos almacenar su valor concatenándolo en una sola columna de base de datos de tipo VARCHAR. Entonces tenemos que declarar la conversión para nuestra propiedad de esta manera:<br>
<pre><code class="language-java">@Type(type="org.openxava.test.types.RegionesType")
private String [] regiones;</code></pre>
      La lógica de conversión en RegionesType es:<br>
<pre><code class="language-java">package org.openxava.test.types;

import java.io.*;
import java.sql.*;

import org.apache.commons.logging.*;
import org.hibernate.*;
import org.hibernate.usertype.*;
import org.hibernate.engine.spi.*; // A partir de OpenXava 5.3 que usa Hibernate 4.3
import org.openxava.util.*;

/**
 *
 * @author Javier Paniza
 */
public class RegionesType implements UserType { // 1

    public int[] sqlTypes() {
        return new int[] { Types.VARCHAR };
    }

    public Class returnedClass() {
        return String[].class;
    }

    public boolean equals(Object obj1, Object obj2) throws HibernateException {
        return Is.equal(obj1, obj2);
    }

    public int hashCode(Object obj) throws HibernateException {
        return obj.hashCode();
    }

    // El argumento SessionImplementor a partir de OpenXava 5.3 que usa Hibernate 4.3
    // SharedSessionContractImplementor en lugar de SessionImplementor a partir de OpenXava 6.1 que usa Hibernate 5.3
   public Object nullSafeGet(ResultSet resultSet, String[] names, SharedSessionContractImplementor implementor, Object owner) // 2
        throws HibernateException, SQLException
    {
        Object o = resultSet.getObject(names[0]);
        if (o == null) return new String[0];
        String dbValue = (String) o;
        String [] javaValue = new String [dbValue.length()];
        for (int i = 0; i &lt; javaValue.length; i++) {
            javaValue[i] = String.valueOf(dbValue.charAt(i));
        }
        return javaValue;
    }

    // El argumento SessionImplementor a partir de OpenXava 5.3 que usa Hibernate 4.3
    // SharedSessionContractImplementor en lugar de SessionImplementor a partir de OpenXava 6.1 que usa Hibernate 5.3
   public void nullSafeSet(PreparedStatement ps, Object value, int index, SharedSessionContractImplementor implementor) // 3
        throws HibernateException, SQLException
    {
        if (value == null) {
            ps.setString(index, "");
            return;
        }
        String [] javaValue = (String []) value;
        StringBuffer dbValue = new StringBuffer();
        for (int i = 0; i &lt; javaValue.length; i++) {
            dbValue.append(javaValue[i]);
        }
        ps.setString(index, dbValue.toString());
    }

    public Object deepCopy(Object obj) throws HibernateException {
        return obj == null?null:((String []) obj).clone();
    }

    public boolean isMutable() {
        return true;
    }

    public Serializable disassemble(Object obj) throws HibernateException {
        return (Serializable) obj;
    }

    public Object assemble(Serializable cached, Object owner) throws HibernateException {
        return cached;
    }

    public Object replace(Object original, Object target, Object owner) throws HibernateException {
        return original;
    }

}</code></pre>
      El conversor de tipo ha de implementar <em><a class="wiki_link_ext"

          href="http://docs.jboss.org/hibernate/orm/5.3/javadocs/org/hibernate/usertype/UserType.html"

          rel="nofollow">org.hibernate.usertype.UserType</a></em> (1). Los métodos principales son <em>nullSafeGet</em> (2) para leer de la base de datos y convertir a Java, y <em>nullSafeSet</em> (3) para escribir el valor Java en la base de datos.<br>
      OpenXava tiene conversores de tipo de Hibernate genéricos en el paquete <em><a

          class="wiki_link_ext" href="http://www.openxava.org/OpenXavaDoc/apidocs/org/openxava/types/package-summary.html"

          rel="nofollow">org.openxava.types</a></em> listos para usar. Uno de ellos es <em><a

          class="wiki_link_ext" href="http://www.openxava.org/OpenXavaDoc/apidocs/org/openxava/types/EnumLetterType.html"

          rel="nofollow">EnumLetterType</a></em>, que permite mapear propiedades de tipo <em>enum</em>. Por ejemplo, si tenemos una propiedad como esta:<br>
<pre><code class="language-java">private Distancia distancia;
public enum Distancia { LOCAL, NACIONAL, INTERNACIONAL };</code></pre>
      En esta propiedad Java 'LOCAL' es 1, 'NATIONAL' es 2 and 'INTERNATIONAL' es 3 cuando la propiedad se almacena en la base de datos. Pero, ¿qué ocurre, si en la base de datos se almacena una única letra ('L', 'N' or 'I')? En este caso podemos usar <em>EnumLetterType</em> de esta forma:<br>
<pre><code class="language-java">@Type(type="org.openxava.types.EnumLetterType",
    parameters={
        @Parameter(name="letters", value="LNI"),
        @Parameter(name="enumType", value="org.openxava.test.modelo.Albaran$Distancia")
    }
)
private Distancia distancia;
public enum Distancia { LOCAL, NACIONAL, INTERNACIONAL }</code></pre>
      Al poner 'LNI' como valor para <em>letters</em>, hace corresponder la 'L' con 1, la 'N' con 2 y la 'I' con 3. Vemos como el que se puedan configurar propiedades del conversor de tipos nos permite hacer conversores reutilizables.<br>
      <h3 id="toc8"><a name="Mapeo objeto/relacional-Conversion+de+tipo-Conversion+con+multiples+columnas"></a>Conversión con múltiples columnas</h3>
      Con <em><a class="wiki_link_ext" href="http://docs.jboss.org/hibernate/orm/5.3/javadocs/org/hibernate/usertype/CompositeUserType.html"

          rel="nofollow">CompositeUserType</a></em> podemos hacer que varias columnas de la tabla de base de datos correspondan a una propiedad en Java. Esto es útil, por ejemplo cuando tenemos propiedades cuyo tipo Java son clases definidas por nosotros que tienen a su vez varias propiedades susceptibles de ser almacenadas, y también se usa mucho cuando nos enfrentamos a esquemas de bases de datos legados.<br>
      Un ejemplo típico sería usar el conversor genérico <em><a class="wiki_link_ext"

          href="http://www.openxava.org/OpenXavaDoc/apidocs/org/openxava/types/Date3Type.html"

          rel="nofollow">Date3Type</a></em>, que permite almacenar en la base de datos 3 columnas y en Java una propiedad <em>java.util.Date</em>.<br>
<pre><code class="language-java">@Type(type="org.openxava.types.Date3Type")
@Columns(columns = {
    @Column(name="AÑOENTREGA"),
    @Column(name="MESENTREGA"),
    @Column(name="DIAENTREGA")
})
private java.util.Date fechaEntrega;</code></pre>
      DIAENTREGA, MESENTREGA y AÑOENTREGA son las tres columnas que en la base de datos guardan la fecha de entrega. Y aquí <em>Date3Type</em>:<br>
<pre><code class="language-java">package org.openxava.types;

import java.io.*;
import java.sql.*;

import org.hibernate.*;
import org.hibernate.engine.*; // Hasta OpenXava 5.2.x
import org.hibernate.type.*; // A partir de OpenXava 5.3 que usa Hibernate 4.3
import org.hibernate.usertype.*;
import org.openxava.util.*;

/**
 * In java a &lt;tt&gt;java.util.Date&lt;/tt&gt; and in database 3 columns of
 * integer type. &lt;p&gt;
 *
 * @author Javier Paniza
 */
public class Date3Type implements CompositeUserType { // 1

    public String[] getPropertyNames() {
        return new String[] { "year", "month", "day" };
    }

    public Type[] getPropertyTypes() {
        // return new Type[] { Hibernate.INTEGER, Hibernate.INTEGER, Hibernate.INTEGER }; // Antes OpenXava 5.3/Hibernate 4.3
        return new Type[] { IntegerType.INSTANCE, IntegerType.INSTANCE, IntegerType.INSTANCE }; // A partir de OpenXava 5.3/Hibernate 4.3
    }

    public Object getPropertyValue(Object component, int property) throws HibernateException { // 2
        java.util.Date date = (java.util.Date) component;
        switch (property) {
            case 0:
                return Dates.getYear(date);
            case 1:
                return Dates.getMonth(date);
            case 2:
                return Dates.getYear(date);
        }
        throw new HibernateException(XavaResources.getString("date3_type_only_3_properties"));
    }

    public void setPropertyValue(Object component, int property, Object value)
        throws HibernateException // 3
    {
        java.util.Date date = (java.util.Date) component;
        int intValue = value == null?0:((Number) value).intValue();
        switch (property) {
            case 0:
                Dates.setYear(date, intValue);
            case 1:
                Dates.setMonth(date, intValue);
            case 2:
                Dates.setYear(date, intValue);
        }
        throw new HibernateException(XavaResources.getString("date3_type_only_3_properties"));
    }

    public Class returnedClass() {
        return java.util.Date.class;
    }

    public boolean equals(Object x, Object y) throws HibernateException {
        if (x==y) return true;
        if (x==null || y==null) return false;
        return !Dates.isDifferentDay((java.util.Date) x, (java.util.Date) y);
    }

    public int hashCode(Object x) throws HibernateException {
        return x.hashCode();
    }

    // SharedSessionContractImplementor en lugar de SessionImplementor a partir de OpenXava 6.1 que usa Hibernate 5.3
   public Object nullSafeGet(ResultSet rs, String[] names, SharedSessionContractImplementor session, Object owner)
        throws HibernateException, SQLException // 4
    {
        /* Antes OpenXava 5.3/Hibernate 4.3
        Number year = (Number) Hibernate.INTEGER.nullSafeGet( rs, names[0] );
        Number month = (Number) Hibernate.INTEGER.nullSafeGet( rs, names[1] );
        Number day = (Number) Hibernate.INTEGER.nullSafeGet( rs, names[2] );
        */
        // A partir de OpenXava 5.3/Hibernate 4.3
        Number year = (Number) IntegerType.INSTANCE.nullSafeGet( rs, names[0], session, owner);
        Number month = (Number) IntegerType.INSTANCE.nullSafeGet( rs, names[1], session, owner );
        Number day = (Number) IntegerType.INSTANCE.nullSafeGet( rs, names[2], session, owner );

        int iyear = year == null?0:year.intValue();
        int imonth = month == null?0:month.intValue();
        int iday = day == null?0:day.intValue();

        return Dates.create(iday, imonth, iyear);
    }

    // SharedSessionContractImplementor en lugar de SessionImplementor a partir de OpenXava 6.1 que usa Hibernate 5.3   
    public void nullSafeSet(PreparedStatement st, Object value, int index, SharedSessionContractImplementor session)
        throws HibernateException, SQLException // 5
    {
        java.util.Date d = (java.util.Date) value;
        /* Antes OpenXava 5.3/Hibernate 4.3
        Hibernate.INTEGER.nullSafeSet(st, Dates.getYear(d), index);
        Hibernate.INTEGER.nullSafeSet(st, Dates.getMonth(d), index + 1);
        Hibernate.INTEGER.nullSafeSet(st, Dates.getDay(d), index + 2);
        */
        // A partir de OpenXava 5.3/Hibernate 4.3
        IntegerType.INSTANCE.nullSafeSet(st, Dates.getYear(d), index, session);
        IntegerType.INSTANCE.nullSafeSet(st, Dates.getMonth(d), index + 1, session);
        IntegerType.INSTANCE.nullSafeSet(st, Dates.getDay(d), index + 2, session);
    }

    public Object deepCopy(Object value) throws HibernateException {
        java.util.Date d = (java.util.Date) value;
        if (value == null) return null;
        return (java.util.Date) d.clone();
    }

    public boolean isMutable() {
        return true;
    }

    // SharedSessionContractImplementor en lugar de SessionImplementor a partir de OpenXava 6.1 que usa Hibernate 5.3
   public Serializable disassemble(Object value, SharedSessionContractImplementor session)
        throws HibernateException
    {
        return (Serializable) deepCopy(value);
    }

    // SharedSessionContractImplementor en lugar de SessionImplementor a partir de OpenXava 6.1 que usa Hibernate 5.3
    public Object assemble(Serializable cached, SharedSessionContractImplementor session, Object owner)
        throws HibernateException
    {
        return deepCopy(cached);
    }

    // SharedSessionContractImplementor en lugar de SessionImplementor a partir de OpenXava 6.1 que usa Hibernate 5.3
   public Object replace(Object original, Object target, SharedSessionContractImplementor session, Object owner)
        throws HibernateException
    {
        return deepCopy(original);
    }

}</code></pre>
      Como se ve el conversor de tipo implementa <em><a class="wiki_link_ext"

          href="http://docs.jboss.org/hibernate/orm/5.3/javadocs/org/hibernate/usertype/CompositeUserType.html"

          rel="nofollow">CompositeUserType</a></em> (1). Los métodos clave son <em>getPropertyValue</em> (2) y <em>setPropertyValue</em> (3) para coger y poner valores en las propiedades del objeto del tipo compuesto, y <em>nullSafeGet</em> (4) y <em>nullSafeSet</em> (5) para leer y grabar este objeto en la base de datos.<br>
      <h3 id="toc9"><a name="Mapeo objeto/relacional-Conversion+de+tipo-Conversion+de+referencia"></a>Conversión de referencia</h3>
      La conversión de referencias no se soporta directamente por Hibernate. Pero en alguna circunstancias extremas puede ser que necesitemos hacer conversión de referencias. En esta sección se explica como hacerlo.<br>
      Por ejemplo, puede que tengamos una referencia a permiso de conducir usando dos columnas, PERMISOCONDUCIR_NIVEL y PERMISOCONDUCIR_TIPO, y la columna PERMISOCONDUCIR_TIPO no admita nulos, pero es posible que el objeto puede no tener permiso de conducir, en cuyo caso la columna PERMISOCONDUCIR_TIPO almacena una cadena vacía. Esto no es algo normal si nosotros diseñamos la base de datos usando claves foráneas, pero si la base de datos fue diseñada por un programador RPG, por ejemplo, esto se habrá hecho de esta forma, porque los programadores RPG no están acostumbrados a lidiar con nulos.<br>
      Es decir, necesitamos una conversión para PERMISOCONDUCIR_TIPO, para transformar el nulo en una cadena vacía. Esto se puede conseguir con un código como este:<br>
<pre><code class="language-java">// Aplicamos conversión (nulo en una cadena vacía) a la columna PERMISOCONDUCIR_TIPO
// Para hacerlo, creamos permisoConducir_nivel y permisoConducir_tipo
// Hacemos JoinColumns no insertable ni modificable, modificamos el método get/setPermisoConducir
// y creamos un método conversionPermisoConducir().
@ManyToOne(fetch=FetchType.LAZY)
@JoinColumns({ // 1
 @JoinColumn(name="PERMISOCONDUCIR_NIVEL", referencedColumnName="NIVEL",
 insertable=false, updatable=false),
 @JoinColumn(name="PERMISOCONDUCIR_TIPO", referencedColumnName="TIPO",
 insertable=false, updatable=false)
})
private PermisoConducir permisoConducir;
private Integer permisoConducir_nivel; // 2
private String permisoConducir_tipo; // 2

public PermisoConducir getPermisoConducir() { // 3
 // De esta manera porque la columna tipo de permiso de conducir no admite nulos
 try {
 if (permisoConducir != null) permisoConducir.toString(); // para forzar la carga
 return permisoConducir;
 }
 catch (EntityNotFoundException ex) {
 return null;
 }
}

public void setPermisoConducir(PermisoConducir permiso) { // 4
 // De esta manera porque la columna tipo de permiso de conducir no admite nulos
 this.permisoConducir = permiso;
 this.permisoConducir_nivel = permiso==null?null:permiso.getNivel();
 this.permisoConducir_tipo = permiso==null?null:permiso.getTipo();
}

@PrePersist @PreUpdate
private void conversionPermisoConducir() { // 5
 if (this.permisoConducir_tipo == null) this.permisoConducir_tipo = "";
}</code></pre>
      Lo primero poner <em><a class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/JoinColumns.html"

          rel="nofollow">@JoinColumns</a></em> con <em>insertable=false</em> y <em>updatable=false</em> en todas las <em><a

          class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/JoinColumn.html"

          rel="nofollow">@JoinColumn</a></em> (1), de esta manera la referencia es leida de la base de datos, pero no escrita. También tenemos que definir propiedades planas para almacenar la clave foránea de la referencia (2).<br>
      Ahora tenemos que escribir un <em>getter</em>, <em>getPermisoConducir()</em> (3), para devolver nulo cuand la referencia no se encuentre, y un <em>setter</em>, <em>setPermisoConducir()</em> (4), para asignar la clave de la referencia a las propiedades planas correspondientes.<br>
      Finalmente, hemos de escribir un <a class="wiki_link" href="model_es.html#Modelo-Metodos+de+retrollamada+de+JPA">método de retrollamada</a>, <em>conversionPermisoConducir()</em> (5), para hacer el trabajo de conversión. Este método será automáticamente ejecutado al crear y actualizar.<br>
      Este ejemplo enseña como es posible envolver bases de datos legadas simplemente usando un poco de programación y algunos recursos básicos de JPA.<br>
      <h2 id="toc10"><a name="Mapeo objeto/relacional-Restricciones+de+valor+unico"></a>Restricciones de valor único</h2>
      Desde la v4.9 Openxava permite personalizar los mensajes de las restricciones declaradas en el elemento <em>uniqueConstraints</em> de <em><a

          class="wiki_link_ext" href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/Table.html"

          rel="nofollow">@Table</a></em> y <em><a class="wiki_link_ext"

          href="http://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/SecondaryTable.html"

          rel="nofollow">@SecondaryTable</a></em>, así como de <em>@Column(unique=true)</em>. Para ello se debe tener en cuenta algunas consideraciones previas respecto a Hibernate (la implementación de JPA usada por defecto en Openxava)<br>
      Ejemplo:<br>
<pre><code class="language-java">package org.openxava.test.model;

@Entity
@SecondaryTable(
    name="APPLICATIONUSER_INFO",
    uniqueConstraints={
        @UniqueConstraint(name="not_repeat_user_info", columnNames={"name", "birthdate", "sex"})
    }
)
public class ApplicationUser extends Identifiable {

    @Required
    @Column(length=8, unique=true) //not_repeat_nic
    private String nic;

    @Column(length=40, table="APPLICATIONUSER_INFO")
    private String name;

    @Column(length=40, table="APPLICATIONUSER_INFO")
    private Date birthdate;

    @Column(table="APPLICATIONUSER_INFO")
    @Enumerated(EnumType.STRING)
    private Sex sex;
    public enum Sex { MALE, FEMALE }
   ...
}</code></pre>
      <ul>
        <li>Al construir nuestra aplicación (ejecutando <em>build.xml</em>), Hibernate utilizará el dialecto declarado en el <strong><em>persistence.xml</em></strong> de tu proyecto, para generar un <em><a

              class="wiki_link_ext" href="http://en.wikipedia.org/wiki/Data_definition_language"

              rel="nofollow">DDL</a></em> que mapeará la estructura de tus clases a tablas de la base de datos. Si, por ejemplo, estás trabajando con una base de datos <em>MySQL</em>, mostrará:</li>
      </ul>
<pre><code class="language-sql">create table APPLICATIONUSER_INFO (
    birthdate datetime,
    name varchar(40),
    sex varchar(255),
    id varchar(32) not null,
    primary key (id), unique (name, birthdate, sex)
)
create table ApplicationUser (
    id varchar(32) not null,
    nic varchar(8) unique,
    primary key (id)
)
alter table APPLICATIONUSER_INFO
    add index FK375C9572BA846971 (id),
    add constraint FK375C9572BA846971 foreign key (id) references ApplicationUser (id)</code></pre>
      Como se observa Hibernate ha mapeado la estructura de nuestra clase <strong><em>ApplicationUser</em></strong>, incluso ha creado la restricciones <strong><em>unique (name, birthdate, sex)</em></strong> y <strong><em>nic varchar(8) unique</em></strong> pero no ha asignado el nombre <em>(“no_repeat_user_info”)</em> declarado en <strong><em>@UniqueConstraint</em></strong>, ni existe un elemento en <strong><em>@Column</em></strong> que nos permita dar nombre a la restricción <strong><em>unique=true</em></strong>, dejando que el motor de base de datos asigne nombres por defecto.<br>
      <ul>
        <li>Al producirse una violación a cualquiera de las restricciones anterioriores, Hibernate administrará el error, lanzado por el motor de base de datos, creando una <strong><em>org.hibernate.exception.ConstraintViolationException</em></strong> o en algunos casos una <strong><em>org.hibernate.exception.GenericJDBCException</em></strong> -como es el de HSQL-. <strong><em>ConstraintViolationException</em></strong> tiene una propiedad <strong><em>constraintName</em></strong> que es asignada por Hibernate después de extraer el nombre de la restricción que tiene la base de datos.</li>
        <li>Es el dialecto definido en tu proyecto el encargado de extraer el nombre de la restricción que será asignado al <strong><em>contraintName</em></strong>. Ésto lo hace por medio del método <strong><em>extractConstraintName(SQLException sqle)</em></strong> de la interfaz <strong><em>ViolatedConstraintNameExtracter</em></strong>. Pero sucede que los dialectos proporcionados por Hibernate no siempre realizan adecuadamente la extracción del constraintName. Para nuestro ejemplo, el dialecto <strong><em>MySQL5Dialect</em></strong> -de Hibernate 3.6.10 que usa Openxava- ni implementa la interfaz <strong><em>ViolatedConstraintNameExtracter</em></strong> -Hibernate4 ya lo hace adecuadamente-.</li>
      </ul>
      <br>
      Por lo tanto, si quisiéramos generar un mensaje personalizado para las restricciones anteriores, hacemos:<br>
      <ul>
        <li>Para mantener coherencia entre el nombre de la <strong><em>@UniqueConstraint</em></strong> y el nombre de la restricción en la base de datos, la que Hibernate administrará por medio del <em>contraintName</em> de <em>ConstraintViolationException</em>, mapeamos manualmente el nombre de la restricción en la base de datos:</li>
      </ul>
<pre><code class="language-sql">create table APPLICATIONUSER_INFO (
   birthdate datetime,
   name varchar(40),
   sex varchar(255),
   id varchar(32) not null,
   primary key (id),
   unique key `not_repeat_user_info` (name, birthdate, sex)
)</code></pre>
      <ul>
        <li>Igual para la restricción de @Column:</li>
      </ul>
<pre><code class="language-sql">create table ApplicationUser (
   id varchar(32) not null,
   nic varchar(8),
   primary key (id),
   unique key `not_repeat_nic` (nic)
)</code></pre>
      <ul>
        <li>Si el dialecto no es el adecuado lo redefinimos:</li>
      </ul>
<pre><code class="language-java">package dialect;

import java.sql.*;
import org.hibernate.dialect.*;
import org.hibernate.exception.*;

public class XMySQL5Dialect extends MySQL5Dialect {

    public XMySQL5Dialect(){}

    private static ViolatedConstraintNameExtracter EXTRACTER = new TemplatedViolatedConstraintNameExtracter() {
        public String extractConstraintName(SQLException sqle) {
            try {
                int sqlState = Integer.valueOf( JDBCExceptionHelper.extractSqlState(sqle)).intValue();
                switch (sqlState) {
                    case 23000: return extractUsingTemplate("for key '","'", sqle.getMessage());
                    default: return null;
                }
            } catch (NumberFormatException nfe) {
                return null;
            }
        }
    };

    @Override
    public ViolatedConstraintNameExtracter getViolatedConstraintNameExtracter() {
        return EXTRACTER;
    }
}</code></pre>
      <ul>
        <li>Asignamos el nuevo dialecto en el <strong><em>persistence.xml</em></strong> de nuestro proyecto.</li>
      </ul>
<pre><code class="language-xml">...
&lt;property name="hibernate.dialect"value="dialect.XMySQL5Dialect"/&gt;
...</code></pre>
      <ul>
        <li>Finalmente, declaramos los nombres asignados a las restricciones como identificadores de mensajes en el archivo i18n de nuestra aplicación.</li>
      </ul>
      <h3 id="toc11"><a name="Mapeo objeto/relacional-Restricciones+de+valor+unico-Otros+dialectos"></a>Otros dialectos</h3>
<pre><code class="language-java">import java.sql.*;

import org.hibernate.dialect.*;
import org.hibernate.exception.*;

public class XPostgreSQLDialect extends PostgreSQLDialect {

  public XPostgreSQLDialect(){}

  private static ViolatedConstraintNameExtracter EXTRACTER = new TemplatedViolatedConstraintNameExtracter() {
    public String extractConstraintName(SQLException sqle) {
        try {
            int sqlState = Integer.valueOf( JDBCExceptionHelper.extractSqlState(sqle)).intValue();
            switch (sqlState) {
                // CHECK VIOLATION
                case 23514: return extractUsingTemplate("violates check constraint \"","\"", sqle.getMessage());
                // UNIQUE VIOLATION
                case 23505:
                    if (sqle.getMessage().indexOf("violates unique constraint \"") &gt; -1)
                        return extractUsingTemplate("violates unique constraint \"","\"", sqle.getMessage());
                    else if (sqle.getNextException() != null )
                        return extractConstraintName(sqle.getNextException());
                    else
                        return "UNIQUE_CONSTRAINT_VIOLATION_UNKNOWN";
                // FOREIGN KEY VIOLATION
                case 23503: return extractUsingTemplate("violates foreign key constraint \"","\"", sqle.getMessage());
                // NOT NULL VIOLATION
                case 23502: return extractUsingTemplate("null value in column \"","\" violates not-null constraint", sqle.getMessage());
                // RESTRICT VIOLATION
                case 23001: return null;
                // ALL OTHER
                default: return null;
                }
            } catch (NumberFormatException nfe) {
                return null;
            }
        }
    };

  @Override
  public ViolatedConstraintNameExtracter getViolatedConstraintNameExtracter() {
            return EXTRACTER;
  }
}</code></pre>
<pre><code class="language-java">import java.sql.*;
import org.hibernate.dialect.*;
import org.hibernate.exception.*;

public class XSQLServerDialect extends SQLServer2008Dialect {

   public XSQLServerDialect() {}

   private static ViolatedConstraintNameExtracter EXTRACTER = new TemplatedViolatedConstraintNameExtracter() {
    public String extractConstraintName(SQLException sqle) {
        try {
            int sqlState = Integer.valueOf(JDBCExceptionHelper.extractSqlState(sqle)).intValue();
            switch (sqlState) {
                case 23000:
                    return extractUsingTemplate("UNIQUE KEY '", "'", sqle.getMessage());
                default:
                    return null;
            }
        } catch (NumberFormatException nfe) {
            return null;
        }
    }
    };

    @Override
     public ViolatedConstraintNameExtracter getViolatedConstraintNameExtracter() {
     return EXTRACTER;
     }
}</code></pre>
    </div>
  </body>
</html>
