<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lección 11: Comportamiento y lógica de negocio - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <h1><a name="comportamiento-y-logica-de-negocio"></a> <span id="breadcrumbs">
          <span id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava
              </a> </span> / <a href="index_es.html">documentación</a> / </span>
        Lección 11: Comportamiento y lógica de negocio </h1>
      <strong>Curso</strong>: <a class="wiki_link" href="getting-started_es.html">1.
        Primeros pasos</a> | <a class="wiki_link" href="basic-domain-model1_es.html">2.
        Modelo básico del dominio (1)</a> | <a class="wiki_link" href="basic-domain-model2_es.html">3.
        Modelo básico del dominio (2)</a> | <a class="wiki_link" href="refining-user-interface_es.html">4.
        Refinar la interfaz de usuario</a> | <a class="wiki_link" href="agile-development_es.html">5.
        Desarrollo ágil</a> | <a class="wiki_link" href="testing_es.html">6.
        Pruebas automáticas</a> | <a class="wiki_link" href="inheritance_es.html">7.
        Herencia</a> | <a class="wiki_link" href="basic-business-logic_es.html">8.
        Lógica de negocio básica</a> | <a class="wiki_link" href="validation_es.html">9.
        Validación avanzada</a> | <a class="wiki_link" href="refining-standard-behavior_es.html">10.
        Refinar el comportamiento predefinido</a> | <strong>11. Comportamiento
        y lógica de negocio</strong> | <a class="wiki_link" href="references-collections_es.html">12.
        Referencias y colecciones</a> | <a class="wiki_link" href="philosophy_es.html">A.
        Arquitectura y filosofía</a> | <a class="wiki_link" href="jpa_es.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_es.html">C.
        Anotaciones</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">Tabla de contenidos</h1>
        <div style="margin-left: 1em;"><a href="#comportamiento-y-logica-de-negocio">Lección
            11: Comportamiento y lógica de negocio</a></div>
        <div style="margin-left: 2em;"><a href="#logica-de-negocio-desde-el-modo-detalle">Lógica
            de negocio desde el modo detalle</a></div>
        <div style="margin-left: 3em;"><a href="#crear-una-accion-para-ejecutar-logica-personalizada">Crear
            una acción para ejecutar lógica personalizada</a></div>
        <div style="margin-left: 3em;"><a href="#escribiendo-la-logica-de-negocio-real-en-la-entidad">Escribiendo
            la lógica de negocio real en la entidad</a></div>
        <div style="margin-left: 3em;"><a href="#escribe-menos-codigo-usando-apache-commons-beanutils">Escribe
            menos código usando Apache Commons BeanUtils</a></div>
        <div style="margin-left: 3em;"><a href="#excepciones-de-aplicacion">Excepciones
            de aplicación</a></div>
        <div style="margin-left: 3em;"><a href="#validar-desde-la-accion">Validar
            desde la acción</a></div>
        <div style="margin-left: 3em;"><a href="#evento-onchange-para-ocultar-mostrar-una-accion-por-codigo">Evento
            OnChange para ocultar/mostrar una acción por código</a></div>
        <div style="margin-left: 2em;"><a href="#logica-de-negocio-desde-el-modo-lista">Lógica
            de negocio desde el modo lista</a></div>
        <div style="margin-left: 3em;"><a href="#accion-de-lista-con-logica-propia">Acción
            de lista con lógica propia</a></div>
        <div style="margin-left: 3em;"><a href="#logica-de-negocio-en-el-modelo-sobre-varias-entidades">Lógica
            de negocio en el modelo sobre varias entidades</a></div>
        <div style="margin-left: 2em;"><a href="#mostrar-un-dialogo">Mostrar un
            diálogo</a></div>
        <div style="margin-left: 3em;"><a href="#usar-showdialog">Usar
            showDialog()</a></div>
        <div style="margin-left: 3em;"><a href="#definir-las-acciones-del-dialogo">Definir
            las acciones del diálogo</a></div>
        <div style="margin-left: 3em;"><a href="#cerrar-el-dialogo">Cerrar el
            diálogo</a></div>
        <div style="margin-left: 3em;"><a href="#vista-plana-en-lugar-de-dialogo">Vista
            plana en lugar de diálogo</a></div>
        <div style="margin-left: 2em;"><a href="#pruebas-junit">Pruebas JUnit</a></div>
        <div style="margin-left: 3em;"><a href="#probar-la-accion-de-modo-detalle">Probar
            la acción de modo detalle</a></div>
        <div style="margin-left: 3em;"><a href="#buscar-una-entidad-para-la-prueba-usando-el-modo-lista-y-jpa">Buscar
            una entidad para la prueba usando el modo lista y JPA</a></div>
        <div style="margin-left: 3em;"><a href="#probar-que-la-accion-se-oculta-cuando-no-aplica">Probar
            que la acción se oculta cuando no aplica</a></div>
        <div style="margin-left: 3em;"><a href="#probar-la-accion-de-modo-lista">Probar
            la acción de modo lista</a></div>
        <div style="margin-left: 3em;"><a href="#verificar-datos-de-prueba">Verificar
            datos de prueba</a></div>
        <div style="margin-left: 3em;"><a href="#probar-casos-excepcionales">Probar
            casos excepcionales</a></div>
        <div style="margin-left: 2em;"><a href="#resumen">Resumen</a></div>
      </div>
      OpenXava no es simplemente un marco de trabajo para hacer mantenimientos
      (altas, bajas, modificaciones y consultas), más bien está concebido para
      desarrollar aplicaciones de gestión plenamente funcionales. Hasta ahora
      hemos aprendido como crear y refinar la aplicación para manejar los datos.
      Ahora vamos a posibilitar al usuario la ejecución de lógica de negocio
      específica.<br>
      En esta lección vamos a ver como escribir lógica de negocio en el modelo y
      llamar a esta lógica desde acciones personalizadas. Así podrás transformar
      tu aplicación de gestión de datos en una herramienta útil para el trabajo
      cotidiano de tu usuario.
      <h2><a name="logica-de-negocio-desde-el-modo-detalle"></a>Lógica de
        negocio desde el modo detalle</h2>
      Empezaremos con el caso más simple: un botón en modo detalle para ejecutar
      cierta lógica. En este caso para crear la factura desde un pedido:<br>
      <img src="files/business-logic-behavior_es010.png" alt="business-logic-behavior_es010.png"
        title="business-logic-behavior_es010.png"><br>
      Aquí se muestra como esta nueva acción coge el pedido actual y crea una
      factura a partir de él. Simplemente copia todos los datos del pedido a la
      nueva factura, incluyendo las líneas de detalle. Se muestra un mensaje y
      la pestaña FACTURA del pedido visualizará la factura recién creada. Veamos
      como codificar este comportamiento.
      <h3><a name="crear-una-accion-para-ejecutar-logica-personalizada"></a>Crear
        una acción para ejecutar lógica personalizada</h3>
      Como ya sabes el primer paso para tener una acción personalizada en tu
      módulo es definir un controlador con esa acción. Por tanto, editemos <i>
        controladores.xml</i> y añadamos un nuevo controlador. El siguiente
      código muestra el controlador <i>Pedido</i>:
      <pre><code class="xml">&lt;controlador nombre="Pedido"&gt;
	&lt;hereda-de controlador="Facturacion"/&gt; &lt;!-- Para tener las acciones estándar --&gt;

	&lt;accion nombre="crearFactura" modo="detail"
		clase="com.tuempresa.facturacion.acciones.CrearFacturaDesdePedido"/&gt;
	&lt;!-- modo="detail" : Sólo en modo detalle --&gt;

&lt;/controlador&gt;
</code></pre> Dado que hemos seguido la convención de dar al controlador el
      mismo nombre que a la entidad y el módulo, ya tenemos automáticamente esta
      nueva acción disponible para <i>Pedido</i>. El controlador <i>Pedido</i>
      desciende del controlador <i>Facturacion</i>. Recuerda que creamos un
      controlador <i>Facturacion</i> en la lección 7. Es un refinamiento del
      controlador <i>Typical</i>.<br>
      Ahora hemos de escribir el código Java para la acción. Puedes verlo aquí:
      <pre><code class="java">package com.tuempresa.facturacion.acciones; // En el paquete 'acciones'

import org.openxava.actions.*;
import org.openxava.jpa.*;
import com.tuempresa.facturacion.modelo.*;

public class CrearFacturaDesdePedido
    extends ViewBaseAction { // Para usar getView()

    public void execute() throws Exception {
        Pedido pedido = XPersistence.getManager().find( // Usamos JPA para obtener la
            Pedido.class, // entidad Pedido visualizada en la vista
            getView().getValue("oid"));
        pedido.crearFactura(); // El trabajo de verdad lo delegamos en la entidad
        getView().refresh(); // Para ver la factura creada en la pestaña FACTURA
        addMessage("factura_creada_desde_pedido", // Mensaje de confirmación
            pedido.getFactura());
    }
}
</code></pre> Realmente simple. Buscamos la entidad <i>Pedido</i>, llamamos al
      método <i> crearFactura()</i>, refrescamos la vista y mostramos un
      mensaje. Fíjate como la acción es un mero intermediario entre la vista (la
      interfaz de usuario) y el modelo (la lógica de negocio).<br>
      Recuerda añadir el texto del mensaje en el archivo <i>MensajesFacturacion_es.properties</i>
      de la carpeta <i>i18n</i>:
      <pre><code class="properties">factura_creada_desde_pedido=Factura {0} creada a partir del pedido actual
</code></pre> Sin embargo, el mensaje tal cual está no se muestra de forma
      agradable, porque enviamos como argumento un objeto <i>Factura</i>.
      Necesitamos un <i>toString()</i> para <i>Factura</i> y <i>Pedido</i>
      que sea útil para el usuario. Sobrescribiremos <i>toString()</i> de <i>DocumentoComercial</i>
      (el padre de <i>Factura</i> y <i> Pedido</i>) para conseguirlo. Puedes
      ver este método <i>toString()</i>:
      <pre><code class="java">abstract public class DocumentoComercial extends Eliminable { {

    ...

    public String toString() {
        return anyo + "/" + numero;
    }
}
</code></pre> El año y el número son perfectos para identificar una factura o
      pedido desde el punto de vista del usuario.<br>
      Esto es todo para la acción. Veamos la pieza restante, el método <i>
        crearFactura()</i> de la entidad <i>Pedido</i>.
      <h3><a name="escribiendo-la-logica-de-negocio-real-en-la-entidad"></a>Escribiendo
        la lógica de negocio real en la entidad</h3>
      La lógica de negocio para crear una nueva <i>Factura</i> está en la
      entidad <i>Pedido</i>, no en la acción. Esto es la forma natural de
      hacerlo. El principio esencial de la Orientación a Objetos es que los
      objetos no son solo datos, sino datos y lógica. El código más bello es
      aquel cuyos objetos contienen la lógica para manejar sus propios datos. Si
      tus entidades son meros contenedores de datos (simples envoltorios de las
      tablas de la base de datos) y tus acciones tienen toda la lógica para
      manipularlos, en ese caso tu código es una perversión del objetivo
      original de la Orientación a Objetos.<br>
      Aparte de las razones espirituales, poner la lógica para crear una <i>Factura</i>
      dentro de <i>Pedido</i> es un enfoque pragmático, porque de esta forma
      podemos usar esta lógica desde otras acciones, proceso masivos, servicios
      web, etc.<br>
      Veamos el código del método <i>crearFactura()</i> de la clase <i>Pedido</i>,
      no olvides añadir los imports indicados:
      <pre><code class="java">public class Pedido extends DocumentoComercial {

    ...
	
    public void crearFactura() throws Exception { // throws Exception para tener
                                              // un código más simple, de momento
        Factura factura = new Factura(); // Instancia una factura
        BeanUtils.copyProperties(factura, this); // y copia el estado del pedido actual
        factura.setOid(null); // Para que JPA sepa que esta entidad todavía no existe
        factura.setFecha(LocalDate.now()); // La fecha para la nueva factura es hoy
        factura.setDetalles(new ArrayList&lt;&gt;(getDetalles())); // Clona la colección detalles
        XPersistence.getManager().persist(factura);
        this.factura = factura; // Siempre después de persist()
    }
}
</code></pre> La lógica consiste en crear un nuevo objeto <i>Factura</i>,
      copiar los datos desde el <i>Pedido</i> actual a él y asignar la entidad
      resultante a la referencia <i>factura</i> del <i>Pedido</i> actual.<br>
      Hay tres sutiles detalles aquí. Primero, has de escribir <i>factura.setOid(null)</i>,
      si no la nueva <i>Factura</i> tendría la misma identidad que el <i>Pedido</i>
      original, además a JPA no le gusta persistir los objetos con el id
      autogenerado rellenado de antemano. Segundo, has de asignar la nueva <i>
        Factura</i> al actual Pedido (<i>this.factura = factura</i>) después de
      llamar a <i>persist(factura)</i>, si no obtendrás un error de JPA (algo
      así como “object references an unsaved transient instance”). Tercero,
      hemos de envolver la colección <i>detalles</i> con un <i>new ArrayList()</i>,
      para que sea una colección nueva aunque con los mismos elementos, porque
      JPA no quiere la misma colección asignada a dos entidades.
      <h3><a name="escribe-menos-codigo-usando-apache-commons-beanutils"></a>Escribe
        menos código usando Apache Commons BeanUtils</h3>
      Observa como hemos usado <i>BeanUtils.copyProperties()</i> para copiar
      todas las propiedades del actual <i>Pedido</i> a la nueva <i>Factura</i>.
      Este método copia todas las propiedades con el mismo nombre de un objeto a
      otro, incluso si los objetos son de clases diferentes. Esta utilidad
      pertenece al proyecto de apache Commons BeanUtils. El jar para esta
      utilidad, <i>commons-beanutils.jar</i>, ya está incluido en tu proyecto.<br>
      El siguiente código muestra como usando BeanUtils escribes menos:
      <pre><code class="java">BeanUtils.copyProperties(factura, this);
// Es lo mismo que
factura.setOid(getOid());
factura.setAnyo(getAnyo());
factura.setNumero(getNumero());
factura.setFecha(getFecha());
factura.setEliminado(isEliminado());
factura.setCliente(getCliente());
factura.setPorcentajeIVA(getPorcentajeIVA());
factura.setIva(getIva());
factura.setImporteTotal(getImporteTotal());
factura.setObservaciones(getObservaciones());
factura.setDetalles(getDetalles());
</code></pre> Sin embargo, la principal ventaja de usar BeanUtils no es ahorrar
      tiempo de tecleo, sino que obtienes un código más resistente a los
      cambios. Porque, si añades, quitas o renombras alguna propiedad de <i>DocumentoComercial</i>
      (el padre de <i>Factura</i> y <i>Pedido</i>), si estás copiando las
      propiedades a mano tienes que cambiar el código, mientras que si estás
      usando <i> BeanUtils.copyProperties()</i> el código funcionará siempre
      bien, sin tener que cambiarlo.
      <h3><a name="excepciones-de-aplicacion"></a>Excepciones de aplicación</h3>
      Recuerda la frase: “La excepción que confirma la regla”. Las reglas, la
      vida y el software están llenos de excepciones. Y nuestro método <i>
        crearFactura()</i> no es una excepción. Hemos escrito código que
      funciona en los casos más comunes. Pero, ¿qué ocurre si el pedido no está
      listo para ser facturado o si hay algún problema para acceder a la base de
      datos? Obviamente, en este caso necesitamos tomar caminos diferentes.<br>
      Es decir, el simple <i>throws Exception</i> que hemos escrito para el
      método <i> crearFactura()</i> no es suficiente para un comportamiento
      refinado. Deberiamos crear nuestra propia excepción, hagámoslo:
      <pre><code class="java">package com.tuempresa.facturacion.modelo; // En el paquete 'modelo'

import org.openxava.util.*;

public class CrearFacturaException extends Exception { // No RuntimeException

    public CrearFacturaException(String mensaje) {
        // El XavaResources es para traducir el mensaje desde el id en i18n
        super(XavaResources.getString(mensaje)); 
    }
	
}
</code></pre>Ahora podemos usar nuestra <i>CrearFacturaException</i> en lugar
      de <i>Exception</i> en el método <i>crearFactura()</i> de <i>Pedido</i>:
      <pre><code class="java">public void crearFactura()
    throws CrearFacturaException // Una excepción de aplicación (1)
{
    if (this.factura != null) { // Si ya tiene una factura no podemos crearla
        throw new CrearFacturaException( 
            "pedido_ya_tiene_factura"); // Admite un id de 18n como argumento
    }
    if (!isEntregado()) { // Si el pedido no está entregado no podemos crear la factura
        throw new CrearFacturaException("pedido_no_entregado");
    }
    try {
        Factura factura = new Factura(); 
        BeanUtils.copyProperties(factura, this); 
        factura.setOid(null); 
        factura.setFecha(LocalDate.now()); 
        factura.setDetalles(new ArrayList&lt;&gt;(getDetalles())); 
        XPersistence.getManager().persist(factura);
        this.factura = factura; 
    }
    catch (Exception ex) { // Cualquier excepción inesperada (2)
        throw new SystemException( // Se lanza una excepción runtime (3)
            "imposible_crear_factura", ex);
    }
}
</code></pre> Ahora declaramos explícitamente las excepciones de aplicación que
      este método lanza (1). Una excepción de aplicación es una excepción
      chequeada que indica un comportamiento especial pero esperado del método.
      Una excepción de aplicación está relacionada con la lógica de negocio del
      método. Puedes crear una excepción de aplicación para cada posible caso.
      Por ejemplo, podrías crear una <i>PedidoYaTieneFacturaException</i> y una
      <i>PedidoNoEntregadoException</i>. Esto te permitiría tratar cada caso de
      forma diferente desde el código que usa el método. Aunque, esto no es
      necesario en nuestro caso, por tanto nosotros simplemente usamos nuestra <i>CrearFacturaException</i>,
      una excepción de aplicación genérica para este método.<br>
      También hemos de enfrentarnos a problemas inesperados (2). Los problemas
      inesperados incluyen errores del sistema (acceso a base de datos, la red o
      problemas de hardware) o errores de programación (<i>NullPointerException,
        IndexOutOfBoundsException,</i> etc). Cuando nos encontramos con
      cualquier problema inesperado lanzamos una <i>RuntimeException</i> (3).
      En este caso hemos lanzado una <i>SystemException</i>, una <i>RuntimeException</i>
      incluida en OpenXava por comodidad, pero puedes lanzar la <i>RuntimeException</i>
      que quieras.<br>
      No necesitas modificar el código de la acción. Si tu acción no atrapa las
      excepciones, OpenXava lo hace automáticamente. Muestra los mensajes de las
      excepciones de aplicación al usuario; y para las excepciones runtime,
      muestra un mensaje de error genérico y aborta la transacción.<br>
      Para rematar, añadimos el mensaje para la excepción en los archivos <i>i18n</i>.
      Edita el archivo <i>MensajesFacturacion_es.properties</i> de la carpeta <i>Facturacion/i18n</i>
      añadiendo las siguientes entradas:
      <pre><code class="properties">pedido_ya_tiene_factura=El pedido ya tiene una factura
pedido_no_entregado=El pedido todavía no está entregado
imposible_crear_factura=Imposible crear factura
</code></pre> Hay cierto debate en la comunidad de desarrolladores sobre la
      manera correcta de usar las excepciones en Java. El enfoque usado en esta
      sección es la forma clásica de trabajar con excepciones en el mundo Java
      empresarial.
      <h3><a name="validar-desde-la-accion"></a>Validar desde la acción</h3>
      Usualmente el mejor lugar para las validaciones es el modelo, es decir,
      las entidades. Sin embargo, a veces es necesario poner lógica de
      validación en las acciones. Por ejemplo, si quieres preguntar por el
      estado actual de la interfaz gráfica has de hacer la validación en la
      acción.<br>
      En nuestro caso si el usuario pulsa en CREAR FACTURA cuando está creando
      un nuevo pedido que todavía no ha grabado, fallará. Falla porque es
      imposible crear una factura desde un pedido inexistente. El usuario ha de
      grabar el pedido primero.<br>
      Modificamos el método <i>execute()</i> de <i>CrearFacturaDesdePedido</i>
      para validar que la factura visualizada actualmente esté grabada:
      <pre><code class="java">public void execute() throws Exception {
    // Añade la siguiente condición
    if (getView().getValue("oid") == null) { 
        // Si el oid es nulo el pedido actual no se ha grabado todavía (1)
        addError("imposible_crear_factura_pedido_no_existe");
        return;
    }
    
    ...
    
}
</code></pre> La validación consiste en verificar que el <i>oid</i> es nulo
      (1), en cuyo caso el usuario está introduciendo un pedido nuevo, pero
      todavía no lo ha grabado. En este caso se muestra un mensaje y se aborta
      la creación de la factura. <br>
      Aquí también tenemos un mensaje para añadir al archivo i18n. Edita el
      archivo <i>MensajesFacturacion_es.properties</i> de la carpeta <i>Facturacion/i18n</i>
      añadiendo la siguiente entrada:
      <pre><code class="properties">imposible_crear_factura_pedido_no_existe=Imposible crea factura: El pedido no existe todavía
</code></pre> Las validaciones le dicen al usuario que ha hecho algo mal. Esto
      es necesario, por supuesto, pero es mejor aún crear una aplicación que
      ayude al usuario a evitar hacer las cosas mal. Veamos una forma de hacerlo
      en la siguiente sección.
      <h3><a name="evento-onchange-para-ocultar-mostrar-una-accion-por-codigo"></a>Evento
        OnChange para ocultar/mostrar una acción por código</h3>
      Nuestro actual código es suficientemente robusto como para prevenir que
      equivocaciones del usuario estropeen los datos. Vamos a ir un paso más
      allá, impidiendo que el usuario se equivoque. Ocultaremos la acción para
      crear una nueva factura cuando el pedido no esté listo para ello.<br>
      OpenXava permite ocultar y mostrar acciones automáticamente. También
      permite ejecutar una acción cuando cierta propiedad sea cambiada por el
      usuario en la interfaz de usuario. Con estos dos ingredientes podemos
      mostrar el botón sólo cuando la acción esté lista para ser usada.<br>
      Recuerda que una factura puede ser generada desde un pedido si el pedido
      ha sido entregado y no tiene factura todavía. Por tanto, tenemos que
      vigilar los cambios en la referencia <i>factura</i> y la propiedad <i>entregado</i>
      de la entidad <i>Pedido</i>. Lo primero será crear la acción que oculta o
      muestra la acción para crear una factura desde un pedido, <i>MostrarOcultarCrearFactura</i>,
      con este código:
      <pre><code class="java">package com.tuempresa.facturacion.acciones; // En el paquete 'acciones'

import org.openxava.actions.*; // Necesario para usar OnChangePropertyAction,

public class MostrarOcultarCrearFactura
    extends OnChangePropertyBaseAction { // Necesario para las acciones @OnChange (1)

    public void execute() throws Exception {
        if (estaPedidoCreado() &amp;&amp; estaEntregado() &amp;&amp; !tieneFactura()) { // (2)
            addActions("Pedido.crearFactura");
        }
        else {
            removeActions("Pedido.crearFactura");
        }
    }
	
    private boolean estaPedidoCreado() {
        return getView().getValue("oid") != null; // Leemos el valor de la vista
    }
	
    private boolean estaEntregado() {
        Boolean entregado = (Boolean)
            getView().getValue("entregado"); // Leemos el valor de la vista
        return entregado == null?false:entregado;
    }

    private boolean tieneFactura() {
        return getView().getValue("factura.oid") != null; // Leemos el valor de la vista
    } 	
}
</code></pre>Después anotamos <i>factura</i> y <i>entregado</i> en <i>Pedido</i>
      con <i>@OnChange</i> para que cuando el usuario cambie el valor de <i>entregado</i>
      o <i>factura</i> en la pantalla, la acción <i>MostrarOcultarCrearFactura</i>
      se ejecute:
      <pre><code class="java">public class Pedido extends DocumentoComercial {

    ...
    @OnChange(MostrarOcultarCrearFactura.class) // Añade esto
    Factura factura;

    ...
    @OnChange(MostrarOcultarCrearFactura.class) // Añade esto
    boolean entregado;

    ...
}
</code></pre><i>MostrarOcultarCrearFactura</i> es una acción convencional con un
      método <i>execute()</i>, aunque extiende de<i> OnChangePropertyBaseAction</i>
      (1). Todas las acciones anotadas con <i>@OnChange</i> tienen que
      implementar <i>IOnChangePropertyAction</i>, aunque es más fácil extender
      de <i>OnChangePropertyBaseAction</i> la cual lo implementa. Desde esta
      acción puedes usar <i>getNewValue()</i> y <i>getChangedProperty()</i>,
      aunque en este caso concreto no los necesitamos.<br>
      El método <i>execute()</i> pregunta si el pedido visualizado está
      grabado, entregado y todavía no tiene una factura (2), en cuyo caso
      muestra la acción con <i>addActions("Pedido.crearFactura")</i>, en caso
      contrario oculta la acción con <i>removeActions("Pedido.crearFactura")</i>.
      Así, ocultamos o mostramos la acción <i>Pedido.crearFactura</i>,
      mostrándola solo cuando proceda. Los métodos <i>add/removeActions()</i>
      permiten especificar varias acciones a mostrar u ocultar separadas por
      comas.<br>
      Ahora cuando marcas o desmarcas la casilla <i>entregado</i> o escoges una
      factura, el botón para la acción se muestra u oculta. También, cuando el
      usuario pulsa en <i>Nuevo</i> para crear un nuevo pedido el botón para
      crear la factura se oculta. Sin embargo, al editar un pedido ya existente,
      el botón estará siempre presente, aunque el pedido no cumpla los
      requisitos. Esto es porque cuando un objeto se busca y visualiza las
      acciones <i>@OnChange</i> no se ejecutan por defecto. Podemos cambiar
      esto con una pequeña modificación en <i> BuscarExcluyendoEliminados</i>:
      <pre><code class="java">public class BuscarExcluyendoEliminados
    // extends SearchByViewKeyAction {
    extends SearchExecutingOnChangeAction { // Usa ésta como clase base
</code></pre> La acción de búsqueda por defecto, es decir, <i>SearchByViewKeyAction</i>
      no ejecuta las acciones <i>@OnChange</i> por defecto, por tanto cambiamos
      nuestra acción de buscar para que extienda de <i>SearchExecutingOnChangeAction</i>.
      <i> SearchExecutingOnChangeAction</i> se comporta exactamente igual que <i>SearchByViewKeyAction</i>
      pero ejecutando los eventos <i>OnChange</i>. De esta forma cuando el
      usuario escoge un pedido la acción <i>MostrarOcultarCrearFactura</i> se
      ejecuta.<br>
      Nos queda un pequeño detalle para que todo esto sea perfecto: cuando el
      usuario pulsa en CREAR FACTURA después de que la factura se haya creado el
      botón se tiene que ocultar. El usuario no puede crear la factura otra vez.
      Podemos implementar esta funcionalidad con un ligero refinamiento de <i>CrearFacturaDesdePedido</i>,
      así:
      <pre><code class="java">public void execute() throws Exception {

    ...

    // Todo ha ido bien, por tanto ocultamos la acción
    removeActions("Pedido.crearFactura"); 
}
</code></pre> Como puedes ver simplemente añadimos <i>removeActions("Pedido.crearFactura")</i>
      al final del método <i>execute()</i>.<br>
      Mostrar y ocultar acciones no es un sustituto para la validación en el
      modelo. Las validaciones siguen siendo necesarias porque las entidades
      pueden ser usadas desde cualquier otra parte de la aplicación, no solo de
      los módulos de mantenimiento. Sin embargo, el truco de ocultar y mostrar
      acciones mejora la experiencia del usuario.<br>
      <h2><a name="logica-de-negocio-desde-el-modo-lista"></a>Lógica de negocio
        desde el modo lista</h2>
      En la lección 7 aprendiste como crear acciones de lista. Las acciones de
      lista son una herramienta utilísima para dar al usuario la posibilidad de
      aplicar lógica a varios objetos a la vez. En nuestro caso, podemos añadir
      una acción en el modo lista para crear una nueva factura automáticamente a
      partir de varios pedidos seleccionados en la lista, de esta manera:<br>
      <img src="files/business-logic-behavior_es020.png" alt="business-logic-behavior_es020.png"
        title="business-logic-behavior_es020.png"><br>
      Aquí se muestra como esta acción de lista coge los pedidos seleccionados y
      crea una factura a partir de ellos. Simplemente copia los datos del pedido
      en la nueva factura, añadiendo las línea de detalle de todos los pedidos
      en una única factura. También se muestra un mensaje. Veamos como codificar
      este comportamiento.
      <h3><a name="accion-de-lista-con-logica-propia"></a>Acción de lista con
        lógica propia</h3>
      Como ya sabes, el primer paso para tener una acción propia en tu módulo es
      añadirla a un controlador. Por tanto, editemos <i>controladores.xml</i>
      añadiendo una nueva acción al controlador <i>Pedido</i>:
      <pre><code class="xml">&lt;controlador nombre="Pedido"&gt;

    ...
    
    &lt;!-- La nueva acción --&gt;
    &lt;accion nombre="crearFacturaDesdePedidosSeleccionados"
        modo="list"
        clase="com.tuempresa.facturacion.acciones.CrearFacturaDesdePedidosSeleccionados"/&gt;
	&lt;!-- modo="list": Sólo se muestra en modo lista --&gt;

&lt;/controlador&gt;
</code></pre> Solo con esto ya tienes una nueva acción disponible para <i>Pedido</i>
      en modo lista.<br>
      Ahora hemos de escribir el código Java para la acción:
      <pre><code class="java">package com.tuempresa.facturacion.acciones;

import java.util.*;
import javax.ejb.*;
import org.openxava.actions.*;
import org.openxava.model.*;
import com.tuempresa.facturacion.modelo.*;

public class CrearFacturaDesdePedidosSeleccionados
    extends TabBaseAction { // Tipico de acciones de lista. Permite usar getTab() (1)

    public void execute() throws Exception {
        Collection&lt;Pedido&gt; pedidos = getPedidosSeleccionados(); // (2)
        Factura factura = Factura.crearDesdePedidos(pedidos); // (3)
        addMessage("factura_creada_desde_pedidos", factura, pedidos); // (4)
    }

    private Collection&lt;Pedido&gt; getPedidosSeleccionados() // (5)
        throws FinderException
    {
        Collection&lt;Pedido&gt; pedidos = new ArrayList&lt;&gt;();
        for (Map key: getTab().getSelectedKeys()) { // (6)
            Pedido pedido = (Pedido) MapFacade.findEntity("Pedido", key); // (7)
            pedidos.add(pedido);
        }
        return pedidos;
    }
}
</code></pre> Realmente sencillo. Obtenemos la lista de los pedidos marcados en
      la lista (2), llamamos al método estático <i>crearDesdePedidos()</i> (3)
      de <i>Factura</i> y mostramos un mensaje (4). En este caso también
      ponemos la lógica real en la clase del modelo, no en la acción. Dado que
      la lógica aplica a varios pedidos y crea una nueva factura, el lugar
      natural para ponerlo es en un método estático de la clase <i>Factura</i>.<br>
      El método <i>getPedidosSeleccionados()</i> (5) devuelve una colección con
      las entidades <i>Pedido</i> marcadas por el usuario en la lista. Para
      hacerlo, el método usa <i>getTab()</i> (6), disponible en <i>TabBaseAction</i>
      (1), que devuelve un objeto <i>org.openxava.tab.Tab</i>. El objeto <i>Tab</i>
      te permite manejar los datos tabulares de la lista. En este caso usamos <i>getSelectedKeys()</i>
      (6) que devuelve una colección con las claves de las filas seleccionadas.
      Dado que esas claves están en formato <i>Map</i> usamos <i>MapFacade.findEntity()</i>
      (7) para convertirlas en entidades <i>Pedido</i>.<br>
      Acuérdate de añadir el texto del mensaje al fichero <i>
        MensajesFacturacion_es.properties</i> en la carpeta <i>i18n</i>:
      <pre><code class="properties">factura_creada_desde_pedidos=Factura {0} creada a partir de los pedidos: {1}
</code></pre> Eso es todo para la acción. Veamos la pieza que falta, el método <i>
        crearDesdePedidos()</i> de la entidad <i>Factura</i>.
      <h3><a name="logica-de-negocio-en-el-modelo-sobre-varias-entidades"></a>Lógica
        de negocio en el modelo sobre varias entidades</h3>
      La lógica de negocio para crear una nueva <i>Factura</i> a partir de
      varias entidades <i>Pedido</i> está en la capa del modelo, es decir, en
      las entidades, no en la acción. No podemos poner el método en la clase <i>Pedido</i>,
      porque el proceso se hace a partir de varios pedidos, no de uno. No
      podemos usar un método de instancia en <i>Factura</i> porque todavía no
      existe el objeto <i>Factura</i>, de hecho lo que queremos es crearlo. Por
      lo tanto, vamos a crear un método de factoría estático en la clase <i>Factura</i>
      para crear una nueva <i>Factura</i> a partir de varios pedidos. Puedes
      ver este método aquí:
      <pre><code class="java">public class Factura extends DocumentoComercial {

    ...
	
    public static Factura crearDesdePedidos(Collection&lt;Pedido&gt; pedidos)
        throws CrearFacturaException
    {
        Factura factura = null;
        for (Pedido pedido: pedidos) {
            if (factura == null) { // El primero pedido
                pedido.crearFactura(); // Reutilizamos la lógica para crear una
                                       // factura desde un pedido
                factura = pedido.getFactura(); // y usamos la factura creada
            }
            else { // Para el resto de los pedidos la factura ya está creada
                pedido.setFactura(factura); // Asigna la factura
                factura.getDetalles().addAll(pedido.getDetalles()); // Copia las líneas
                factura.setIva(
                    factura.getIva().add(pedido.getIva())); // Acumala el IVA
                factura.setImporteTotal( // y el importe total
                    factura.getImporteTotal().add(pedido.getImporteTotal()));
            } 
        } 
        if (factura == null) { // Si no hay pedidos
            throw new CrearFacturaException("pedidos_no_especificados");
        }
        return factura;
    }
}
</code></pre> Usamos el primer <i>Pedido</i> para crear una nueva <i>Factura</i>
      usando el método ya existente <i>crearFactura()</i> de <i>Pedido</i>.
      Entonces copiamos las líneas de los pedidos restantes a la nueva <i>Factura</i>
      y acumulamos en ella el <i>iva</i> e <i>importeTotal</i> de los pedidos.
      Además, asignamos la nueva <i>Factura</i> como la factura de los pedidos
      de la colección.<br>
      Si <i>factura</i> es nulo al final del proceso, es porque la colección <i>pedidos</i>
      está vacía. En este caso lanzamos una <i>CrearFacturaException</i>, ya
      que la acción no atrapa las excepciones, OpenXava muestra el mensaje de la
      excepción al usuario. Esto está bien. Si el usuario no marca los pedido y
      pulsa en el botón para crear la factura, le aparecerá ese mensaje de
      error.<br>
      Acuérdate de añadir los textos para los mensajes en el archivo <i>MensajesFacturacion_es.properties</i>
      de la carpeta <i>i18n</i>:
      <pre><code class="properties">pedidos_no_especificados=Pedidos no especificados
</code></pre> Este no es el único error con el que el usuario puede encontrarse.
      Todas las validaciones que hemos escrito para <i>Factura</i> y <i>Pedido</i>
      hasta ahora se aplican automáticamente, por lo tanto el usuario ha de
      escoger pedidos ya entregados y sin factura. La validación del modelo
      impide que el usuario cree una factura desde pedidos no apropiados.
      <h2><a name="mostrar-un-dialogo"></a>Mostrar un diálogo</h2>
      Después de crear una factura a partir de varios pedidos, sería práctico
      para el usuario ver y posiblemente editar la nueva factura. Una forma de
      conseguir esto es sacando un diálogo que permite ver y editar la recién
      creada factura. De esta forma:<br>
      <img src="files/business-logic-behavior_es030.png" alt="business-logic-behavior_es030.png"
        title="business-logic-behavior_es030.png"><br>
      Veamos como implementar este comportamiento.
      <h3><a name="usar-showdialog"></a>Usar showDialog()</h3>
      El primer paso es modificar <i>CrearFacturaDesdePedidosSeleccionados</i>
      para mostrar un diálogo después de crear la factura, con sólo añadir unas
      poca línea al final de <i>execute()</i> es suficiente:<br>
      <pre><code class="java">public void execute() throws Exception {
    Collection&lt;Pedido&gt; pedidos = getPedidosSeleccionados(); 
    Factura factura = Factura.crearDesdePedidos(pedidos); 
    addMessage("factura_creada_desde_pedidos", factura, pedidos);

    // Añade las siguientes líneas para mostrar el diálogo
    showDialog(); // (1)
    // A partir de ahora getView() es el diálogo
    getView().setModel(factura); // Visualiza la factura en el diálogo (2)
    getView().setKeyEditable(false); // Para indicar que el objeto ya existe (3)
    setControllers("EdicionFactura"); // Las acciones del diálogo (4)
}
</code></pre>Llamamos a <i>showDialog()</i> (1), lo que saca un diálogo y a
      partir de ese momento cuando usamos <i>getView()</i> referencia a la
      vista del diálogo no a la vista principal del módulo. Después de <i>showDialog()</i>
      el diálogo está en blanco, hasta que asignamos nuestra factura a la vista
      con <i>getView().setModel(factura)</i> (2), ahora la factura se visualiza
      en el diálogo. La siguiente línea, <i>getView().setKeyEditable(false)</i>
      (3), es para indicar que la factura ya está grabada y así más adelante la
      acción de grabar correspondiente sepa como comportarse. Finalmente, usamos
      <i>setControllers("EdicionFactura")</i> para definir el controlador con
      las acciones a presentar en el diálogo, es decir los botones de abajo del
      diálogo. Fíjate como <i>setControllers()</i> es una alternativa a <i>addActions()</i>.<br>
      Obviamente, esto no funcionará hasta que tengamos el controlador <i>EdicionFactura</i>
      definido. Haremos esto en la siguiente sección.
      <h3><a name="definir-las-acciones-del-dialogo"></a>Definir las acciones
        del diálogo</h3>
      El diálogo permite al usuario cambiar la factura y grabar los cambios o
      simplemente cerrar la factura después de examinarla. Estas acciones se
      definen en el controlador <i>EdicionFactura</i> en <i>controladores.xml</i>:
      <pre><code class="xml">&lt;controlador nombre="EdicionFactura"&gt;

    &lt;accion nombre="grabar"
        clase="com.tuempresa.facturacion.acciones.GrabarFactura"
        atajo-de-teclado="Control S"/&gt;
		
    &lt;accion nombre="cerrar"
        clase="org.openxava.actions.CancelAction"/&gt;
		
&lt;/controlador&gt;
</code></pre>Las dos acciones de este controlador representan los dos botones,
      GRABAR y CERRAR que viste en la imagen anterior.</div>
    <div class="wiki" style="display: block;">
      <h3><a name="cerrar-el-dialogo"></a>Cerrar el diálogo</h3>
      <i>GrabarFactura</i> contiene sólo una extensión menor de la acción
      estándar <i>SaveAction</i> de OpenXava:
      <pre><code class="java">package com.tuempresa.facturacion.acciones;

import org.openxava.actions.*;

public class GrabarFactura
    extends SaveAction { // Acción estándar de OpenXava para 
                         // grabar el contenido de la vista	             
    public void execute() throws Exception {
        super.execute(); // La lógica estándar de grabación (1)
        closeDialog(); // (2)
    }
}
</code></pre>La acción extiende <i>SaveAction</i> sobrescribiendo el método <i>execute()</i>
      para simplemente llamar a la lógica estándar, con <i>super.execute()</i>
      (1), y después cerrar el diálogo con <i>closeDialog()</i> (2). De esta
      forma, cuando el usuario pulsa en GRABAR, los datos de la factura se
      graban y el diálogo se cierrar volviendo a la lista de pedidos, listo para
      continuar creando facturas a partir de pedidos.<br>
      Para el botón CERRAR usamos <i>CancelAction</i>, una acción incluida en
      OpenXava que simplemente cierra el diálogo.
      <h3><a name="vista-plana-en-lugar-de-dialogo"></a>Vista plana en lugar de
        diálogo</h3>
      A veces en lugar de sacar un diálogo encima:<br>
      <img src="files/business-logic-behavior_es040.png" alt="business-logic-behavior_es040.png"
        title="business-logic-behavior_es040.png"><br>
      Podriamos preferir reemplazar la vista actual por la nueva, así: <br>
      <img src="files/business-logic-behavior_es050.png" alt="business-logic-behavior_es050.png"
        title="business-logic-behavior_es050.png"><br>
      Esto puede ser útil cuando la cantidad de información a mostrar es muy
      grande y en un diálogo queda mal. Usar una vista plana en vez de un
      diálogo es tan fácil como cambiar esta línea de tu <i>CrearFacturaDesdePedidosSeleccionados</i>:
      <pre><code class="java">showDialog();
</code></pre>Por esta otra:
      <pre><code class="java">showNewView();
</code></pre> No hace falta nada más. Bueno, quizás cambiar el nombre de la
      acción "cerrar" por "volver" en el controlador <i>EdicionFactura</i> en <i>controllers.xml</i>.<br>
      <br>
      El trabajo está casi terminado. Puedes probar el módulo <i>Pedido</i>:
      escoge varios pedidos y pulsa en el botón CREAR FACTURA DESDE PEDIDOS
      SELECCIONADOS. Entonces verás la factura creada en un diálogo.
      <h2><a name="pruebas-junit"></a>Pruebas JUnit</h2>
      El código que hemos escrito en esta lección no estará completo hasta que
      no escribamos las pruebas. Recuerda, todo código nuevo tiene que tener su
      correspondiente código de prueba. Escribamos pues las pruebas para estas
      dos nuevas acciones.
      <h3><a name="probar-la-accion-de-modo-detalle"></a>Probar la acción de
        modo detalle</h3>
      Primero probaremos la acción <i>Pedido.crearFactura</i>, la acción para
      crear una factura a partir del modo detalle del pedido visualizado.
      Recordamos aquí como funciona este proceso:<br>
      <img src="files/business-logic-behavior_es010.png" alt="business-logic-behavior_es010.png"
        title="business-logic-behavior_es010.png"><br>
      Ahora vamos a escribir la prueba para verificar que funciona justo de esta
      forma. Añade el método <i>testCrearFacturaDesdePedido()</i> a la clase <i>PruebaPedido</i>:
      <pre><code class="java">public void testCrearFacturaDesdePedido() throws Exception {
    login("admin", "admin");
    
    // Buscar el pedido
    buscarPedidoSusceptibleDeSerFacturado(); // Busca un pedido  
    assertValue("entregado", "true"); // El pedido está entregado
    int cantidadDetallesPedido = getCollectionRowCount("detalles"); // Toma nota de
                                      // la cantidad de detalles en el pedido
    execute("Sections.change", "activeSection=1"); // La sección de la factura
    assertValue("factura.anyo", ""); // Todavía no hay factura
    assertValue("factura.numero", ""); // en este pedido

    // Crear la factura
    execute("Pedido.crearFactura"); // Ejecuta la acción que estamos probando (1)
    String anyoFactura = getValue("factura.anyo"); // Verifica que ahora
    assertTrue("Año de fectura ha de tener valor", // hay una factura
        !Is.emptyString(anyoFactura)); // en la pestaña de factura (2)
    String numeroFactura = getValue("factura.numero");
    assertTrue("Número de factura ha de tener valor",
        !Is.emptyString(numeroFactura)); // Is.emptyString() es de org.openxava.util
    assertMessage("Factura " + anyoFactura + "/" + numeroFactura +
        " creada a partir del pedido actual"); // El mensaje de confirmación (3)
    assertCollectionRowCount("factura.detalles", // La factura recién creada
        cantidadDetallesPedido); // tiene el mismo número de detalles que el pedido (4)

    // Restaurar el pedido para poder ejecutar la prueba la siguiente vez
    setValue("factura.anyo", "");
    assertValue("factura.numero", "");
    assertCollectionRowCount("factura.detalles", 0);
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> Esta prueba pulsa el botón para ejecutar la acción <i>Pedido.crearFactura</i>
      (1), entonces verifica que una factura ha sido creada, está siendo
      visualizada en la pestaña de factura (2) y tiene la misma cantidad de
      líneas de detalle que el pedido actual (4). También comprueba que se ha
      generado el mensaje de confirmación correcto (3).<br>
      Para ejecutarla es necesario escoger un pedido susceptible de ser
      facturado. Esto se hace en el método <i>buscarPedidoSusceptibleDeSerFacturado()</i>
      que vamos a examinar en la siguiente sección.
      <h3><a name="buscar-una-entidad-para-la-prueba-usando-el-modo-lista-y-jpa"></a>Buscar
        una entidad para la prueba usando el modo lista y JPA</h3>
      Para seleccionar un pedido adecuado para nuestra prueba usaremos JPA para
      determinar el año y número de ese pedido, y entonces usaremos el modo
      lista para seleccionar este pedido y editarlo en modo detalle. Aquí tienes
      los métodos para implementar esto:
      <pre><code class="java">private void buscarPedidoSusceptibleDeSerFacturado() throws Exception {
    buscarPedidoUsandoLista("entregado = true and factura = null"); // Envía la condición,
}                            // en este caso buscamos por un pedido entregado y sin factura

private void buscarPedidoUsandoLista(String condicion) throws Exception {
    Pedido pedido = buscarPedido(condicion); // Busca el pedido con la condición usando JPA
    String anyo = String.valueOf(pedido.getAnyo());
    String numero = String.valueOf(pedido.getNumero());
    setConditionValues(new String [] { anyo, numero }); // Llena el año y el número
    execute("List.filter"); // y pulsa en el botón filtrar en la lista
    assertListRowCount(1); // Sólo una fila, correspondiente al pedido buscado
    execute("List.viewDetail", "row=0"); // Para ver el pedido en modo detalle
    assertValue("anyo", anyo); // Verifica que el pedido editado
    assertValue("numero", numero); // es el deseado
}

private Pedido buscarPedido(String condicion) {
    Query query = XPersistence.getManager().createQuery( // Crea una consulta JPA
        "from Pedido p where p.eliminado = false and " // a partir de la condición. Fíjate en
        + condicion); // deleted = false para excluir los pedidos borrados
    List&lt;Pedido&gt; pedidos = query.getResultList();
    if (pedidos.isEmpty()) { // Es necesario al menos un pedido con la condición
        fail("Para ejecutar esta prueba necesitas tener al menos un pedido con " + condicion);
    }
    return pedidos.get(0);
}
</code></pre>Además necesitas añadir los siguiente imports a <i>PruebaPedido</i>
      para que te compile:
      <pre><code class="java">import java.util.*;
import javax.persistence.*;
import org.openxava.jpa.*;
import org.openxava.util.*;
import com.tuempresa.facturacion.modelo.*;
</code></pre>El método <i>buscarPedidoSusceptibleDeSerFacturado()</i>
      simplemente llama a un método más genérico, <i>buscarPedidoUsandoLista()</i>,
      para buscar una entidad por una condición. El método <i>buscarPedidoUsandoLista()</i>
      obtiene la entidad <i>Pedido</i> mediante <i>buscarPedido()</i>,
      entonces usa la lista para filtrar por el año y el número a partir de este
      <i>Pedido</i>, yendo a modo detalle al finalizar. El método <i>buscarPedido()</i>
      usa JPA simple y llano para buscar.<br>
      Como puedes ver, combinar el modo lista con JPA es una herramienta muy
      útil en ciertas circunstancias. Usaremos los métodos <i>buscarPedidoUsandoLista()</i>
      y <i>buscarPedido()</i> en las siguientes pruebas.
      <h3><a name="probar-que-la-accion-se-oculta-cuando-no-aplica"></a>Probar
        que la acción se oculta cuando no aplica</h3>
      Recuerda que refinamos el módulo <i>Pedido</i> para que mostrara la
      acción para crear la factura sólo cuando el pedido visualizado fuese
      susceptible de ser facturado. Éste es el método de prueba para este caso,
      añádelo a <i>PruebaPedido</i>:
      <pre><code class="java">public void testOcultaCrearFacturaDesdePedidoCuandoNoAplicable() throws Exception {
    login("admin", "admin");
    buscarPedidoUsandoLista(
        "entregado = true and factura &lt;&gt; null"); // Si el pedido ya tiene factura
    assertNoAction("Pedido.crearFactura"); // no se puede facturar otra vez
    execute("Mode.list");
    buscarPedidoUsandoLista(
        "entregado = false and factura = null"); // Si el pedido no está entregado
    assertNoAction("Pedido.crearFactura"); // no se puede facturar
    execute("CRUD.new"); // Si el pedido todavía no está grabado
    assertNoAction("Pedido.crearFactura"); // no puede ser facturado
}
</code></pre> Probamos tres casos en los que el botón para crear la factura no
      tiene que estar presente. Fíjate en el uso de <i>assertNoAction()</i>
      para preguntar si el vínculo o botón para una acción está presente en la
      interfaz de usuario. Aquí estamos reutilizando el método <i>buscarPedidoUsandoLista()</i>
      desarrollado en la sección anterior.<br>
      Ya hemos probado que el botón está presente cuando el pedido es adecuado
      en la prueba <i>testCrearFacturaDesdePedido()</i>, porque <i>execute()</i>
      falla si la acción no está en la interfaz de usuario.
      <h3><a name="probar-la-accion-de-modo-lista"></a>Probar la acción de modo
        lista</h3>
      Ahora probaremos <i>Pedido.crearFacturaDesdePedidosSeleccionados</i>, la
      acción que crea una factura desde varios pedidos en modo lista. Recordemos
      su funcionamiento:<br>
      <img src="files/business-logic-behavior_es030.png" alt="business-logic-behavior_es030.png"
        title="business-logic-behavior_es030.png"><br>
      Escribamos una prueba para verificar que esto funciona justo de esta
      forma. Añade el método <i>testCrearFacturaDesdePedidosSeleccionados()</i>
      a la clase <i> PruebaPedido</i>:
      <pre><code class="java">public void testCrearFacturaDesdePedidosSeleccionados() throws Exception {
    login("admin", "admin");
    verificarPedido(2021, 2, 1, "45.98"); // El pedido 2021/2 tiene 1 línea y 45,98 de importe base
    verificarPedido(2021, 4, 2, "98.01"); // El pedido 2021/4 tiene 2 líneas y 98,01 de importe base
	
    execute("List.orderBy", "property=numero"); // Ordena la lista por número
    checkRow( // Marca la fila a partir del número de fila
        getFilaDocumentoEnLista("2021", "2") // Obtiene la fila del año y número del pedido
    );             // por tanto, esta línea marca la línea del pedido 2021/2 en la lista (1)
    checkRow(
        getFilaDocumentoEnLista("2021", "4") // Marca el pedido 2021/4 en la lista (1)
    ); 
    execute("Pedido.crearFacturaDesdePedidosSeleccionados"); // Ejecuta la acción que
                                                             // estamos probando (2)
    String anyoFactura = getValue("anyo"); // Ahora estamos viendo el detalle de
    String numeroFactura = getValue("numero"); // la factura recién creada
    assertMessage("Factura " + anyoFactura + "/" + numeroFactura +
        " creada a partir de los pedidos: [2021/2, 2021/4]"); // El mensaje de confirmación
    assertCollectionRowCount("detalles", 3); // Confirma que el número de líneas de la
                      // factura recién creada es la suma de la de los pedidos fuente (3)
    assertValue("importeTotal", "143,99"); // Confirma que el importe base de la factura
                               // recién creada es la suma de la de los pedidos fuente (4)
    execute("Sections.change", "activeSection=1"); // Cambia a la pestaña de
                                                   // pedidos de la factura
    assertCollectionRowCount("pedidos", 2); // La nueva factura tiene 2 pedidos (5)
    assertValueInCollection("pedidos", 0, 0, "2021"); // y son los correctos
    assertValueInCollection("pedidos", 0, 1, "2");
    assertValueInCollection("pedidos", 1, 0, "2021");
    assertValueInCollection("pedidos", 1, 1, "4");
	
    assertAction("EdicionFactura.grabar"); // Los botones GRABAR (6)
    assertAction("EdicionFactura.cerrar"); // y CERRAR (6)
	
    checkRowCollection("pedidos", 0); // Seleccionamos los 2 pedidos
    checkRowCollection("pedidos", 1);
    execute("Collection.removeSelected", // y los borramos, para ejecutar esta prueba
        "viewObject=xava_view_section1_pedidos"); // otra vez usando los mismo pedidos
    assertNoErrors();
	
    execute("EdicionFactura.cerrar"); // Vuelve a la lista de pedidos (7)
    confirmarDocumentoEstaEnLista("2021", "2"); // Confirma que estamos realmente
    confirmarDocumentoEstaEnLista("2021", "4"); // en la lista de pedidos
}
</code></pre> Esta prueba marca dos pedidos (1) y pulsa en el botón CREAR
      FACTURA DESDE LOS PEDIDOS SELECCIONADOS (2). Entonces verifica que se ha
      creado una nueva factura con el número correcto de líneas (3), importe
      total (4) y lista de pedidos (5). También verifica que las acciones GRABAR
      y CERRAR están disponibles (6) y usa el botón CERRAR para volver a la
      lista de pedidos (7).<br>
      Usamos <i>getFilaDocumentoEnLista()</i> y <i>confirmarDocumentoEstaEnLista()</i>,
      métodos de la clase base <i>PruebaDocumentoComercial</i>, que fueron
      definidos originalmente como privados, por lo tanto tenemos que
      redefinirlos como protegidos para poder utilizarlos desde <i>PruebaPedido</i>.
      Edita <i>PruebaDocumentoComercial</i> y haz los siguientes cambios:
      <pre><code class="java">protected void confirmarDocumentoEstaEnLista(String anyo, String numero) ... // protected en lugar
// private void confirmarDocumentoEstaEnLista(String anyo, String numero) ... // de private

protected int getFilaDocumentoEnLista(String anyo, String numero) ... // protected en lugar
// private int getFilaDocumentoEnLista(String anyo, String numero) ... // de private
</code></pre> El único detalle pendiente es el método <i>verificarPedido()</i>
      que veremos en la siguiente sección.
      <h3><a name="verificar-datos-de-prueba"></a>Verificar datos de prueba</h3>
      En la lección 3 (Pruebas automáticas) aprendiste como confiar en datos
      existentes en la base de datos para tus pruebas. Obviamente, si tu base de
      datos se altera accidentalmente tus pruebas, aunque correctas, no pasarán.
      Por tanto, verificar los valores de la base de datos antes de ejecutar la
      prueba que confía en ellos es una buena práctica. En nuestro ejemplo lo
      hacemos llamando a <i>verificarPedido()</i> al principio. Veamos el
      contenido de <i>verificarPedido()</i>:
      <pre><code class="java">private void verificarPedido(
    int anyo, int numero, int cantidadDetalles, String importeTotal)
{
    Pedido pedido = buscarPedido("anyo = " + anyo + " and numero=" + numero);
    assertEquals("Para ejecutar esta prueba el pedido " +
        pedido + " tiene que tener " + cantidadDetalles + " detalles",
        cantidadDetalles, pedido.getDetalles().size());
    assertTrue("Para ejecutar esta prueba el pedido " +
        pedido + " must have " + importeTotal + " como importe total",
        pedido.getImporteTotal().compareTo(new BigDecimal(importeTotal)) == 0);
    assertTrue("Para ejecutar esta prueba el pedido " + pedido + " tiene que estar entegrado",
        pedido.isEntregado());        
}
</code></pre> Este método busca un pedido y verifica la cantidad de líneas, el
      importe total y si el pedido está entregado. Usar este método tiene la
      ventaja de que si los pedidos necesarios para la prueba no están en la
      base de datos con los valores correctos obtienes un mensaje preciso. Así,
      no derrocharás tu tiempo intentando adivinar que es lo que está mal. Esto
      es especialmente útil si la prueba no la está ejecutando el programador
      original. Por cierto, si te resulta dificil adaptar tus pedidos para que
      se ajusten a esta prueba (número de pedido, importe, número de líneas),
      puedes adaptar los valores en la prueba a tus pedidos actuales.<br>
      <h3><a name="probar-casos-excepcionales"></a>Probar casos excepcionales</h3>
      Dado que la acción para crear la factura se oculta si el pedido no está
      listo para ser facturado, no podemos probar el código para los casos
      excepcionales desde modo detalle. Sin embargo, en modo lista el usuario
      todavía tiene la opción de escoger cualquier pedido para facturar. Por
      tanto, intentaremos crear la factura desde la lista de pedidos para probar
      que los casos excepcionales se comportan correctamente. Añade el siguiente
      código a <i>PruebaPedido</i>:
      <pre><code class="java">public void testExcepcionesCreandoFacturaDesdePedido() throws Exception {
    login("admin", "admin");
    confirmarExcepcionCreandoFacturaDesdePedido( // Confirma que cuando el pedido ya tiene (1)
        "entregado = true and factura &lt;&gt; null", // factura se produce el error correcto
        "Ha sido imposible ejecutar la acción Crear factura desde pedidos seleccionados: " +
            "El pedido ya tiene una factura"
    );
    confirmarExcepcionCreandoFacturaDesdePedido( // Confirma que cuando el pedido no está (2)
        "entregado = false and factura = null", // entregado se produce el error correcto
        "Ha sido imposible ejecutar la acción Crear factura desde pedidos seleccionados: " + 
            "El pedido todavía no está entregado"
    );
}

private void confirmarExcepcionCreandoFacturaDesdePedido(
    String condicion, String mensaje) throws Exception
{
    Pedido pedido = buscarPedido(condicion); // Busca el pedido por la condición (3)
    int fila = getFilaDocumentoEnLista( // y obtiene el número de fila para ese pedido (4)
       String.valueOf(pedido.getAnyo()),
       String.valueOf(pedido.getNumero())
    );
    checkRow(fila); // Marca la fila (5)
    execute("Pedido.crearFacturaDesdePedidosSeleccionados"); // Trata de crear la factura (6)
    assertError(mensaje); // ¿Se ha mostrado el mensaje esperado? (7)
    uncheckRow(fila); // Desmarca la fila, así podemos llamar a este método otra vez
}
</code></pre> La prueba verifica que el mensaje es el correcto cuando tratamos
      de crear una factura a partir de un pedido que ya tiene factura (1), y
      también desde un pedido no entregado todavía (2). Para hacer estas
      verificaciones llama al método <i>confirmarExcepcionCreandoFacturaDesdePedido()</i>.
      Este método busca la entidad <i>Pedido</i> usando la condición (3),
      localiza la fila donde la entidad se está visualizando (4) y la marca (5).
      Después, la prueba ejecuta la acción (6) y verifica que el mensaje
      esperado se muestra (7).
      <h2><a name="resumen"></a>Resumen</h2>
      La sal de tu aplicación son las acciones y los métodos. Gracias a ellos
      puedes convertir una simple aplicación de gestión de datos en una
      herramienta útil. En este caso, por ejemplo, hemos provisto al usuario con
      una forma de crear automáticamente facturas desde pedidos.<br>
      Has aprendido como crear métodos de lógica de negocio tanto estáticos como
      de instancia, y como llamarlos desde acciones de modo detalle y modo
      lista. Por el camino has visto como ocultar y mostrar acciones, usar
      excepciones, validar en las acciones, mostrar diálogos y cómo hacer las
      pruebas automáticas de todo esto.<br>
      Todavía nos quedan muchas cosas interesante por aprender, por ejemplo en
      la siguiente lección vamos a refinar el comportamiento de las referencias
      y colecciones.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-8-business-logic-behavior_es.zip/download"
          rel="nofollow">Descargar código fuente de esta lección</a></strong><br>
      <br>
      <strong>¿Problemas con la lección? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/437013/"
          rel="nofollow">Pregunta en el foro</a></strong> <strong>¿Ha ido bien?
        <a class="wiki_link" href="references-collections_es.html">Ve a la
          lección 12</a></strong> </div>
  </body>
</html>
