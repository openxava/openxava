<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lección 8: Validación avanzada - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" style="display: block;">
      <h1 id="toc0"><a name="Leccion-6-Validacion-avanzada"></a> <span id="breadcrumbs">
          <span id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava
              </a> </span> / <a href="index_es.html">documentación</a> / </span>
        Lección 8: Validación avanzada</h1>
      <strong>Curso</strong>: <a class="wiki_link" href="getting-started_es.html">1.
        Primeros pasos</a> | <a class="wiki_link" href="basic-domain-model1_es.html">2.
        Modelo básico del dominio (1)</a> | <a class="wiki_link" href="basic-domain-model2_es.html">3.
        Modelo básico del dominio (2)</a> | <a class="wiki_link" href="refining-user-interface_es.html">4.
        Refinar la interfaz de usuario</a> | <a class="wiki_link" href="agile-development_es.html">5.
        Desarrollo ágil</a> | <a class="wiki_link" href="inheritance_es.html">6.
        Herencia</a> | <a class="wiki_link" href="basic-business-logic_es.html">7.
        Lógica de negocio básica</a> | <strong>8. Validación avanzada</strong>
      | <a class="wiki_link" href="refining-standard-behavior_es.html">9.
        Refinar el comportamiento predefinido</a> | <a class="wiki_link" href="business-logic-behavior_es.html">10.
        Comportamiento y lógica de negocio</a> | <a class="wiki_link" href="references-collections_es.html">11.
        Referencias y colecciones</a> | <a class="wiki_link" href="philosophy_es.html">A.
        Arquitectura y filosofía</a> | <a class="wiki_link" href="jpa_es.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_es.html">C.
        Anotaciones</a> | <a class="wiki_link" href="testing_es.html">D.
        Pruebas automáticas</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">Tabla de contenidos</h1>
        <div style="margin-left: 1em;"><a href="#Leccion-6-Validacion-avanzada">Lección
            8: Validación avanzada</a></div>
        <div style="margin-left: 2em;"><a href="#Alternativas-de-validacion">Alternativas
            de validación</a></div>
        <div style="margin-left: 3em;"><a href="#Alternativas-de-validacion-Anadir-la-propiedad-entregado-a-Pedido">Añadir
            la propiedad entregado a Pedido</a></div>
        <div style="margin-left: 3em;"><a href="#Alternativas-de-validacion-Validar-con-EntityValidator">Validar
            con @EntityValidator</a></div>
        <div style="margin-left: 3em;"><a href="#Alternativas-de-validacion-Validar-con-metodos-de-retrollamada-JPA">Validar
            con métodos de retrollamada JPA</a></div>
        <div style="margin-left: 3em;"><a href="#Alternativas-de-validacion-Validar-en-el-setter">Validar
            en el setter</a></div>
        <div style="margin-left: 3em;"><a href="#Alternativas-de-validacion-Validar-con-Bean-Validation">Validar
            con Bean Validation</a></div>
        <div style="margin-left: 3em;"><a href="#Alternativas-de-validacion-Validar-al-borrar-con-RemoveValidator">Validar
            al borrar con @RemoveValidator</a></div>
        <div style="margin-left: 3em;"><a href="#Alternativas-de-validacion-Validar-al-borrar-con-un-metodo-de-retrollamada">Validar
            al borrar con un método de retrollamada</a></div>
        <div style="margin-left: 3em;"><a href="#Alternativas-de-validacion-Cual-es-la-mejor-forma-de-validar">¿Cuál
            es la mejor forma de validar?</a></div>
        <div style="margin-left: 2em;"><a href="#Crear-tu-propia-anotacion-de-Bean-Validation">Crear
            tu propia anotación de Bean Validation</a></div>
        <div style="margin-left: 3em;"><a href="#Crear-tu-propia-anotacion-de-Bean-Validation-Usar-un-Bean-Validation-en-tu-entidad">Usar
            un Bean Validation en tu entidad</a></div>
        <div style="margin-left: 3em;"><a href="#Crear-tu-propia-anotacion-de-Bean-Validation-Definir-tu-propia-anotacion-ISBN">Definir
            tu propia anotación ISBN</a></div>
        <div style="margin-left: 3em;"><a href="#Crear-tu-propia-anotacion-de-Bean-Validation-Usa-Apache-Commons-Validator-para-implementar-la-logica">Usa
            Apache Commons Validator para implementar la lógica</a></div>
        <div style="margin-left: 3em;"><a href="#Crear-tu-propia-anotacion-de-Bean-Validation-Llamar-a-un-servicio-web-REST-para-validar-el-ISBN">Llamar
            a un servicio web REST para validar el ISBN</a></div>
        <div style="margin-left: 3em;"><a href="#Crear-tu-propia-anotacion-de-Bean-Validation-Anadir-atributos-a-tu-anotacion">Añadir
            atributos a tu anotación</a></div>
        <div style="margin-left: 2em;"><a href="#Resumen">Resumen</a></div>
      </div>
      De momento solo hemos hecho validaciones básicas usando la anotación <i>@Required</i>
      de OpenXava. Sin embargo, muchas veces es necesario escribir nuestra
      propia lógica de validación, algo que vamos a aprender en esta lección.<br>
      <h2 id="toc1"><a name="Alternativas-de-validacion"></a>Alternativas de
        validación</h2>
      Vamos a refinar tu código para que el usuario no pueda asignar pedidos a
      una factura si los pedidos no han sido entregados todavía. Es decir, solo
      los pedidos entregados pueden asociarse a una factura. Aprovecharemos la
      oportunidad para explorar diferentes formas de hacer esta validación.<br>
      <h3 id="toc2"><a name="Alternativas-de-validacion-Anadir-la-propiedad-entregado-a-Pedido"></a>Añadir
        la propiedad entregado a Pedido</h3>
      Para hacer esto, lo primero es añadir una nueva propiedad a la entidad <em>Pedido</em>.
      La propiedad <em>entregado</em>:<br>
      <pre><code class="java">@Column(columnDefinition="BOOLEAN DEFAULT FALSE")
boolean entregado;
</code></pre> Además es necesario añadir la propiedad <em>entregado</em> a la
      vista. Modifica la vista <em>Pedido</em> como muestra el siguiente
      código:<br>
      <pre><code class="java">@View(extendsView="super.DEFAULT", 
    members=
        "diasEntregaEstimados, entregado, " + // Añade entregado
        "factura { factura }"
)
...
public class Pedido extends DocumentoComercial {
</code></pre> Ahora tienes una nueva propiedad <em>entregado</em> que el
      usuario puede marcar para indicar que el pedido ha sido entregado. Ejecuta
      el nuevo código y marca algunos de los pedidos existentes como entregados.<br>
      <h3 id="toc3"><a name="Alternativas-de-validacion-Validar-con-EntityValidator"></a>Validar
        con <em>@EntityValidator</em></h3>
      En tu aplicación actual el usuario puede añadir cualquier pedido que le
      plazca a una factura usando el módulo <em>Factura</em> y puede asignar
      una factura a cualquier pedido desde el módulo <em>Pedido</em>. Vamos a
      restringir esto. Solo los pedidos entregados podrán añadirse a una
      factura.<br>
      La primera alternativa que usaremos para implementar esta validación es
      mediante <i>@EntityValidator</i>. Esta anotación te permite asignar a tu
      entidad una clase con la lógica de validación deseada. Anotemos tu entidad
      <em>Pedido</em> tal como muestra el siguiente código:<br>
      <pre><code class="java">@EntityValidator(
    value=com.tuempresa.facturacion.validadores.ValidadorEntregadoParaEstarEnFactura.class, // Clase con la lógica de validación
    properties= {
        @PropertyValue(name="anyo"), // El contenido de estas propiedades
        @PropertyValue(name="numero"), // se mueve desde la entidad 'Pedido'
        @PropertyValue(name="factura"), // al validador antes de
        @PropertyValue(name="entregado") // ejecutar la validación
})
public class Pedido extends DocumentoComercial {
</code></pre><em></em>Cada vez que un objeto <em>Pedido</em> se crea o modifica
      un objeto del tipo <em>ValidadorEntregadoParaEstarEnFactura</em> es
      creado, entonces las propiedades <em>anyo</em>, <em>numero</em>, <em>factura</em>
      y <em>entregado</em> se rellenan con las propiedades del mismo nombre del
      objeto <em>Pedido</em>. Después de eso, el método <i>validate()</i> del
      validador se ejecuta. Escribamos el código del validador, primero crea el
      paquete <i>com.tuempresa.facturacion.validadores </i>y después pon en él
      esta clase:<br>
      <pre><code class="java">package com.tuempresa.facturacion.validadores; // En el paquete 'validadores'
 
import com.tuempresa.facturacion.modelo.*;
import org.openxava.util.*;
import org.openxava.validators.*;
import lombok.*;
 
@Getter @Setter 
public class ValidadorEntregadoParaEstarEnFactura
    implements IValidator { // ha de implementar 'IValidator'
 
    private int anyo; // Propiedades a ser inyectadas desde Pedido
    private int numero;
    private boolean entregado;
    private Factura factura;
 
    public void validate(Messages errors)
        throws Exception { // La lógica de validación
        if (factura == null) return;
        if (!entregado) {
            errors.add( // Al añadir mensajes a 'errors' la validación fallará
                "pedido_debe_estar_entregado", // Un id del archivo i18n
                anyo, numero); // Argumentos para el mensaje
        }
    }

}
</code></pre> La lógica de validación es extremadamente fácil, si una factura
      está presente y este pedido no ha sido servido añadimos un mensaje de
      error, por tanto la validación fallará. Has de añadir el mensaje de error
      en el archivo <em>Facturacion/i18n/MensajesFacturacion_es.properties</em>.
      Tal como muestra a continuación:<br>
      <pre><code class="properties"># Mensajes  para la aplicación Facturacion
pedido_debe_estar_entregado=Pedido {0}/{1} debe estar entregado para ser añadido a una Factura
</code></pre> Ahora puedes intentar añadir pedidos a una factura con la
      aplicación, verás como los pedidos no entregados son rechazados. Ve al
      módulo <i>Facturas</i>, selecciona la pestaña PEDIDOS de una factura y
      desde ahí pulsa en el botón <i>Añadir</i>:
      <div class="wiki" style="display: block;"> <img src="files/validation_es010.png"

          alt="validation_es010.png" title="validation_es010.png"></div>
      <div class="wiki" style="display: block;">Se mostrará un diálogo con una
        lista de pedidos para escoger. Selecciona dos, uno de ellos no entregado
        todavía y pulsa en AÑADIR:</div>
      <img src="files/validation_es013.png" alt="validation_es013.png" title="validation_es013.png">
      <div class="wiki" style="display: block;">Entonces el pedido entregado se
        añadirá mientras que el otro es rechazado, generando los siguientes
        mensajes:</div>
      <img src="files/validation_es017.png" alt="validation_es017.png" title="validation_es017.png">
      <div class="wiki" style="display: block;"> Ya tienes tu validación hecha
        con <i>@EntityValidator</i>. No es difícil, pero es un poco verboso,
        porque necesitas escribir una clase nueva solo para añadir 2 línea de
        lógica. Aprendamos otras formas de hacer esta misma validación.<br>
      </div>
      <h3 id="toc4"><a name="Alternativas-de-validacion-Validar-con-metodos-de-retrollamada-JPA"></a>Validar
        con métodos de retrollamada JPA</h3>
      Vamos a probar otra forma más sencilla de hacer esta validación,
      simplemente moviendo la lógica de validación desde la clase validador a la
      misma entidad <em>Pedido</em>, en este caso a un método <i>@PrePersist</i>
      y <i>@PreUpdate</i>.<br>
      Lo primero es eliminar la clase <em>ValidadorEntregadoParaEstarEnFactura</em>
      de tu proyecto. También quita la anotación <i>@EntityValidator</i> de tu
      entidad <em>Pedido</em>:<br>
      <pre><code class="java">// @EntityValidator( // Eliminar '@EntityValidator'
//    value=com.tuempresa.facturacion.validadores.ValidadorEntregadoParaEstarEnFactura.class,
//    properties= {
//        @PropertyValue(name="anyo"),
//        @PropertyValue(name="numero"),
//        @PropertyValue(name="factura"),
//        @PropertyValue(name="entregado")
// })
public class Pedido extends DocumentoComercial {
</code></pre> Acabamos de eliminar la validación. Ahora, vamos a añadirla de
      nuevo, pero ahora dentro de la misma clase <em>Pedido</em>. Escribe el
      método <em>validar()</em> que se muestra a continuación dentro de tu
      clase <em>Pedido</em>:<br>
      <pre><code class="java">@PrePersist @PreUpdate // Antes de crear o modificar
private void validar() throws Exception {
    if (factura != null &amp;&amp; !isEntregado()) { // La lógica de validación
        // La excepción de validación del entorno Bean Validation
        throw new javax.validation.ValidationException(
            XavaResources.getString( // Para leer un mensaje i18n
                "pedido_debe_estar_entregado",
                getAnyo(),
                getNumero())
        );
    }
}
</code></pre>Antes de grabar un pedido esta validación se ejecutará, si falla
      una <i>ValidationException</i> será lanzada. Esta excepción es del marco
      de validación Bean Validation, de esta forma OpenXava sabe que es una
      excepción de validación. Así con solo un método dentro de tu entidad
      tienes la validación hecha.
      <div class="wiki" style="display: block;">Sólo está permitido un método <i>@PrePersist</i>
        y un método <i>@PreUpdate</i> por entidad, por eso antes de ejecutar el
        código de arriba has de comentar las anotaciones <i>@PrePersist</i> y <i>@PreUpdate</i>
        que tenías en <i>recalcularDiasEntrega()</i>, de esta manera:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="java">// @PrePersist @PreUpdate // Comenta estas anotaciones
private void recalcularDiasEntrega()() {
    setDiasEntrega(getDiasEntregaEstimados());
}
</code></pre> </div>
      <div class="wiki" style="display: block;">No te preocupes, descomentaremos
        estas anotaciones más adelante. Aunque JPA sólo permita un método <i>@PrePersist/@PreUpdate</i>
        siempre tenemos la opción de crear un único método de retrollamada desde
        el cual llamar a todos los demás métodos que necesitemos, pero esto no
        hace falta en nuestro caso, porque no vamos a quedarnos con este estilo
        de validación como definitivo.</div>
      <div class="wiki" style="display: block;">Ahora, intentar añadir pedidos
        no entregados a una factura y verás los errores de validación, como en
        nuestro primer ejemplo.<br>
      </div>
      <h3 id="toc5"><a name="Alternativas-de-validacion-Validar-en-el-setter"></a>Validar
        en el setter</h3>
      Otra alternativa para hacer tu validación es poner tu lógica de validación
      dentro del método setter. Es un enfoque simple y llano. </div>
    <div class="wiki" style="display: block;">Para probarlo, primero vuelve a
      poner las anotaciones <i>@PrePersist</i> y <i>@PreUpdate</i> en el
      método <i>recalcularDiasEntrega(), </i>también quita el método <em>validar()</em>
      de tu entidad <em>Pedido</em>: </div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@PrePersist @PreUpdate // Añádelas de nuevo
private void recalcularDiasEntrega() {
    setDiasEntrega(getDiasEntregaEstimados());
}	
	
// Quita el método validar()
	
// @PrePersist @PreUpdate // Antes de crear o modificar
// private void validar() throws Exception {
//     if (factura != null &amp;&amp; !isEntregado()) { // La lógica de validación
//         // La excepción de validación del entorno Bean Validation
//         throw new javax.validation.ValidationException(
//             XavaResources.getString( // Para leer un mensaje i18n
//                 "pedido_debe_estar_entregado",
//                 getAnyo(),
//                 getNumero())
//         );
//     }
// }    
</code></pre> </div>
    <div class="wiki" style="display: block;">Después añade el método setter <em>setFactura()</em>
      a <i>Pedido</i>:<br>
      <pre><code class="java">public void setFactura(Factura factura) {
    if (factura != null &amp;&amp; !isEntregado()) { // La lógica de validación
        // La excepción de validación del entorno Bean Validation
        throw new javax.validation.ValidationException(
            XavaResources.getString( // Para leer un mensaje i18n
                "pedido_debe_estar_entregado",
                getAnyo(),
                getNumero())
        );
    }
    this.factura = factura; // La asignación típica del setter
}
</code></pre> Esto funciona exactamente como las dos opciones anteriores. Es
      parecida a la alternativa del <i>@PrePersist/@PreUpdate</i>, solo que no
      depende de JPA, es una implementación básica de Java.<br>
      <h3 id="toc6"><a name="Alternativas-de-validacion-Validar-con-Bean-Validation"></a>Validar
        con <em>Bean Validation</em></h3>
      Como opción final vamos a hacer la más breve. Consiste en poner tu lógica
      de validación dentro de un método booleano anotado con la anotación de
      Bean Validation <i>@AssertTrue</i>.<br>
      Para implementar esta alternativa primero quita el método <em>setFactura()</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">// Quita el método setter

// public void setFactura(Factura factura) {
//    if (factura != null &amp;&amp; !isEntregado()) { // La lógica de validación
//        // La excepción de validación del entorno Bean Validation
//        throw new javax.validation.ValidationException(
//            XavaResources.getString( // Para leer un mensaje i18n
//                "pedido_debe_estar_entregado",
//                getAnyo(),
//                getNumero())
//        );
//    }
//    this.factura = factura; // La asignación típica del setter
// }
</code></pre> </div>
    <div class="wiki" style="display: block;">Después, añade <em>isEntregadoParaEstarEnFactura()</em>
      a tu entidad <em>Pedido</em>, como se muestra a continuación:<br>
      <pre><code class="java">@AssertTrue(  // Antes de grabar confirma que el método devuelve true, si no lanza una excepción
    message="pedido_debe_estar_entregado" // Mensaje de error en caso retorne false
)
private boolean isEntregadoParaEstarEnFactura() { // ...
    return factura == null || isEntregado(); // La lógica de validación
}
</code></pre> </div>
    <div class="wiki" style="display: block;">En las formas anteriores de
      validación nuestro mensaje de error era construído mediante dos
      argumentos, <em>anyo</em> y <em>numero</em>, que en nuestro archivo <em>i18n</em>
      son representados por <em>{0}/{1}</em> respectivamente. Para el caso de
      validación con <i>@AssertTrue</i> no podemos pasar estos dos argumentos
      para construir nuestro mensaje de error, sino que podemos declarar
      propiedades y propiedades calificadas del bean validado en la definición
      del mensaje, para eso cambia en <em>MensajesFacturacion_es.properties</em>
      la entrada:<br>
      <pre><code class="properties">pedido_debe_estar_entregado=Pedido {0}/{1} debe estar entregado para ser añadido a una Factura
</code></pre> </div>
    <div class="wiki" style="display: block;">Por:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="properties">pedido_debe_estar_entregado=Pedido {anyo}/{numero} debe estar entregado para ser añadido a una Factura
</code></pre> </div>
    <div class="wiki" style="display: block;">Fíjate que hemos cambiado <i>{0}/{1}</i>
      por <i>{anyo}/{numero}</i>. OpenXava llenará <em>{anyo}/{numero}</em>
      con los valores de <em>anyo</em> y <em>numero</em> que tenga el <em>Pedido</em>
      que está siendo actualizado y no cumple la condición de validación.<br>
      Esta es la forma más simple de validar, porque solo anotamos el método con
      la validación, y es el entorno Bean Validation el responsable de llamar
      este método al grabar y lanzar la excepción correspondiente si la
      validación no pasa.<br>
      <h3 id="toc7"><a name="Alternativas-de-validacion-Validar-al-borrar-con-RemoveValidator"></a>Validar
        al borrar con <em>@RemoveValidator</em></h3>
      Las validaciones que hemos visto hasta ahora se hacen cuando la entidad se
      modifica, pero a veces es útil hacer la validación justo al borrar la
      entidad y usar la validación para vetar el borrado de la misma.<br>
      Vamos a modificar la aplicación para impedir que un usuario borre un
      pedido si éste tiene una factura asociada. Para hacer esto anota tu
      entidad <em>Pedido</em> con <i>@RemoveValidator</i>, como se muestra a
      continuación:<br>
      <pre><code class="java">@RemoveValidator(com.tuempresa.facturacion.validadores.ValidadorBorrarPedido.class) // La clase con la validación
public class Pedido extends DocumentoComercial {
</code></pre><em></em>Ahora, antes de borrar un pedido la lógica de <em>ValidadorBorrarPedido</em>
      se ejecuta y si la validación falla el pedido no se borra. Veamos el
      código de este validador:<br>
      <pre><code class="java">package com.tuempresa.facturacion.validadores; // En el paquete 'validadores'
 
import com.tuempresa.facturacion.modelo.*;
import org.openxava.util.*;
import org.openxava.validators.*;
 
public class ValidadorBorrarPedido
    implements IRemoveValidator { // Ha de implementar 'IRemoveValidator'
 
    private Pedido pedido;
 
    public void setEntity(Object entity) // La entidad a borrar se inyectará...
        throws Exception // ...con este método antes de la validación
    {
        this.pedido = (Pedido) entity;
    }
 
    public void validate(Messages errors) // La lógica de validación
        throws Exception
    {
        if (pedido.getFactura() != null) {
            // Añadiendo mensajes a 'errors' la validación fallará y el
            // borrado se abortará
            errors.add("no_puede_borrar_pedido_con_factura");
        }
    }
}
</code></pre> La lógica de validación está en el método <i>validate()</i>.
      Antes de llamarlo la entidad a validar es inyectada usando <i>setEntity()</i>.
      Si se añaden mensajes al objeto <i>errors</i> la validación fallará y la
      entidad no se borrará. Has de añadir el mensaje de error en el archivo <em>Facturacion/i18n/MensajesFacturacion_es.properties</em>:<br>
      <pre><code class="properties">no_puede_borrar_pedido_con_factura=Pedido asociado a factura no puede ser eliminado
</code></pre> Ahora si intentas borrar un pedido con una factura asociada
      obtendrás un mensaje de error y el borrado no se producirá.<br>
      Puedes ver que usar un <i>@RemoveValidator</i> no es difícil, pero es un
      poco verboso. Has de escribir una clase nueva solo para añadir un simple
      if. Examinemos una alternativa más breve.<br>
      <h3 id="toc8"><a name="Alternativas-de-validacion-Validar-al-borrar-con-un-metodo-de-retrollamada"></a>Validar
        al borrar con un método de retrollamada</h3>
      Vamos a probar otra forma más simple de hacer esta validación al borrar,
      moviendo la lógica de validación desde la clase validador a la misma
      entidad <em>Pedido</em>, en este caso en un método <i>@PreRemove</i>.<br>
      El primer paso es eliminar la clase <em>ValidadorBorrarPedido</em> de tu
      proyecto. Además quita la anotación <i>@RemoveValidator</i> de tu entidad
      <em>Pedido</em>:<br>
      <pre><code class="java">// @RemoveValidator(com.tuempresa.facturacion.validadores.ValidadorBorrarPedido.class) // Quitamos '@RemoveValidator'
public class Pedido extends DocumentoComercial {
</code></pre> Hemos quitado la validación. Añadámosla otra vez, pero ahora
      dentro de la misma clase <em>Pedido</em>. Añade el método <em>validarPreBorrar()</em>
      a la clase <em>Pedido</em>, como se muestra a continuación:<br>
      <pre><code class="java">@PreRemove
private void validarPreBorrar() {
    if (factura != null) { // La lógica de validación
        throw new javax.validation.ValidationException( // Lanza una excepción runtime
            XavaResources.getString( // Para obtener un mensaje de texto
                "no_puede_borrar_pedido_con_factura"));
    }
}
</code></pre> Antes de borrar un pedido esta validación se efectuará, si falla
      se lanzará una <i>ValidationException</i>. Puedes lanzar cualquier
      excepción runtime para abortar el borrado. Tan solo con un método dentro
      de la entidad tienes la validación hecha.<br>
      <h3 id="toc9"><a name="Alternativas-de-validacion-Cual-es-la-mejor-forma-de-validar"></a>¿Cuál
        es la mejor forma de validar?</h3>
      Has aprendido varias formas de hacer la validación sobre tus clases del
      modelo. ¿Cuál de ellas es la mejor? Todas ellas son opciones válidas.
      Depende de tus circunstancias y preferencias personales. Si tienes una
      validación que no es trivial y es reutilizable en varios puntos de tu
      aplicación, entonces usar un <i>@EntityValidator</i> y <i>@RemoveValidator</i>
      es una buena opción. Por otra parte, si quieres usar tu modelo fuera de
      OpenXava y sin JPA, entonces el uso de la validación en los <em>setters</em>
      es mejor.<br>
      En nuestro caso particular hemos optado por <i>@AssertTrue</i> para la
      validación “el pedido ha de estar servido para estar en una factura” y por
      <i>@PreRemove</i> para la validación al borrar. Ya que son las
      alternativas más simples que funcionan.<br>
      <h2 id="toc10"><a name="Crear-tu-propia-anotacion-de-Bean-Validation"></a>Crear
        tu propia anotación de <em>Bean Validation</em></h2>
      Las técnicas mencionadas hasta ahora son muy útiles para la mayoría de las
      validaciones de tus aplicaciones. Sin embargo, a veces te encuentras con
      algunas validaciones que son muy genéricas y quieres usarlas una y otra
      vez. En este caso definir tu propia anotación de <em>Bean Validation</em>
      puede ser una buena opción. Definir un <em>Bean validation</em> es más
      largo y engorroso que lo que hemos visto hasta ahora, pero usarlo y
      reusarlo es simple, tan solo añadir una anotación a tu propiedad o clase.<br>
      Vamos a aprender como crear un <em>Bean Validation</em>.<br>
      <h3 id="toc11"><a name="Crear-tu-propia-anotacion-de-Bean-Validation-Usar-un-Bean-Validation-en-tu-entidad"></a>Usar
        un <em>Bean Validation</em> en tu entidad</h3>
      Es superfácil. Simplemente anota tu propiedad como ves a continuación:<br>
      <pre><code class="java">@ISBN // Esta anotación indica que esta propiedad tiene que validarse como un ISBN
String isbn;
</code></pre> Solo con añadir <em>@ISBN</em> a tu propiedad ésta será validada
      justo antes de que la entidad se grabe en la base de datos, ¡genial! El
      problema es que <em>@ISBN</em> no está incluida como un validador
      predefinido en el marco de validación <em>Bean Validation</em>. Esto no
      es un gran problema, si quieres una anotación <em>@ISBN</em>, hazla tú
      mismo. De hecho, vamos a crear la anotación de validación <em>@ISBN</em>
      en esta sección.<br>
      Antes de nada, añadamos una nueva propiedad <em>isbn</em> a <em>Producto</em>.
      Edita tu clase <em>Producto</em> y añádele el siguiente código:<br>
      <pre><code class="java">@Column(length=13)
String isbn;
</code></pre> Ejecuta el módulo <em>Producto</em> con tu navegador. Sí, la
      propiedad <em>isbn</em> ya está ahí. Ahora, puedes añadir la validación.<br>
      <h3 id="toc12"><a name="Crear-tu-propia-anotacion-de-Bean-Validation-Definir-tu-propia-anotacion-ISBN"></a>Definir
        tu propia anotación <em>ISBN</em></h3>
      Creemos la anotación <em>@ISBN</em>. Primero, crea un paquete en tu
      proyecto llamado <em>com.tuempresa.facturacion.anotaciones</em>. Pulsa en
      él con el botón derecho del ratón y escoge <i>New &gt; Annotation</i>,
      como sigue:<br>
      <img src="files/validation_es020.png" alt="validation_es020.png" title="validation_es020.png"><br>
      Se mostrará un diálogo, teclea ISBN y pulsa en <i>Finish</i>:</div>
    <img src="files/validation_es030.png" alt="validation_es030.png" title="validation_es030.png">
    <div class="wiki" style="display: block;">Edita el código de tu recién
      creada anotación <em>ISBN</em> y déjala así:<br>
      <pre><code class="java">package com.tuempresa.facturacion.anotaciones; // En el paquete 'anotaciones'
 
import java.lang.annotation.*;
import javax.validation.*;
 
@Constraint(validatedBy = com.tuempresa.facturacion.validadores.ValidadorISBN.class)
@Target({ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface ISBN {
 
    Class&lt;?&gt;[] groups() default{};
    Class&lt;? extends Payload&gt;[] payload() default{};
    String message() default "isbn_invalido"; // Id del mensaje en el archivo i18n
}
</code></pre> Como puedes ver, es una definición de anotación normal y
      corriente. El atributo <i>message</i> es el mensaje a mostrar al usuario
      si la validación falla, puedes escribir el mensaje tal cual o poner un
      identificador i18n. El desarrollador puede especificar su propio mensaje
      cuando use la anotación, aunque nosotros proveemos unos por defecto,
      "isbn_invalido", por lo que hemos de añadir la siguiente entrada en <em>MensajesFacturacion_es.properties</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="properties">isbn_invalido=ISBN inválido o inexistente
</code></pre> </div>
    <div class="wiki" style="display: block;"><i>@Constraint</i> indica la clase
      con la lógica de validación. Escribamos la clase <em>ValidadorISBN</em>.<br>
      <h3 id="toc13"><a name="Crear-tu-propia-anotacion-de-Bean-Validation-Usa-Apache-Commons-Validator-para-implementar-la-logica"></a>Usa
        <em>Apache Commons Validator</em> para implementar la lógica</h3>
      Vamos a escribir la clase <em>ValidadorISBN</em> con la lógica de
      validación para un <em>ISBN</em>. En lugar de escribir nosotros mismos la
      lógica para validar un <em>ISBN</em> usaremos el proyecto <a href="http://commons.apache.org/proper/commons-validator/">Commons
        Validator</a> de Apache. Commons Validator contiene algoritmos de
      validación para direcciones de correo electrónico, fechas, URL y así por
      el estilo. El <em>commons-validator.jar</em> se incluye por defecto en
      los proyectos OpenXava, por tanto lo puedes usar sin ninguna configuración
      adicional.<br>
      El código para <em>ValidadorISBN</em> lo puedes ver a continuación:<br>
      <pre><code class="java">package com.tuempresa.facturacion.validadores; // En el paquete 'validadores'
 
import javax.validation.*;
 
import com.tuempresa.facturacion.anotaciones.*;
import org.openxava.util.*;
 
public class ValidadorISBN implements ConstraintValidator&lt;ISBN, Object&gt; {
 
    private static org.apache.commons.validator.routines.ISBNValidator
        validador = // De 'Commons Validator'
            new org.apache.commons.validator.routines.ISBNValidator();
 
    public void initialize(ISBN isbn) {
 
    }
    
    // Contiene la lógica de validación
    public boolean isValid(Object valor, ConstraintValidatorContext contexto) { 
        if (Is.empty(valor)) return true;
        return validador.isValid(valor.toString()); // Usa 'Commons Validator'
    }
}
</code></pre> Como ves, la clase validador tiene que implementar <i>ConstraintValidator</i>
      del paquete <em>javax.validation</em>. Esto fuerza a tu validador a
      implementar <i>initialize()</i> e <i>isValid()</i>. El método <i>isValid()</i>
      contiene la lógica de validación. Fíjate que si el elemento a validar está
      vacío asumimos que es válido, porque validar si un valor está presente es
      responsabilidad de otras anotaciones, como <i>@Required</i>, y no de <em>@ISBN</em>.<br>
      En este caso la lógica de validación es sencillísima, porque nos limitamos
      a llamar al validador ISBN de Apache Commons Validator.<br>
      <em>@ISBN</em> está listo para usar. Para hacerlo anota tu propiedad <em>isbn</em>
      con él. Puedes ver cómo:<br>
      <pre><code class="java">@Column(length=13) @ISBN
String isbn;
</code></pre>En este caso cuando grabes la clase el import para <i>@ISBN</i> no
      se añade automáticamente. Esto es porque hay otra <i>@ISBN</i> disponible
      (de la librería Hibernate Validator incluida con OpenXava), por tanto
      OpenXava Studio no sabe cual escoger. No te preocupes, pon el ratón sobre
      la anotación <i>@ISBN</i> y una ventana emergente se mostrará con varias
      soluciones posibles, escoge <i>Import 'ISBN'
        (com.yourcompany.invoicing.annotations)</i> para que el import correcto
      se añada a la clase <i>Producto</i>:</div>
    <div class="wiki" style="display: block;"> <img src="files/validation_es035.png"

        alt="validation_es035.png" title="validation_es035.png"> </div>
    <div class="wiki" style="display: block;"> Ahora, puedes probar tu módulo, y
      verificar que el <em>ISBN</em> que introduces se valida correctamente.
      Enhorabuena, has escrito tu primer <em>Bean Validation</em>. No ha sido
      tan difícil: una anotación, una clase.<br>
      Este <em>@ISBN</em> es suficientemente bueno para usarlo en la vida real,
      sin embargo, vamos a mejorarlo un poco más y así tendremos la posibilidad
      de experimentar con algunas posibilidades interesantes.<br>
      <h3 id="toc14"><a name="Crear-tu-propia-anotacion-de-Bean-Validation-Llamar-a-un-servicio-web-REST-para-validar-el-ISBN"></a>Llamar
        a un servicio web REST para validar el ISBN</h3>
      Aunque la mayoría de los validadores tienen una lógica simple, puedes
      crear validadores con una lógica compleja si lo necesitas. Por ejemplo, en
      el caso de nuestro ISBN, queremos, no sólo verificar el formato correcto,
      sino también comprobar que existe de verdad un libro con ese ISBN. Una
      forma de hacer esto es usando servicios web.<br>
      Como seguramente ya sepas, un servicio web es una funcionalidad que reside
      en un servidor web y que tú puedes llamar desde tu programa. La forma
      tradicional de desarrollar servicios web es mediante los estándares WS-*,
      como SOAP, UDDI, etc. Aunque, hoy en día, la forma más simple de
      desarrollar servicios es REST. REST consiste básicamente en usar la ya
      existente “forma de trabajar” de internet para comunicación entre
      programas. Llamar a un servicio REST consiste en usar una URL web
      convencional para obtener un recurso de un servidor web. Este recurso
      usualmente contiene datos en formato XML, HTML, JSON, etc. En otras
      palabras, los programas usan internet de la misma manera que lo hacen los
      usuarios con sus navegadores.<br>
      Hay bastantes sitio con servicios web SOAP y REST para consultar el ISBN
      de un libro, vamos a usar <a href="https://openlibrary.org/">openlibrary.org</a>
      que proporciona una API REST gratuita para consultar su catálogo de
      libros. Para probar la API de Open Library abre un navegador y ve a la
      siguiente URL:
      <div class="wiki" style="display: block;"><a href="https://openlibrary.org/api/books?jscmd=data&amp;format=json&amp;bibkeys=ISBN:9780932633439">https://openlibrary.org/api/books?jscmd=data&amp;format=json&amp;bibkeys=ISBN:9780932633439</a></div>
      <div class="wiki" style="display: block;">Donde el último parámetro es el
        ISBN del libro, a partir del cual obtenemos un JSON con los datos del
        libro, algo como esto:</div>
      <img src="files/validation040.png" alt="validation040.png" title="validation040.png">
      <div class="wiki" style="display: block;">Un JSON es simplemente data con
        clave/valor que usa {} y [] para anidar y repetir. Si intentas obtener
        los datos de un libro inexistente, como en esta URL:</div>
      <div class="wiki" style="display: block;"><a href="https://openlibrary.org/api/books?jscmd=data&amp;format=json&amp;bibkeys=ISBN:9791034369997">https://openlibrary.org/api/books?jscmd=data&amp;format=json&amp;bibkeys=ISBN:9791034369997</a></div>
      <div class="wiki" style="display: block;">Obtienes un JSON vacío, como
        este:</div>
      <img src="files/validation050.png" alt="validation050.png" title="validation050.png"><span

        style="color: #505050;"><span style="font-family: arial,helvetica,sans-serif;"></span></span>
      <div class="wiki" style="display: block;">Es decir, un JSON vacío,
        simplemente unas llaves vacías, así: {}.</div>
      <div class="wiki" style="display: block;">Para llamar a este servicio web
        usaremos JAX-RS. JAX-RS es el estándar Java para llamar a servicios web
        REST. OpenXava incluye soporte para llamar a servicios web usando
        JAX-RS, por lo que no necesitas añadir ninguna librería adicional.<br>
        Modifiquemos <em>ValidadorISBN</em> para usar este servicio <em>REST</em>.
        Veamos el resultado:<br>
        <pre><code class="java">package com.tuempresa.facturacion.validadores; 

import javax.validation.*;
import javax.ws.rs.client.*; // Para usar JAX-RS
import com.tuempresa.facturacion.anotaciones.*;
import org.apache.commons.logging.*; // Para usar Log
import org.openxava.util.*;
 
public class ValidadorISBN
    implements ConstraintValidator&lt;ISBN, Object&gt; {
	
    private static Log log = LogFactory.getLog(ValidadorISBN.class); // Instancia 'log'
 
    private static org.apache.commons.validator.routines.ISBNValidator
        validador = 
            new org.apache.commons.validator.routines.ISBNValidator();
 
    public void initialize(ISBN isbn) {
 
    }
 
    public boolean isValid(Object valor, ConstraintValidatorContext contexto) {
        if (Is.empty(valor)) return true;
        if (!validador.isValid(valor.toString())) return false;
        return existeISBN(valor); // Aquí hacemos la llamada REST
    }
    
    private boolean existeISBN(Object isbn) {
        try {
            // Aquí usamos JAX-RS para llamar al servicio REST
            String respuesta = ClientBuilder.newClient()
                .target("http://openlibrary.org/") // El sitio
                .path("/api/books") // La ruta del servicio
                .queryParam("jscmd", "data") // Los parámetros
                .queryParam("format", "json")
                .queryParam("bibkeys", "ISBN:" + isbn) // El ISBN es un parámetro
                .request()
                .get(String.class); // Una cadena con el JSON
            return !respuesta.equals("{}"); // ¿Está el JSON vacío? Suficiente para nuestro caso
        }
        catch (Exception ex) {
            log.warn("Imposible conectar a openlibrary.org " +
                "para validar el ISBN. Validación fallida", ex);
            return false; // Si hay errores asumimos que la validación falla
        }
    }
    
}
</code></pre> </div>
      Simplemente abrimos la URL con el ISBN como parámetro de la petición. Si
      el JSON resultante es un JSON vacío, es decir {}, la búsqueda ha fallado,
      en caso contrario hemos encontrado el libro. Para nuestro caso, obtener el
      JSON como una cadena para poder hacer una comparación simple es el camino
      más corto, sin embargo JAX-RS permite convertir el JSON en un objeto Java
      de tu propia clase (<i>Libro</i> por ejemplo) rellenando las propiedades
      correspondientes, sólo has de usar <i>.get(Libro.class)</i> en lugar de <i>.get(String.class)</i>
      como última línea de la llamada. </div>
    <div class="wiki" style="display: block;"> Prueba ahora tu aplicación y
      verás como si introduces un ISBN no existente la validación falla.<br>
      <h3 id="toc15"><a name="Crear-tu-propia-anotacion-de-Bean-Validation-Anadir-atributos-a-tu-anotacion"></a>Añadir
        atributos a tu anotación</h3>
      Creas una anotación <em>Bean Validation</em> cuando quieres reutilizar la
      validación varias veces, usualmente en varios proyectos. En este caso,
      necesitas hacer tu validación adaptable, para que sea reutilizable de
      verdad. Por ejemplo, en el proyecto actual buscar en<a href="https://openlibrary.org/">
        openlibrary.org</a> el ISBN es conveniente, pero en otro proyecto, o
      incluso en otra entidad de tu actual proyecto, puede que no quieras hacer
      esa búsqueda. Necesitas hacer tu anotación más flexible.<br>
      La forma de añadir esta flexibilidad a tu anotación de validación es
      mediante los atributos. Por ejemplo, podemos añadir un atributo de
      búsqueda booleano a nuestra anotación <em>ISBN</em> para poder escoger si
      queremos buscar el ISBN en internet para validar o no. Para hacerlo,
      simplemente añade el atributo <em>buscar</em> al código de la anotación <i>ISBN</i>,
      tal como muestra el siguiente código:<br>
      <pre><code class="java">public @interface ISBN {
 
    boolean buscar() default true; // Para (des)activar la búsqueda web al validar
    // ... el resto del código
}
</code></pre> Este nuevo atributo <em>buscar</em> puede leerse de la clase
      validador. Míra como:<br>
      <pre><code class="java">public class ValidadorISBN implements ConstraintValidator&lt;ISBN, Object&gt; {
    // ...
    private boolean buscar; // Almacena la opción buscar
 
    public void initialize(ISBN isbn) { // Lee los atributos de la anotación
        this.buscar = isbn.buscar();
    }
 
    public boolean isValid(Object valor, ConstraintValidatorContext contexto) {
        if (Is.empty(valor)) return true;
        if (!validador.isValid(valor.toString())) return false;
        return buscar ? existeISBN(valor) : true; // Usa 'buscar'
    }
    // ...
}
</code></pre> Aquí ves la utilidad del método <i>initialize()</i>, que lee la
      anotación para inicializar el validador. En este caso simplemente
      almacenamos el valor de <em>isbn.buscar()</em> para preguntar por él en <i>isValid()</i>.<br>
      Ahora puedes escoger si quieres llamar a nuestro servicio REST o no para
      hacer la validación ISBN. Mira como:<br>
      <pre><code class="java">@ISBN(buscar=false) // En este caso no se hace una búsqueda en la web para validar el ISBN
private String isbn;
</code></pre> ¡Enhorabuena! Has aprendido como crear tu propia anotación de Bean
      Validation y de paso a usar JAX-RS para llamar a servicios REST.<br>
      <h2 id="toc20"><a name="Resumen"></a>Resumen</h2>
      En esta lección has aprendido varias formas de hacer validación en una
      aplicación OpenXava. Además, ahora estás preparado para encapsular toda la
      lógica de validación reutilizable en anotaciones usando <em>Bean
        Validation</em>.<br>
      La validación es una parte importante de la lógica de tu aplicación y te
      ánimo a que la pongas en el modelo, es decir en las entidades; tal y como
      esta lección ha mostrado. Aun así, a veces es conveniente poner algo de
      lógica fuera de las clases del modelo. Aprenderás a hacer esto en las
      siguientes lecciones.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-6-validation_es.zip/download"

          rel="nofollow">Descargar código fuente de esta lección</a></strong><br>
      <br>
      <strong>¿Problemas con la lección? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/437013/"

          rel="nofollow">Pregunta en el foro</a></strong> <strong>¿Ha ido bien?
        <a class="wiki_link" href="refining-standard-behavior_es.html">Ve a la
          lección 9</a></strong> </div>
  </body>
</html>
