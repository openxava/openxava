<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lesson 12: Advanced validation - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" style="display: block;">
      <h1 id="toc0"><a name="Lesson 6: Advanced validation"></a> <span id="breadcrumbs">
          <span id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava
              </a> </span> / <a href="index_en.html">documentation</a> / </span>
        Lesson 12: Advanced validation </h1>
      <strong>Course</strong>: <a class="wiki_link" href="getting-started_en.html">1.
        Getting started</a> | <a class="wiki_link" href="basic-domain-model1_en.html">2.
        Basic domain model (1)</a> | <a class="wiki_link" href="basic-domain-model2_en.html">3.
        Basic domain model (2)</a> | <a class="wiki_link" href="refining-user-interface_en.html">4.
        Refining the user interface</a> | <a class="wiki_link" href="agile-development_en.html">5.
        Agile development</a> | <a class="wiki_link" href="mapped-superclass-inheritance_en.html">6.
        Mapped superclass inheritance</a> | <a class="wiki_link" href="entity-inheritance_en.html">7.
        Entity inheritance</a> | <a class="wiki_link" href="view-inheritance_en.html">8.
        View inheritance</a> | <a class="wiki_link" href="basic-business-logic_en.html">9.
        Basic business logic</a> | <a class="wiki_link" href="total-properties-with-calculation_en.html">10.
        Total properties with Calculation</a> | <a class="wiki_link" href="refining-standard-behavior_en.html">11.
        Refining the standard behavior</a> | <strong>12. Advanced validation</strong>
      | <a class="wiki_link" href="refining-standard-behavior_en">13. Refining
        the standard behavior</a> | <a class="wiki_link" href="business-logic-behavior_en.html">14.
        Behavior &amp; business logic</a> | <a class="wiki_link" href="references-collections_en.html">15.
        References &amp; collections</a> | <a class="wiki_link" href="philosophy_en.html">A.
        Architecture &amp; philosophy</a> | <a class="wiki_link" href="jpa_en.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_en.html">C.
        Annotations</a> | <a class="wiki_link" href="testing_en.html">D.
        Automated testing</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">Table of contents</h1>
        <div style="margin-left: 1em;"><a href="#Lesson%206:%20Advanced%20validation">Lesson
            12: Advanced validation</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%206:%20Advanced%20validation-Validation%20alternatives">Validation
            alternatives</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Validation%20alternatives-Adding%20delivered//%20property%20to%20//Order">Adding
            delivered property to Order</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Validation%20alternatives-Validating%20with%20@EntityValidator">Validating
            with @EntityValidator</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Validation%20alternatives-Validating%20with%20a%20JPA%20callback%20method">Validating
            with a JPA callback method</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Validation%20alternatives-Validating%20in%20the%20setter">Validating
            in the setter</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Validation%20alternatives-Validating%20with%20Bean%20Validation">Validating
            with Bean Validation</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Validation%20alternatives-Validating%20on%20removal%20with%20@RemoveValidator">Validating
            on removal with @RemoveValidator</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Validation%20alternatives-Validating%20on%20removal%20with%20a%20JPA%20callback%20method">Validating
            on removal with a JPA callback method</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Validation%20alternatives-What%27s%20the%20best%20way%20of%20validating?">What's
            the best way of validating?</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%206:%20Advanced%20validation-Creating%20your%20own%20Bean%20Validation%20annotation">Creating
            your own Bean Validation annotation</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Creating%20your%20own%20Bean%20Validation%20annotation-Using%20a%20Bean%20Validation%20from%20your%20entity">Using
            a Bean Validation from your entity</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Creating%20your%20own%20Bean%20Validation%20annotation-Defining%20your%20own%20ISBN%20annotation">Defining
            your own ISBN annotation</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Creating%20your%20own%20Bean%20Validation%20annotation-Using%20Apache%20Commons%20Validator%20to%20implement%20the%20validation%20logic">Using
            Apache Commons Validator to implement the validation logic</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Creating%20your%20own%20Bean%20Validation%20annotation-Call%20to%20a%20REST%20web%20service%20to%20validate%20the%20ISBN">Call
            to a REST web service to validate the ISBN</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%206:%20Advanced%20validation-Creating%20your%20own%20Bean%20Validation%20annotation-Adding%20attributes%20to%20your%20annotation">Adding
            attributes to your annotation</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%206:%20Advanced%20validation-Summary">Summary</a></div>
      </div>
      So far we have only done some basic validations using the <i>@Required</i>
      annotation. However, sometimes it's convenient to write our own logic for
      the validation. In this lesson we are going to describe custom validation
      methods which allow us to add specific business logic to your application.<br>
      <h2 id="toc1"><a name="Lesson 6: Advanced validation-Validation alternatives"></a>Validation
        alternatives</h2>
      We are going to enhance your code with this logic: if the orders are not
      delivered yet, then the user cannot assign them to an invoice. That is,
      only delivered orders can be associated with an invoice.<br>
      <h3 id="toc2"><a name="Lesson 6: Advanced validation-Validation alternatives-Adding delivered// property to //Order"></a>Adding
        <em>delivered</em> property to <em>Order</em></h3>
      First you have to add a new property to the <em>Order</em> entity. The <em>delivered</em>
      property:<br>
      <pre><code class="java">@Column(columnDefinition="BOOLEAN DEFAULT FALSE")
boolean delivered;
</code></pre> Moreover it's necessary to add the <em>delivered</em> property to
      the view. Modify the <em>Order</em> view as shown in the following code:<br>
      <pre><code class="java">@View(extendsView="super.DEFAULT", 
    members=
        "estimatedDeliveryDays, delivered," + // Add delivered
        "invoice { invoice }" 
)
...
public class Order extends CommercialDocument {
</code></pre> There is a new <em>delivered</em> property now which indicates
      the delivery state of an order. Try the new code and mark some of the
      existing orders as delivered.<br>
      <h3 id="toc3"><a name="Lesson 6: Advanced validation-Validation alternatives-Validating with @EntityValidator"></a>Validating
        with <em>@EntityValidator</em></h3>
      Up to now the user can add any order to any invoice from the <em>Invoice</em>
      module, and he can associate a particular invoice with any order from the
      <em>Order</em> module. We are going to restrict this: only delivered
      orders are allowed to be added to an invoice.<br>
      The first alternative to implement this validation is by using an <i>@EntityValidator</i>.
      This annotation allows you to assign the desired validation logic to your
      entity. Let's annotate the <em>Order</em> entity as show in following
      code:<br>
      <pre><code class="java">@EntityValidator(
    value=com.yourcompany.invoicing.validators.DeliveredToBeInInvoiceValidator.class, // The class with the validation logic
    properties= {
        @PropertyValue(name="year"), // The content of these properties
        @PropertyValue(name="number"), // is moved from the 'Order' entity
        @PropertyValue(name="invoice"), // to the validator before
        @PropertyValue(name="delivered") // executing the validation
    }
)
public class Order extends CommercialDocument {
</code></pre><em></em>Every time an <em>Order</em> object is created or
      modified an object of type <em>DeliveredToBeInInvoiceValidator</em> is
      created. Then its properties <em>year</em>, <em>number</em>, <em>invoice</em>
      and <em>delivered</em> are initialized with the properties of the same
      name from the <em>Order</em> object. After that, the <i>validate()</i>
      method of the validator is executed. Let's write the validator code, first
      create the <i>com.yourcompany.invoicing.validators</i> package, then put
      the next class inside:<br>
      <pre><code class="java">package com.yourcompany.invoicing.validators; // In 'validators' package

import com.yourcompany.invoicing.model.*;
import org.openxava.util.*;
import org.openxava.validators.*;
import lombok.*;
 
@Getter @Setter 
public class DeliveredToBeInInvoiceValidator
    implements IValidator { // Must implement IValidator
 
    int year; // Properties to be injected from Order
    int number;
    boolean delivered;
    Invoice invoice;
 
    public void validate(Messages errors) // The validation logic
        throws Exception
    {
        if (invoice == null) return;
        if (!delivered) {
            errors.add( // By adding messages to errors the validation will fail
                "order_must_be_delivered", // An id from i18n file
                year, number); // Arguments for the message
         }
    }

}
</code></pre> The validation logic is absolutely straightforward: if an invoice
      is present and this order is not marked as delivered we add an error
      message, so the validation will fail. You should add the error message in
      the <em>Invoicing/i18n/Invoicing-messages_en.properties</em> file. As
      shown below:<br>
      <pre><code class="properties"># Messages for the Invoicing application
order_must_be_delivered=Order {0}/{1} must be delivered in order to be added to an Invoice
</code></pre> Now you can try to add orders to an invoice with the application,
      you will see how the undelivered orders are rejected. Go to <i>Invoices</i>
      module, select the ORDERS tab of an invoice, and from there click on <i>Add</i>
      button:</div>
    <div class="wiki" style="display: block;"> <img src="files/validation_en010.png"

        alt="validation_en010.png" title="validation_en010.png"></div>
    <div class="wiki" style="display: block;">It will show a dialog with a list
      of orders to choose from. Choose two, one of them not delivered yet, then
      click on ADD:</div>
    <img src="files/validation_en013.png" alt="validation_en013.png" title="validation_en013.png">
    <div class="wiki" style="display: block;">Then the delivered order is added
      and the other rejected, producing the next messages:</div>
    <img src="files/validation_en017.png" alt="validation_en017.png" title="validation_en017.png">
    <div class="wiki" style="display: block;"> Your validation is implemented
      correctly with <i>@EntityValidator</i>. It's not difficult, but a little
      “verbose”, because you need to write a “fully featured” new class merely
      to add 2 lines of code logic. Let's learn other ways to do the same
      validation.<br>
      <h3 id="toc4"><a name="Lesson 6: Advanced validation-Validation alternatives-Validating with a JPA callback method"></a>Validating
        with a JPA callback method</h3>
      We're going to try another, maybe even simpler, way to do this validation,
      we'll transfer the validation logic from the validator class into the <em>Order</em>
      entity itself, in this case in a <i>@PrePersist</i> and <i>@PreUpdate</i>
      method.<br>
      First, remove the <em>DeliveredToBeInInvoiceValidator</em> class from
      your project. Then remove the <i>@EntityValidator</i> annotation from
      your <em>Order</em> entity:<br>
      <pre><code class="java">//@EntityValidator( // Remove the '@EntityValidator' annotation
//    value=com.yourcompany.invoicing.validators.DeliveredToBeInInvoiceValidator.class,
//    properties= {
//        @PropertyValue(name="year"),
//        @PropertyValue(name="number"),
//        @PropertyValue(name="invoice"),
//        @PropertyValue(name="delivered")
//    }
//)
public class Order extends CommercialDocument {
</code></pre> After that we're going to add the validation again, but now inside
      the <em>Order</em> class itself. Add the <em>validate()</em> method to
      your <em>Order</em> class:<br>
      <pre><code class="java">@PrePersist @PreUpdate // Just before creating or updating
private void validate()  throws Exception {
    if (invoice != null &amp;&amp; !isDelivered()) { // The validation logic
        // The validation exception from Bean Validation
        throw new javax.validation.ValidationException(
            XavaResources.getString(
                "order_must_be_delivered",
                getYear(),
                getNumber()
            )
        );
    }
}
</code></pre>Before saving an order this validation will be executed, if it
      fails a <i>ValidationException</i> is thrown. This exception is from the
      <em>Bean Validation</em> framework, so OpenXava knows that it is a
      validation exception. This way with only one method within your entity you
      have the validation done.</div>
    <div class="wiki" style="display: block;">Only one <i>@PrePersist</i>
      method and one <i>@PreUpdate</i> method by entity are allowed, so before
      executing the above code you have to comment the <i>@PrePersiste and
        @PreUpdate</i> annotations you have in <i>recalculateDeliveryDays()</i>,
      in this way:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">// @PrePersist @PreUpdate // Comment these annotations
private void recalculateDeliveryDays() {
    setDeliveryDays(getEstimatedDeliveryDays());
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Don't worry, we'll uncomment these
      annotations later. Although JPA only allows one <i>@PrePersist</i>/<i>@PreUpdate</i>
      method you always can create a unique callback method and call all other
      methods from it, but not needed for our case, because we're not going to
      keep this validation style as definitive.</div>
    <div class="wiki" style="display: block;">Now, try to add orders not
      delivered to an invoice and see the validation errors, like in our first
      example.<br>
      <h3 id="toc5"><a name="Lesson 6: Advanced validation-Validation alternatives-Validating in the setter"></a>Validating
        in the setter</h3>
      Another alternative to do your validation is to put the validation logic
      inside the setter method. That's a simple approach. </div>
    <div class="wiki" style="display: block;">First, put back again the <i>@PrePersist</i>
      and <i>@PreUpdate</i> annotations in <i>recalculateDeliveryDays(), also
      </i>remove the <em>validate()</em> method from the <em>Order</em>
      entity:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@PrePersist @PreUpdate // Add back the callback annotations
private void recalculateDeliveryDays() {
    setDeliveryDays(getEstimatedDeliveryDays());
}
    
// Remove the validate() method

// @PrePersist @PreUpdate // Just before creating or updating
// private void validate()  throws Exception {
//     if (invoice != null &amp;&amp; !isDelivered()) { // The validation logic
//         // The validation exception from Bean Validation
//         throw new javax.validation.ValidationException(
//             XavaResources.getString( 
//                 "order_must_be_delivered",
//                 getYear(),
//                 getNumber()
//             )
//         );
//     }
// }    
</code></pre> </div>
    <div class="wiki" style="display: block;">Then add the next <em>setInvoice()</em>
      setter method to <i>Order</i>:<br>
      <pre><code class="java">public void setInvoice(Invoice invoice) {
    if (invoice != null &amp;&amp; !isDelivered()) { // The validation logic
        // The validation exception from Bean Validation
        throw new javax.validation.ValidationException(
            XavaResources.getString(
                "order_must_be_delivered",
                getYear(),
                getNumber()
            )
        );
    }
    this.invoice = invoice; // The regular setter assignment
}
</code></pre> This works exactly the same way as the two other options. This is
      like the <i>@PrePersist/@PreUpdate</i> alternative, only that it does not
      depend on JPA, it's a basic Java implementation.<br>
      <h3 id="toc6"><a name="Lesson 6: Advanced validation-Validation alternatives-Validating with Bean Validation"></a>Validating
        with <em>Bean Validation</em></h3>
      As a last option we are going to do the shortest one: The validation logic
      is put into a boolean method annotated with the <i>@AssertTrue</i> Bean
      Validation annotation.<br>
      To implement this alternative first remove the <em>setInvoice()</em>
      method:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">// Remove the setter method

// public void setInvoice(Invoice invoice) {
//    if (invoice != null &amp;&amp; !isDelivered()) { // The validation logic
//        // The validation exception from Bean Validation
//        throw new javax.validation.ValidationException(
//            XavaResources.getString(
//                "order_must_be_delivered",
//                getYear(),
//                getNumber()
//            )
//        );
//    }
//    this.invoice = invoice; // The regular setter assignment
// }
</code></pre> </div>
    <div class="wiki" style="display: block;"> Then add the <em>isDeliveredToBeInInvoice()</em>
      method to your <em>Order</em> entity:<br>
      <pre><code class="java">@AssertTrue( // Before saving it asserts if this method returns true, if not it throws an exception
    message="order_must_be_delivered" // Error message in case false
)
private boolean isDeliveredToBeInInvoice() {
    return invoice == null || isDelivered(); // The validation logic
}
</code></pre> </div>
    <div class="wiki" style="display: block;"><br>
    </div>
    <div class="wiki" style="display: block;">In previous forms of validation
      our error message was constructed using two arguments, <em>year</em> and
      <em>number</em>, which in our i18n file are represented by <em>{0}/{1}</em>
      respectively. For the validation case with <i>@AssertTrue</i> we can not
      pass these two arguments to construct our error message, but we can
      declare properties and qualified properties of the validated bean in the
      definition of the message, for that change in <em>Invoicing-messages_en.properties</em>
      the entry:<br>
      <pre><code class="properties">order_must_be_delivered=Order {0}/{1} must be delivered in order to be added to an Invoice
</code></pre> </div>
    <div class="wiki" style="display: block;">By:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="properties">order_must_be_delivered=Order {year}/{number} must be delivered in order to be added to an Invoice
</code></pre> </div>
    <div class="wiki" style="display: block;">Note as we change <i>{0}/{1}</i>
      by <i>{year}/{number}</i>. OpenXava will fill <em>{year}/{number}</em>
      with values of <em>year</em> and <em>number</em> that has the <em>Order</em>
      being updated and does not fulfill the condition of validation.<br>
      This is the simplest way to validate, because the method with the
      validation only has to be annotated. The Bean Validation is responsible
      for calling this method when saving takes place, and throws the
      corresponding <i>ValidationException</i> if the validation does not
      succeed.<br>
      <h3 id="toc7"><a name="Lesson 6: Advanced validation-Validation alternatives-Validating on removal with @RemoveValidator"></a>Validating
        on removal with <em>@RemoveValidator</em></h3>
      The validations we have seen until now are processed when the entity is
      modified, but sometimes it's useful or it's required to process the
      validation before the removal of the entity, and to use the validation to
      cancel the entity removal.<br>
      We are going to modify the application to reject the removal of an order
      if it has an invoice associated. To achieve this annotate your <em>Order</em>
      entity with <i>@RemoveValidator</i>, as show in following code:<br>
      <pre><code class="java">@RemoveValidator(com.yourcompany.invoicing.validators.OrderRemoveValidator.class) // The class with the validation
public class Order extends CommercialDocument {
</code></pre>Now, before removing an order the logic in <em>OrderRemoveValidator</em>
      is executed, and if validation fails the order is not removed. Let's look
      at the code for the validator:<br>
      <pre><code class="java">package com.yourcompany.invoicing.validators; // In 'validators' package

import com.yourcompany.invoicing.model.*;
import org.openxava.util.*;
import org.openxava.validators.*;
 
public class OrderRemoveValidator
    implements IRemoveValidator { // Must implement IRemoveValidator
 
    private Order order;
 
    public void setEntity(Object entity) // The entity to remove will be injected
        throws Exception // with this method before validating
    {
        this.order = (Order) entity;
    }
 
    public void validate(Messages errors) // The validation logic
        throws Exception
    {
        if (order.getInvoice() != null) {
            // By adding messages to errors the validation
            // will fail and the removal will be aborted
            errors.add("cannot_delete_order_with_invoice");
        }
    }
}
</code></pre> The validation logic is in the <i>validate()</i> method. Before
      calling the entity to be validated, it is injected using <i>setEntity()</i>.
      If messages are added to the <i>errors</i> object the validation will
      fail and the entity will not be removed. You have to add the error message
      in the <em>Invoicing/i18n/Invoicing-messages_en.properties</em> file:<br>
      <pre><code class="properties">cannot_delete_order_with_invoice=An order with an invoice cannot be deleted
</code></pre> If you try to remove an order with an associated invoice now, you
      will get an error message and the removal will be rejected.<br>
      You can see that using a <i>@RemoveValidator</i> is not difficult but
      verbose. You have to write a full new class to add a simple if. Let's
      examine a briefer alternative.<br>
      <h3 id="toc8"><a name="Lesson 6: Advanced validation-Validation alternatives-Validating on removal with a JPA callback method"></a>Validating
        on removal with a JPA callback method</h3>
      We're going to try another, maybe simpler, way to do this removal
      validation just by moving the validation logic from the validator class to
      the <em>Order</em> entity itself, in this case in a <i>@PreRemove</i>
      method.<br>
      First, remove the <em>OrderRemoveValidator</em> class from your project.
      Also remove the <i>@RemoveValidator</i> annotation from your <em>Order</em>
      entity:<br>
      <pre><code class="java">//@RemoveValidator(com.yourcompany.invoicing.validators.OrderRemoveValidator.class) // Remove the @RemoveValidator
public class Order extends CommercialDocument {
</code></pre> We have just removed the validation. Let's add the functionality
      again, but now inside the <em>Order</em> class itself. Add the <em>validateOnRemove()</em>
      method in your <em>Order</em> class:<br>
      <pre><code class="java">@PreRemove // Just before removing the entity
private void validateOnRemove() {
    if (invoice != null) { // The validation logic
        throw new javax.validation.ValidationException( // Throws a runtime exception
            XavaResources.getString( // To get the text message
                "cannot_delete_order_with_invoice"));
    }
}
</code></pre> This validation will be processed before the removal of an order.
      If it fails a <i>ValidationException</i> is thrown. You can throw any
      runtime exception in order to abort the removal. You have done the
      validation with a single method inside the entity.<br>
      <h3 id="toc9"><a name="Lesson 6: Advanced validation-Validation alternatives-What's the best way of validating?"></a>What's
        the best way of validating?</h3>
      You have learned several ways to do validations in your model classes.
      Which of them is the best one? All of them are valid options. It depends
      on your circumstances and personal preferences. If you have a validation
      that is non-trivial and reusable across your application, then to use <i>@EntityValidator</i>
      and <i>@RemoveValidator</i> is a good option. On the other hand, if you
      want to use your model classes from outside OpenXava and without JPA, then
      the use of validation in setters is better.<br>
      In our example we'll use the <i>@AssertTrue</i> for the “delivered to be
      in invoice” validation and <i>@PreRemove</i> for the removal validation,
      because this is the simplest procedure.<br>
      <h2 id="toc10"><a name="Lesson 6: Advanced validation-Creating your own Bean Validation annotation"></a>Creating
        your own <em>Bean Validation</em> annotation</h2>
      The techniques in the previous section are very useful for many
      validations. Nevertheless, sometimes you will face some validations that
      are very generic and you will want to reuse them over and over again. In
      this case to define your own <em>Bean Validation</em> annotation can be a
      good option. Defining a <em>Bean Validation</em> is more verbose but
      usage and reuse is simple; just adding an annotation to your property or
      class.<br>
      We are going to learn how to create a validator from <em>Bean Validation</em>.<br>
      <h3 id="toc11"><a name="Lesson 6: Advanced validation-Creating your own Bean Validation annotation-Using a Bean Validation from your entity"></a>Using
        a <em>Bean Validation</em> from your entity</h3>
      It is very easy. Just annotate your property, as you see in the next code:<br>
      <pre><code class="java">@ISBN // This annotation indicates this property must be validated as an ISBN
String isbn;
</code></pre> By merely adding <em>@ISBN</em> to your property, it will be
      validated before the entity is saved into the database. Great! The problem
      is that <em>@ISBN</em> is not included as a built-in constraint in the
      Bean Validation framework. This is not a big deal. If you want an <em>@ISBN</em>
      annotation, just create it. Indeed, we are going to create the <em>@ISBN</em>
      validation annotation in this section.<br>
      First of all, let's add a new <em>isbn</em> property to <em>Product</em>.
      Edit your <em>Product</em> class and add to it the code bellow:<br>
      <pre><code class="java">@Column(length=13)
String isbn;
</code></pre> Try out your <em>Product</em> module with the browser. Yes, the <em>isbn</em>
      property is already there. Now, you can add the validation.<br>
      <h3 id="toc12"><a name="Lesson 6: Advanced validation-Creating your own Bean Validation annotation-Defining your own ISBN annotation"></a>Defining
        your own ISBN annotation</h3>
      Let's create the <em>@ISBN</em> annotation. First, create a package in
      your project called <em>com.yourcompany.invoicing.annotations</em>. Then
      click with the right mouse button on it and choose <i>New &gt; Annotation</i>,
      as following:<br>
      <img src="files/validation_en020.png" alt="validation_en020.png" title="validation_en020.png"></div>
    <div class="wiki" style="display: block;">It will show a dialog, type ISBN
      for the annotation name and click on <i>Finish</i>:</div>
    <img src="files/validation_en030.png" alt="validation_en030.png" title="validation_en030.png">
    <div class="wiki" style="display: block;"> Edit the code of your recently
      created ISBN annotation and leave it as in the next code:<br>
      <pre><code class="java">package com.yourcompany.invoicing.annotations; // In 'annotations' package

import java.lang.annotation.*;
import javax.validation.*;
 
@Constraint(validatedBy = com.yourcompany.invoicing.validators.ISBNValidator.class)
@Target({ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface ISBN { // A regular Java annotation definition
 
    Class&lt;?&gt;[] groups() default{};
    Class&lt;? extends Payload&gt;[] payload() default{};
    String message() default "isbn_invalid"; // Message id from i18n file
}
</code></pre> As you can see, this is a regular annotation definition. The <i>message</i>
      attribute is the message to show to the user if the validation fails, you
      can write the message "as is" or put an i18n id. The developer can specify
      its own message when he uses the annotation, although we provide one by
      default, "isbn_invalid", so we have to add the next entry into <em>Invoicing-messages_en.properties</em>:
      <div class="wiki" style="display: block;">
        <pre><code class="properties">isbn_invalid=ISBN invalid or nonexistent
</code></pre> </div>
    </div>
    <div class="wiki" style="display: block;">The <i>@Constraint</i> indicates
      the class with the validation logic. Let's write the <em>ISBNValidator</em>
      class.<br>
      <h3 id="toc13"><a name="Lesson 6: Advanced validation-Creating your own Bean Validation annotation-Using Apache Commons Validator to implement the validation logic"></a>Using
        Apache Commons Validator to implement the validation logic</h3>
      We are going to write the <em>ISBNValidator</em> class with the
      validation logic for an ISBN. Instead of writing the ISBN validation logic
      by ourselves we'll use the <a href="http://commons.apache.org/validator/">Commons
        Validator</a> project from Apache. Commons Validator contains validation
      algorithms for email addresses, dates, URLs and so on. The <em>commons-validator.jar</em>
      is included by default in OpenXava projects, so you can use it without
      further configuration. The code for <em>ISBNValidator</em>:<br>
      <pre><code class="java">package com.yourcompany.invoicing.validators; // In 'validators' package

import javax.validation.*;
 
import com.yourcompany.invoicing.annotations.*;
import org.openxava.util.*;
 
public class ISBNValidator
    implements ConstraintValidator&lt;ISBN, Object&gt; { // Must implement ConstraintValidator
 
    private static org.apache.commons.validator.routines.ISBNValidator
        validator = // From 'Commons Validator' framework
            new org.apache.commons.validator.routines.ISBNValidator();
 
    public void initialize(ISBN isbn) {
 
    }
 
    // Contains the validation logic
    public boolean isValid(Object value, ConstraintValidatorContext context) { 
        if (Is.empty(value)) return true;
        return validator.isValid(value.toString()); // Relies on 'Commons Validator'
    }
}
</code></pre> As you see, the validator class must implement <i>ConstraintValidator</i>
      from the <em>javax.validation</em> package. This forces your validator to
      implement <i>initialize()</i> and <i>isValid()</i>. The <i>isValid()</i>
      method contains the validation logic. Note that if the value to validate
      is empty we assume that it is valid. Validating when the value is present
      is the responsibility of other annotations like <i>@Required</i>.<br>
      In this case the validation logic is plain vanilla, because we only call
      the ISBN validator from the Apache Commons Validator project.</div>
    <div class="wiki" style="display: block;"> <em>@ISBN</em> is ready to be
      used. Just annotate your isbn property with it. You can see how:<br>
      <pre><code class="java">@Column(length=13) @ISBN
String isbn;
</code></pre>In this case when you save the class the import for <i>@ISBN</i>
      is not added automatically. This is because there is another <i>@ISBN</i>
      available (from Hibernate Validator library included in OpenXava), so
      OpenXava Studio does not know which one to choose. Don't worry, just put
      your mouse over the <i>@ISBN</i> annotation and a popup will be shown
      with several possible solutions, choose <i>Import 'ISBN'
        (com.yourcompany.invoicing.annotations)</i> so the correct import will
      be added to <i>Product</i> class:</div>
    <div class="wiki" style="display: block;"> <img src="files/validation_en035.png"

        alt="validation_en035.png" title="validation_en035.png"> </div>
    <div class="wiki" style="display: block;"> Now, you can test your module,
      and verify that the ISBN values you enter are validated correctly.
      Congratulations, you have written your first <em>Bean Validation</em>.
      It's not so difficult. One annotation, one class.<br>
      This <em>@ISBN</em> is good enough for use in real life. Nevertheless,
      we'll try to improve it, simply to have the chance to experiment with a
      few interesting possibilities.</div>
    <div class="wiki" style="display: block;">
      <h3 id="toc14"><a name="Lesson 6: Advanced validation-Creating your own Bean Validation annotation-Call to a REST web service to validate the ISBN"></a>Call
        to a REST web service to validate the ISBN</h3>
      Though most validators have simple logic, you can create validator with
      complex logic if necessary. For example, in the case of our ISBN, we want,
      not only to verify the correct format, but also to check that a book with
      that ISBN actually exists. A way to do this is by using web services.<br>
      As you already know, a web service is a functionality hosted in web
      servers and can be called by a program. The traditional way to develop and
      use web services is by means of WS-* standards, like SOAP, UDDI, etc.,
      although, the simplest way to develop services today is REST. The basic
      idea of REST is to use the already existing “way to work” of the internet
      for inter-program communication. Calling a REST service consists of using
      a regular web URL to get a resource from a web server; this resource is
      usually data in XML, HTML, JSON or any other format. In other words, the
      programs use the internet just as regular users with their browsers.<br>
      There are a lot of sites with SOAP and REST web services that enable us to
      consult a book ISBN, we're going to use <a href="https://openlibrary.org/">openlibrary.org</a>
      that provides a free REST API to consult its book catalog. To try the Open
      Library API open a browser and go to the next URL:</div>
    <div class="wiki" style="display: block;"><a href="https://openlibrary.org/api/books?jscmd=data&amp;format=json&amp;bibkeys=ISBN:9780932633439">https://openlibrary.org/api/books?jscmd=data&amp;format=json&amp;bibkeys=ISBN:9780932633439</a></div>
    <div class="wiki" style="display: block;">Where the last parameter is the
      ISBN of the book, from it you will get a JSON with the data of the book,
      something like this:</div>
    <img src="files/validation040.png" alt="validation040.png" title="validation040.png">
    <div class="wiki" style="display: block;">A JSON is just data with key/value
      using {} and [] for nesting and repeating. If you try to get the data of a
      non-existen book, like in this URL:</div>
    <div class="wiki" style="display: block;"><a href="https://openlibrary.org/api/books?jscmd=data&amp;format=json&amp;bibkeys=ISBN:9791034369997">https://openlibrary.org/api/books?jscmd=data&amp;format=json&amp;bibkeys=ISBN:9791034369997</a></div>
    <div class="wiki" style="display: block;">You'll get an empty JSON, like
      this:</div>
    <img src="files/validation050.png" alt="validation050.png" title="validation050.png"><span

      style="color: #505050;"><span style="font-family: arial,helvetica,sans-serif;"></span></span>
    <div class="wiki" style="display: block;">That is, an empty JSON, just {}.</div>
    <div class="wiki" style="display: block;">To call this web service we'll use
      JAX-RS. JAX-RS is the Java standard to call REST web services. OpenXava
      includes support to call web services using JAX-RS, so you don't need to
      add any additional library.<br>
      Let's modify <em>ISBNValidator</em> to use this <em>REST</em> service.
      See the result:<br>
      <pre><code class="java">package com.yourcompany.invoicing.validators; 

import javax.validation.*;
import javax.ws.rs.client.*; // To use JAX-RS
import com.yourcompany.invoicing.annotations.*;
import org.apache.commons.logging.*; // To use Log
import org.openxava.util.*;
 
public class ISBNValidator
    implements ConstraintValidator&lt;ISBN, Object&gt; {
	
    private static Log log = LogFactory.getLog(ISBNValidator.class); // Instantiate 'log'
 
    private static org.apache.commons.validator.routines.ISBNValidator
        validator = 
            new org.apache.commons.validator.routines.ISBNValidator();
 
    public void initialize(ISBN isbn) {
 
    }
 
    public boolean isValid(Object value, ConstraintValidatorContext context) {
        if (Is.empty(value)) return true;
        if (!validator.isValid(value.toString())) return false;
        return isbnExists(value); // Here we do the REST call
    }
    
    private boolean isbnExists(Object isbn) {
        try {
            // Here we use JAX-RS to call a REST service
            String response = ClientBuilder.newClient()
                .target("http://openlibrary.org/") // The site
                .path("/api/books") // The path of the service
                .queryParam("jscmd", "data") // Parameters
                .queryParam("format", "json")
                .queryParam("bibkeys", "ISBN:" + isbn) // The ISBN is a parameter
                .request()
                .get(String.class); // A String with the JSON
            return !response.equals("{}"); // Is the JSON empty? Enough for our case.
        }
        catch (Exception ex) {
            log.warn("Impossible to connect to openlibrary.org " +
                "to validate the ISBN. Validation fails", ex);
            return false; // If there are errors we assume that validation fails
        }
    }
    
}
</code></pre> We simply open the URL with the ISBN as the request parameter. If
      the resulting JSON is an empty JSON, that is {}, the search has failed,
      otherwise we have found the book. For this case, getting the JSON as a <i>String</i>
      to do a simple comparison is the simplest approach, however JAX-RS could
      parse the JSON as a Java object of your own class (<i>Book</i> for
      example) filling the corresponding properties, just use <i>.get(Book.class)</i>
      instead of <i>.get(String.class)</i> as last line of the call.<br>
      Try out your application now and you'll see that the validation will fail
      if you enter a non-existent ISBN.<br>
      <h3 id="toc15"><a name="Lesson 6: Advanced validation-Creating your own Bean Validation annotation-Adding attributes to your annotation"></a>Adding
        attributes to your annotation</h3>
      It's a good idea to create a new <em>Bean Validation</em> annotation if
      you reuse the validation several times, usually across several projects.
      To improve the reusability you may want to parametrize the validation
      code. For example, for your current project to do the search in <a href="https://openlibrary.org/">openlibrary.org</a>
      for ISBN is OK, but in another project, or even in another entity of your
      current project, you do not want to call this particular URL. The code of
      the annotation has to be more flexible.<br>
      This flexibility can be achieved by attributes. For example, we can add a
      boolean search attribute to our <i>ISBN</i> annotation in order to switch
      on or off the internet search for validation. To implement this
      functionality, just add the <em>search</em> attribute to the <i>ISBN</i>
      annotation code:<br>
      <pre><code class="java">public @interface ISBN {
    boolean search() default true; // To (de)activate web search on validate
 
    // ...
}
</code></pre> This new search attribute can be read from the validator class:<br>
      <pre><code class="java">public class ISBNValidator implements ConstraintValidator&lt;ISBN, Object&gt; {
    // ...
    private boolean search; // Stores the search option
 
    public void initialize(ISBN isbn) { // Read the annotation attributes values
        this.search = isbn.search();
    }
 
    public boolean isValid(Object value, ConstraintValidatorContext context) {
        if (Is.empty(value)) return true;
        if (!validator.isValid(value.toString())) return false;
        return search ? isbnExists(value) : true; // Using 'search'
    }
    // ...
}
</code></pre> Here you see the use of the <i>initialize()</i> method: the
      source annotation can be used to initialize the validator, in this case
      simply by storing the <em>isbn.search()</em> value to evaluate it in <i>isValid()</i>.<br>
      Now you can choose whether you want to call our REST service or skip the
      ISBN validation:<br>
      <pre><code class="java">@ISBN(search=false) // In this case no internet search is done to validate the ISBN
private String isbn;
</code></pre> Using this simple method you can add any attribute you need to add
      more flexibility to your ISBN annotation.<br>
      <br>
      Congratulations! You have learned how to create your own <em>Bean
        Validation</em> annotation, and by the way, to use JAX-RS for calling
      REST services.<br>
      <h2 id="toc20"><a name="Lesson 6: Advanced validation-Summary"></a>Summary</h2>
      In this lesson you have learned several ways to do validation in an
      OpenXava application. Also, you know how to encapsulate the reusable
      validation logic in annotations with custom Bean Validation.<br>
      Validation is an important part of the logic of your application, and we
      encourage you to put it into the model, i. e. into your entities. We
      demonstrated several examples for this technique in the lesson. Sometimes
      it is more convenient to put logic outside your model classes. You will
      learn that in the next lessons.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-6-validation_en.zip/download"

          rel="nofollow">Download source code of this lesson</a></strong><br>
      <br>
      <strong>Any problem with this lesson? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/419690/"

          rel="nofollow">Ask in the forum</a></strong> <strong>Everything fine?
        <a class="wiki_link" href="refining-standard-behavior_en.html">Go to
          Lesson 13</a></strong> </div>
    
  </body>
</html>
