<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lección 11: Métodos de retrollamadas JPA - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" style="display: block;">
      <h1 id="toc0"><a name="Leccion-5-Logica-de-negocio-basica"></a> <span id="breadcrumbs">
          <span id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava
              </a> </span> / <a href="index_es.html">documentación</a> / </span>
        Lección 11: Métodos de retrollamadas JPA</h1>
      <strong>Curso</strong>: <a class="wiki_link" href="getting-started_es.html">1.
        Primeros pasos</a> | <a class="wiki_link" href="basic-domain-model1_es.html">2.
        Modelo básico del dominio (1)</a> | <a class="wiki_link" href="basic-domain-model2_es.html">3.
        Modelo básico del dominio (2)</a> | <a class="wiki_link" href="refining-user-interface_es.html">4.
        Refinar la interfaz de usuario</a> | <a class="wiki_link" href="agile-development_es.html">5.
        Desarrollo ágil</a> | <a class="wiki_link" href="mapped-superclass-inheritance_es.html">6.
        Herencia de superclases mapedas</a> | <a class="wiki_link" href="entity-inheritance_es.html">7.
        Herencia de entidades</a> | <a class="wiki_link" href="view-inheritance_es.html">8.
        Herencia de vistas</a> | <a class="wiki_link" href="java-properties_es.html">9.
        Propiedades Java</a> | <a class="wiki_link" href="total-properties-with-calculation_es.html">10.
        Propiedades de total con Calculation</a> | <strong>11. Métodos de
        retrollamadas JPA</strong> | <a class="wiki_link" href="validation_es.html">12.
        Validación avanzada</a> | <a class="wiki_link" href="refining-standard-behavior_es.html">13.
        Refinar el comportamiento predefinido</a> | <a class="wiki_link" href="business-logic-behavior_es.html">14.
        Comportamiento y lógica del negocio</a> | <a class="wiki_link" href="philosophy_es.html">A.
        Arquitectura y filosofía</a> | <a class="wiki_link" href="references-collections_es.html">14.
        Referencias y colecciones</a> | <a class="wiki_link" href="jpa_es.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_es.html">C.
        Anotaciones</a> | <a class="wiki_link" href="testing_es.html">D.
        Pruebas automáticas</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">Tabla de contenidos</h1>
        <div style="margin-left: 1em;"><a href="#Leccion-5-Logica-de-negocio-basica">Lección
            11: Métodos de retrollamadas JPA<br>
          </a></div>
        <div style="margin-left: 2em;"><a href="#Metodos-de-retrollamadas-JPA">Métodos
            de retrollamadas JPA</a></div>
        <div style="margin-left: 3em;"><a href="#Metodos-de-retrollamadas-JPA-Calculo-de-valor-por-defecto-multiusuario">Cálculo
            de valor por defecto multiusuario</a></div>
        <div style="margin-left: 3em;"><a href="#Metodos-de-retrollamadas-JPA-Sincronizar-propiedades-persistentes-y-calculadas">Sincronizar
            propiedades persistentes y calculadas</a></div>
        <div style="margin-left: 2em;"><a href="#Logica-desde-la-base-de-datos-Formula">Lógica
            desde la base de datos (@Formula)</a></div>
        <div style="margin-left: 2em;"><a href="#Resumen">Resumen</a></div>
      </div>
      Nuestra Aplicación ya trabaja con propiedades calculadas y persistentes
      para manejar valores, con una estrucutura lógica básica. Veremos ahora
      como mejorar aún más dicha lógica. <br>
      <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: medium; color: rgb(80, 80, 80); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; display: block;">
        <h2 id="toc6" style="font-weight: bold; padding: 5px 0px 0px; margin: 0px; font-size: 1.3em;">Métodos
          de retrollamadas JPA</h2>
        Otra forma práctica de añadir lógica de negocio a tu modelo es mediante
        los métodos de retrollamada JPA. Un método de retrollamada se llama en
        un momento específico del ciclo de vida de la entidad como objeto
        persistente. Es decir, puedes especificar cierta lógica a ejecutar al
        grabar, leer, borrar o modificar una entidad.<br>
        En esta sección veremos algunas aplicaciones prácticas de los métodos de
        retrollamada JPA.<br>
        <h3 id="toc7" style="font-weight: bold; padding: 5px 0px 0px; margin: 0px; font-size: 1.1em;"><a
            name="Metodos-de-retrollamadas-JPA-Calculo-de-valor-por-defecto-multiusuario"></a>Cálculo
          de valor por defecto multiusuario</h3>
        Hasta ahora estamos calculando el número para<span>&nbsp;</span><em>Factura</em><span>&nbsp;</span>y<span>&nbsp;</span><em>Pedido</em><span>&nbsp;</span>usando<span>&nbsp;</span><em>@DefaultValueCalculator</em>.
        Éste calcula el valor por defecto en el momento que el usuario pulsa
        para crear una nueva<span>&nbsp;</span><em>Factura</em><span>&nbsp;</span>o<span>&nbsp;</span><em>Pedido</em>.
        Por tanto, si varios usuarios pulsan en el botón<span>&nbsp;</span><i>Nuevo</i><span>&nbsp;</span>al
        mismo tiempo todos ellos obtendrán el mismo número. Esto no es apto para
        aplicaciones multiusuario. La forma correcta de generar un número único
        es generándolo justo en el momento de grabar.<br>
        Vamos a implementar la generación del número usando métodos de
        retrollamada JPA. JPA permite marcar cualquier método de tu clase para
        ser ejecutado en cualquier momento de su ciclo de vida. Indicaremos que
        justo antes de grabar un<span>&nbsp;</span><em>DocumentoComercial</em><span>&nbsp;</span>calcule
        su número. De paso mejoraremos el cálculo para tener una numeración
        diferente para<span>&nbsp;</span><em>Pedido</em><span>&nbsp;</span>y<span>&nbsp;</span><em>Factura</em>.<br>
        Edita la entidad<span>&nbsp;</span><em>DocumentoComercial</em><span>&nbsp;</span>y
        añade el método<span>&nbsp;</span><em>calcularNumero()</em>. Veamos el
        código:<br>
        <pre style="background-color: rgb(248, 248, 248); border: 1px solid rgb(238, 238, 238); padding: 10px; font-size: 13px; overflow-x: auto;"><code
class="java hljs" style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248); margin: -10px;"><span
class="hljs-meta" style="color: rgb(153, 153, 153); font-weight: bold;">@PrePersist</span> <span
class="hljs-comment" style="color: rgb(153, 153, 136); font-style: italic;">// Ejecutado justo antes de grabar el objeto por primera vez</span>
<span class="hljs-function"><span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">private</span> <span
class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">void</span> <span
class="hljs-title" style="color: rgb(153, 0, 0); font-weight: bold;">calcularNumero</span><span
class="hljs-params">()</span> </span>{
    Query query = XPersistence.getManager().createQuery(
        <span class="hljs-string" style="color: rgb(221, 17, 68);">"select max(f.numero) from "</span> +
        getClass().getSimpleName() + <span class="hljs-comment" style="color: rgb(153, 153, 136); font-style: italic;">// De esta forma es válido para Factura y Pedido</span>
        <span class="hljs-string" style="color: rgb(221, 17, 68);">" f where f.anyo = :anyo"</span>);
    query.setParameter(<span class="hljs-string" style="color: rgb(221, 17, 68);">"anyo"</span>, anyo);
    Integer ultimoNumero = (Integer) query.getSingleResult();
    <span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">this</span>.numero = ultimoNumero == <span
class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">null</span> ? <span
class="hljs-number" style="color: rgb(0, 128, 128);">1</span> : ultimoNumero + <span
class="hljs-number" style="color: rgb(0, 128, 128);">1</span>;
}
</code></pre></div>
      <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: medium; color: rgb(80, 80, 80); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; display: block;">Este
        código es el mismo que el de<span>&nbsp;</span><em>CalculadorSiguienteNumeroParaAnyo</em><span>&nbsp;</span>pero
        usando<span>&nbsp;</span><em>getClass().getSimpleName()</em><span>&nbsp;</span>en
        lugar de "DocumentoComercial". El método<span>&nbsp;</span><em>getSimpleName()</em><span>&nbsp;</span>devuelve
        el nombre de la clase sin paquete, es decir, precisamente el nombre de
        la entidad. Será "Pedido" para<span>&nbsp;</span><em>Pedido</em><span>&nbsp;</span>y
        "Factura" para<span>&nbsp;</span><em>Factura</em>. Así podremos obtener
        una numeración diferente para<span>&nbsp;</span><em>Factura</em><span>&nbsp;</span>y<span>&nbsp;</span><em>Pedido</em>.<br>
        La especificación JPA establece que no puedes usar el API JPA dentro de
        un método de retrollamada. Por tanto, el método de arriba no es legal
        desde un punto de vista estricto. Pero, Hibernate (la implementación de
        JPA que OpenXava usa por defecto) te permite usarla en<span>&nbsp;</span><em>@PrePersist</em>.
        Y dado que usar JPA es la forma más fácil de hacer este cálculo,
        nosotros lo usamos.<br>
        Ahora borra la clase<span>&nbsp;</span><em>CalculadorSiguienteNumeroParaAnyo</em><span>&nbsp;</span>de
        tu proyecto y modifica la propiedad<span>&nbsp;</span><em>numero</em><span>&nbsp;</span>de<span>&nbsp;</span><em>DocumentoComercial</em><span>&nbsp;</span>para
        que no la use:<br>
        <pre style="background-color: rgb(248, 248, 248); border: 1px solid rgb(238, 238, 238); padding: 10px; font-size: 13px; overflow-x: auto;"><code
class="java hljs" style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248); margin: -10px;"><span
class="hljs-meta" style="color: rgb(153, 153, 153); font-weight: bold;">@Column</span>(length = <span
class="hljs-number" style="color: rgb(0, 128, 128);">6</span>)
<span class="hljs-comment" style="color: rgb(153, 153, 136); font-style: italic;">//  @DefaultValueCalculator(value=CalculadorSiguienteNumeroParaAnyo.class, // Quita esto</span>
<span class="hljs-comment" style="color: rgb(153, 153, 136); font-style: italic;">//      properties=@PropertyValue(name="anyo")</span>
<span class="hljs-comment" style="color: rgb(153, 153, 136); font-style: italic;">//  )</span>
<span class="hljs-meta" style="color: rgb(153, 153, 153); font-weight: bold;">@ReadOnly</span> <span
class="hljs-comment" style="color: rgb(153, 153, 136); font-style: italic;">// El usuario no puede modificar el valor</span>
<span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">int</span> numero;
</code></pre>Fíjate que además de quitar<span>&nbsp;</span><em>@DefaultValueCalculator</em>,
        hemos añadido la anotación<span>&nbsp;</span><em>@ReadOnly</em>. Esto
        significa que el usuario no puede introducir ni modificar este número.
        Esta es la forma correcta de hacerlo ahora dado que el número es
        generado al grabar el objeto, por lo que el valor que tecleara el
        usuario sería sobrescrito siempre.<br>
        Prueba ahora el módulo de<span>&nbsp;</span><em>Factura</em><span>&nbsp;</span>o<span>&nbsp;</span><em>Pedido</em>,
        verás como el número está vacío y no es editable, y cuando grabes el
        documento, el número se calcula y se muestra un mensaje con el año y el
        número recién calculado para esa factura o pedido.<br>
        <h3 id="toc8" style="font-weight: bold; padding: 5px 0px 0px; margin: 0px; font-size: 1.1em;"><a
            name="Metodos-de-retrollamadas-JPA-Sincronizar-propiedades-persistentes-y-calculadas"></a>Sincronizar
          propiedades persistentes y calculadas</h3>
        Como ya hemos aprendido, las propiedades calculadas no permiten filtrar
        ni ordenar en la lista, por lo que preferimos propiedades transitorias
        con<span>&nbsp;</span><i>@Calculation</i>. Sin embargo, las propiedades<span>&nbsp;</span><i>@Calculation</i><span>&nbsp;</span>sólo
        sirven para cálculos aritméticos simples. Cuando necesitas bucles,
        condiciones, leer de la base de datos, conectar a servicios externos o
        cualquier lógica compleja,<span>&nbsp;</span><i>@Calculation</i><span>&nbsp;</span>no
        es suficiente. Para estos casos necesitas escribir la lógica con Java,
        en el getter. Pero, ¿cómo podemos hacer esto y al mismo tiempo mantener
        la ordenación y el filtrado en la lista? Fácil, puedes usar dos
        propiedades, una calculada y otra persistente, y mantenerlas
        sincronizadas usando los métodos de retrollamada de JPA. Vamos a
        aprender como hacerlo en esta sección.
        <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: 16px; color: rgb(80, 80, 80); display: block;">Añadamos
          un nueva propiedad a la entidad<span>&nbsp;</span><i>Pedido</i><span>&nbsp;</span>llamada<span>&nbsp;</span><i>diasEntregaEstimados</i>:</div>
        <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: 16px; color: rgb(80, 80, 80); display: block;">
          <pre style="background-color: rgb(248, 248, 248); border: 1px solid rgb(238, 238, 238); padding: 10px; font-size: 13px; overflow-x: auto;"><code
class="java hljs" style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248); margin: -10px;"><span
class="hljs-meta" style="color: rgb(153, 153, 153); font-weight: bold;">@Depends</span>(<span
class="hljs-string" style="color: rgb(221, 17, 68);">"fecha"</span>)
<span class="hljs-function"><span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">public</span> <span
class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">int</span> <span
class="hljs-title" style="color: rgb(153, 0, 0); font-weight: bold;">getDiasEntregaEstimados</span><span
class="hljs-params">()</span> </span>{
    <span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">if</span> (getFecha().getDayOfYear() &lt; <span
class="hljs-number" style="color: rgb(0, 128, 128);">15</span>) {
        <span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">return</span> <span
class="hljs-number" style="color: rgb(0, 128, 128);">20</span> - getFecha().getDayOfYear(); 
    }
    <span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">if</span> (getFecha().getDayOfWeek() == DayOfWeek.SUNDAY) <span
class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">return</span> <span
class="hljs-number" style="color: rgb(0, 128, 128);">2</span>;
    <span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">if</span> (getFecha().getDayOfWeek() == DayOfWeek.SATURDAY) <span
class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">return</span> <span
class="hljs-number" style="color: rgb(0, 128, 128);">3</span>;
    <span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">return</span> <span
class="hljs-number" style="color: rgb(0, 128, 128);">1</span>;
}
</code></pre></div>
        <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: 16px; color: rgb(80, 80, 80); display: block;">Esto
          es una propiedad calculada pura, un getter con lógica Java. Calcula
          los día estimados de entrega usando<span>&nbsp;</span><i>fecha</i><span>&nbsp;</span>como
          fuente. Este caso no puede solucionarse con<span>&nbsp;</span><i>@Calculation</i><span>&nbsp;</span>que
          solo soporta operaciones aritméticas básicas.</div>
        <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: 16px; color: rgb(80, 80, 80); display: block;">También
          hemos de añadir<span>&nbsp;</span><i>diasEntregaEstimados</i><span>&nbsp;</span>a
          la declaración de la<span>&nbsp;</span><i>@View</i><span>&nbsp;</span>por
          defecto en el código de<span>&nbsp;</span><i>Pedido</i>:</div>
        <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: 16px; color: rgb(80, 80, 80); display: block;">
          <pre style="background-color: rgb(248, 248, 248); border: 1px solid rgb(238, 238, 238); padding: 10px; font-size: 13px; overflow-x: auto;"><code
class="java hljs" style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248); margin: -10px;"><span
class="hljs-meta" style="color: rgb(153, 153, 153); font-weight: bold;">@View</span>(extendsView=<span
class="hljs-string" style="color: rgb(221, 17, 68);">"super.DEFAULT"</span>, 
    members=
        <span class="hljs-string" style="color: rgb(221, 17, 68);">"diasEntregaEstimados,"</span> + <span
class="hljs-comment" style="color: rgb(153, 153, 136); font-style: italic;">// AÑADE ESTA LÍNEA</span>
        <span class="hljs-string" style="color: rgb(221, 17, 68);">"factura { factura }"</span>
)
...
<span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">public</span> <span
class="hljs-class"><span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">class</span> <span
class="hljs-title" style="color: rgb(68, 85, 136); font-weight: bold;">Pedido</span> <span
class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">extends</span> <span
class="hljs-title" style="color: rgb(68, 85, 136); font-weight: bold;">DocumentoComercial</span> </span>{
</code></pre></div>
        <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: 16px; color: rgb(80, 80, 80); display: block;">El
          resultado es este:</div>
        <img src="https://www.openxava.org/OpenXavaDoc/docs/files/business-logic_es050.png"
          alt="business-logic_es050.png" title="business-logic_es050.png" style="margin: 10px 0px; border: 0px; padding: 4px;">
        <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: 16px; color: rgb(80, 80, 80); display: block;">El
          valor se recalcula cada vez que la fecha cambia en la interfaz de
          usuario gracias a el<span>&nbsp;</span><i>@Depends("fecha")</i><span>&nbsp;</span>en<span>&nbsp;</span><i>diasEntregaEstimados.</i><span>&nbsp;</span>Todo
          esto está muy bien, pero cuando vas a modo lista no puedes ordenar ni
          filtrar por los días de entrega estimados. Para resolver este problema
          añadimos una segunda propiedad, en esta ocasión una persistente.</div>
        <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: 16px; color: rgb(80, 80, 80); display: block;">Añade
          el siguiente código a tu entidad<span>&nbsp;</span><i>Pedido</i>:</div>
        <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: 16px; color: rgb(80, 80, 80); display: block;">
          <pre style="background-color: rgb(248, 248, 248); border: 1px solid rgb(238, 238, 238); padding: 10px; font-size: 13px; overflow-x: auto;"><code
class="java hljs" style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248); margin: -10px;"><span
class="hljs-meta" style="color: rgb(153, 153, 153); font-weight: bold;">@Column</span>(columnDefinition=<span
class="hljs-string" style="color: rgb(221, 17, 68);">"INTEGER DEFAULT 1"</span>)
<span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">int</span> diasEntrega;
</code></pre></div>
        <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: 16px; color: rgb(80, 80, 80); display: block;">Fíjate
          como hemos usado<span>&nbsp;</span><i>@Column(columnDefinition="INTEGER
            DEFAULT 1")</i>, con este truco cuando OpenXava crea la columna usa
          "INTEGER DEFAULT 1" como definición de columna, así la nueva columna
          tiene 1 como valor por defecto en lugar de nulo y evitamos un feo
          error con nuestra propiedad int. Sí, en muchos casos<span>&nbsp;</span><i>@Column(columnDefinition=)</i><span>&nbsp;</span>es
          una alternativa a hacer un UPDATE sobre la tabla (como hicimos en la
          sección "Evolución de esquema manual"), aunque tiene el problema de
          que es dependiente de la base de datos. De cualquier modo, esta
          disertación sobre<span>&nbsp;</span><i>columnDefinition</i><span>&nbsp;</span>es
          tangencial a nuestro asunto sobre sincronización entre propiedades
          calculadas y persistentes,<span>&nbsp;</span><i>@Column</i><span>&nbsp;</span>no
          llega a ser necesario, simplemente es conveniente para nuestra
          propiedad int.</div>
        <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: 16px; color: rgb(80, 80, 80); display: block;">Esta
          nueva propiedad<span>&nbsp;</span><i>diasEntrega</i><span>&nbsp;</span>contendrá
          el mismo valor que<span>&nbsp;</span><em>diasEntregaEstimados</em>,
          pero<span>&nbsp;</span><i><em>diasEntrega</em></i><span>&nbsp;</span>será
          persistente con su columna correspondiente en la base de datos. El
          truco está en mantener sincronizada la propiedad<span>&nbsp;</span><em>diasEntrega</em>.
          Usaremos los métodos de retrollamada de JPA en<span>&nbsp;</span><em>Pedido</em><span>&nbsp;</span>para
          conseguir esto. Es suficiente con asignar el valor de<span>&nbsp;</span><i>diasEntregaEstimados</i><span>&nbsp;</span>a<span>&nbsp;</span><i>diasEntrega</i><span>&nbsp;</span>cada
          vez que un nuevo<span>&nbsp;</span><i>Pedido</i><span>&nbsp;</span>se
          crea (<i>@PrePersist</i>) o modifica (<i>@PreUpdate</i>).<br>
          Añade un método<span>&nbsp;</span><i>recalcularDiasEntrega()</i><span>&nbsp;</span>a
          la entidad<span>&nbsp;</span><i>Pedido</i><span>&nbsp;</span>y anótalo
          con<span>&nbsp;</span><i>@PrePersist</i><span>&nbsp;</span>y<span>&nbsp;</span><i>@PreUpdate</i>,
          así:<br>
          <pre style="background-color: rgb(248, 248, 248); border: 1px solid rgb(238, 238, 238); padding: 10px; font-size: 13px; overflow-x: auto;"><code
class="java hljs" style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248); margin: -10px;"><span
class="hljs-meta" style="color: rgb(153, 153, 153); font-weight: bold;">@PrePersist</span> <span
class="hljs-meta" style="color: rgb(153, 153, 153); font-weight: bold;">@PreUpdate</span> 
<span class="hljs-function"><span class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">private</span> <span
class="hljs-keyword" style="color: rgb(51, 51, 51); font-weight: bold;">void</span> <span
class="hljs-title" style="color: rgb(153, 0, 0); font-weight: bold;">recalcularDiasEntrega</span><span
class="hljs-params">()</span> </span>{
    setDiasEntrega(getDiasEntregaEstimados());
}
</code></pre>Básicamente, el método<span>&nbsp;</span><i>recalcularDiasEntrega()</i><span>&nbsp;</span>se
          llama cada vez que la entidad<span>&nbsp;</span><em>Pedido</em><span>&nbsp;</span>se
          registra en la base de datos por primera vez y cuando se actualiza.</div>
        Puedes probar el módulo<span>&nbsp;</span><em>Pedido</em><span>&nbsp;</span>con
        este código y verás como cuando un pedido se crea o modifica, la columna
        en la base de datos<span>&nbsp;</span><i>diasEntrega</i><span>&nbsp;</span>se
        actualiza correctamente después de grabar, lista para usar en procesos
        masivos y disponible para filtrar y ordenar en la lista.<br>
        <h2 id="toc9" style="font-weight: bold; padding: 5px 0px 0px; margin: 0px; font-size: 1.3em;"><a
            name="Logica-desde-la-base-de-datos-Formula"></a>Lógica desde la
          base de datos (<em>@Formula</em>)</h2>
        Otra alternativa a<span>&nbsp;</span><i>@Calculation,</i><span>&nbsp;</span>o
        a tener propiedades calculadas y persistentes sincronizadas, es la
        anotación<span>&nbsp;</span><em>@Formula</em>.<span>&nbsp;</span><em>@Formula</em><span>&nbsp;</span>es
        una extensión de Hibernate al estándar JPA, que permite mapear una
        propiedad a un fragmento de SQL. Por ejemplo, puedes definir<span>&nbsp;</span><i>beneficioEstimado</i><span>&nbsp;</span>con<span>&nbsp;</span><em>@Formula</em><span>&nbsp;</span>en<span>&nbsp;</span><i>DocumentoComercial</i><span>&nbsp;</span>como
        se muestra en el siguiente código:<br>
        <pre style="background-color: rgb(248, 248, 248); border: 1px solid rgb(238, 238, 238); padding: 10px; font-size: 13px; overflow-x: auto;"><code
class="java hljs" style="display: block; overflow-x: auto; padding: 0.5em; color: rgb(51, 51, 51); background: rgb(248, 248, 248); margin: -10px;"><span
class="hljs-meta" style="color: rgb(153, 153, 153); font-weight: bold;">@org</span>.hibernate.annotations.Formula(<span
class="hljs-string" style="color: rgb(221, 17, 68);">"IMPORTETOTAL * 0.10"</span>) <span
class="hljs-comment" style="color: rgb(153, 153, 136); font-style: italic;">// El cálculo usando SQL</span>
<span class="hljs-meta" style="color: rgb(153, 153, 153); font-weight: bold;">@Setter</span>(AccessLevel.NONE) <span
class="hljs-comment" style="color: rgb(153, 153, 136); font-style: italic;">// El setter no se genera, sólo necesitamos el getter</span>
<span class="hljs-meta" style="color: rgb(153, 153, 153); font-weight: bold;">@Stereotype</span>(<span
class="hljs-string" style="color: rgb(221, 17, 68);">"DINERO"</span>)
BigDecimal beneficioEstimado; <span class="hljs-comment" style="color: rgb(153, 153, 136); font-style: italic;">// Un campo, como con una propiedad persistente</span>
</code></pre>Esto significa que cuando un<span>&nbsp;</span><em>DocumentoComercial</em><span>&nbsp;</span>se
        lea de la base de datos, el campo<span>&nbsp;</span><em>beneficioEstimado</em><span>&nbsp;</span>se
        rellenerá con el cálculo de<span>&nbsp;</span><em>@Formula</em><span>&nbsp;</span>que
        es ejecutado por la base de datos. El usuario puede filtrar y ordenar
        por las propiedades<span>&nbsp;</span><i>@Formula</i><span>&nbsp;</span>en
        modo lista, pero siempre son de solo lectura y no se recalculan en
        tiempo real en modo detalle. Dado que son de sólo lectura no necesitan
        el método getter, por lo que la hemos anotamos con<span>&nbsp;</span><i>@Setter(AccessLevel.NONE)</i><span>&nbsp;</span>para
        que Lombok no genere el setter. Además, las propiedades<span>&nbsp;</span><i>@Formula</i><span>&nbsp;</span>dependen
        de la base de datos, porque podrías usar sintaxis sólo soportada por
        cierto fabricante de base de datos.</div>
      <div class="wiki" style="line-height: 1.5; font-family: arial, helvetica, sans-serif; font-size: medium; color: rgb(80, 80, 80); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; display: block;">
        <h2 id="toc14" style="font-weight: bold; padding: 5px 0px 0px; margin: 0px; font-size: 1.3em;"><a
            name="Resumen"></a>Resumen</h2>
        En esta lección has aprendido algunas formas comunes de añadir lógica de
        negocio a tus entidades. No hay duda sobre la utilidad de las
        propiedades calculadas,<span>&nbsp;</span><i>@Calculation</i>, los
        métodos de retrollamada o<span>&nbsp;</span><em>@Formula</em>. Sin
        embargo, todavía tenemos muchas otras formas de añadir lógica a tu
        aplicación OpenXava, que vamos a aprender a usar.<br>
        En futuros lecciones verás como añadir validación, modificar el
        funcionamiento estándar del módulo y añadir tu propia lógica de negocio,
        entre otras formas de añadir lógica personalizada a tu aplicación.</div>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-5-basic-business-logic_es.zip/download"
          rel="nofollow">Descargar código fuente de esta lección</a></strong><br>
      <br>
      <strong>¿Problemas con la lección? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/437013/"
          rel="nofollow">Pregunta en el foro</a></strong> <strong>¿Ha ido bien?
        <a class="wiki_link" href="business-logic-behavior_es.html">Ve a la
          lección 12</a></strong> </div>
    <strong> </strong>
  </body>
</html>
