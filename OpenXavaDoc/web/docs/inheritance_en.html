<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lesson 4: Inheritance - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" style="display: block;">
      <h1 id="toc0"><a name="Lesson 4: Inheritance"></a>
       <span id="breadcrumbs">
          <span id="openxava">
          	<a href="https://www.openxava.org/">
              <span>o</span>pen<span>x</span>ava
            </a>
          </span>  
          / <a href="index_en.html">documentation</a> /  
				</span>
        Lesson 4: Inheritance</h1>
      <div id="toc">
        <h1 class="nopad">Table of contents</h1>
        <div style="margin-left: 1em;"><a href="#Lesson%204:%20Inheritance">Lesson
            4: Inheritance</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%204:%20Inheritance-Inheriting%20from%20a%20mapped%20superclass">Inheriting
            from a mapped superclass</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%204:%20Inheritance-Entity%20inheritance">Entity
            inheritance</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Entity%20inheritance-New%20Order%20entity">New
            Order entity</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Entity%20inheritance-CommercialDocument%20as%20an%20abstract%20entity">CommercialDocument
            as an abstract entity</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Entity%20inheritance-Invoice%20refactored%20to%20use%20inheritance">Invoice
            refactored to use inheritance</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Entity%20inheritance-Creating%20Order%20using%20inheritance">Creating
            Order using inheritance</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Entity%20inheritance-Naming%20convention%20and%20inheritance">Naming
            convention and inheritance</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Entity%20inheritance-Associating%20Order%20with%20Invoice">Associating
            Order with Invoice</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%204:%20Inheritance-View%20inheritance">View
            inheritance</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-View%20inheritance-The%20extendsView%20attribute">The
            extendsView attribute</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-View%20inheritance-View%20for%20Invoice%20using%20inheritance">View
            for Invoice using inheritance</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-View%20inheritance-View%20for%20Order%20using%20inheritance">View
            for Order using inheritance</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-View%20inheritance-Using%20@ReferenceView%20and%20@CollectionView%20to%20refine%20views">Using
            @ReferenceView and @CollectionView to refine views</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%204:%20Inheritance-Inheritance%20in%20JUnit%20tests">Inheritance
            in JUnit tests</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Inheritance%20in%20JUnit%20tests-Creating%20an%20abstract%20module%20test">Creating
            an abstract module test</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Inheritance%20in%20JUnit%20tests-Using%20the%20abstract%20module%20test%20to%20create%20concrete%20module%20tests">Using
            the abstract module test to create concrete module tests</a></div>
        <div style="margin-left: 3em;"><a href="#Lesson%204:%20Inheritance-Inheritance%20in%20JUnit%20tests-Adding%20new%20tests%20to%20the%20extended%20module%20test">Adding
            new tests to the extended module test</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%204:%20Inheritance-Summary">Summary</a></div>
      </div>
      <strong>Course</strong>: <a class="wiki_link" href="getting-started_en.html">1.
        Getting started</a> | <a class="wiki_link" href="modeling_en.html">2.
        Modeling with Java</a> | <a class="wiki_link" href="testing_en.html">3.
        Automated testing</a> | <strong>4. Inheritance</strong> | <a class="wiki_link"

        href="basic-business-logic_en.html">5. Basic business logic</a> | <a class="wiki_link"

        href="validation_en.html">6. Advanced validation</a> | <a class="wiki_link"

        href="refining-standard-behavior_en.html">7. Refining the standard
        behavior</a> | <a class="wiki_link" href="business-logic-behavior_en.html">8.
        Behavior &amp; business logic</a> | <a class="wiki_link" href="references-collections_en.html">9.
        References &amp; collections</a> | <a class="wiki_link" href="philosophy_en.html">A.
        Architecture &amp; philosophy</a> | <a class="wiki_link" href="jpa_en.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_en.html">C.
        Annotations</a><hr>
      
      Inheritance is a practical way to reuse code in the object oriented world.
      Using inheritance with JPA and OpenXava is as easy as using it in plain
      Java. We are going to use inheritance to remove repeated and boring code,
      like the UUID definition. Also, we'll add a new entity, <em>Order</em>,
      and we'll use inheritance to do it with minimal code. Moreover, you'll
      learn how practical it is to use inheritance even for the code used for
      testing.<br>
      <h2 id="toc1"><a name="Lesson 4: Inheritance-Inheriting from a mapped superclass"></a>Inheriting
        from a mapped superclass</h2>
      The <em>Author</em>, <em>Category</em> and <em>Invoice</em> classes
      have some common code, the <em>oid</em> field definition:<br>
      <pre><code class="java">@Id @GeneratedValue(generator="system-uuid") @Hidden
@GenericGenerator(name="system-uuid", strategy="uuid")
@Column(length=32)
private String oid;
 
public String getOid() {
    return oid;
}
 
public void setOid(String oid) {
    this.oid = oid;
}
</code></pre> This code is just the same for all those classes. You know that
      copy and paste is a mortal sin, so we have to look for a solution to
      remove the code repetition, to avoid our way to hell.<br>
      An elegant solution for this situation is inheritance. JPA allows you to
      exploit the concept of inheritance. One of them is to inherit from a
      mapped superclass. A mapped superclass is a Java class with JPA mapping
      annotations, but it is not an entity itself. Its only goal is to be used
      as superclass for an entity. Let's use it, and you'll see its utility
      quickly.<br>
      First, we move this common piece of code to a class marked as <em>@MappedSuperclass</em>.
      We name it <em>Identifiable</em>:<br>
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import javax.persistence.*;
import org.hibernate.annotations.*;
import org.openxava.annotations.*;
 
@MappedSuperclass // Marked as mapped superclass instead of entity
public class Identifiable {
 
    @Id @GeneratedValue(generator="system-uuid") @Hidden
    @GenericGenerator(name="system-uuid", strategy="uuid")
    @Column(length=32)
    private String oid; // Property definition includes OpenXava and JPA annotations
 
    public String getOid() {
        return oid;
    }
 
    public void setOid(String oid) {
        this.oid = oid;
    }
 
}
</code></pre> Now you can define <em>Author</em>, <em>Category</em> and <em>Invoice</em>
      entities in a more succinct way. To see an example you have the new code
      for <em>Category</em> here:<br>
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import javax.persistence.*;
 
@Entity
public class Category extends Identifiable { // Extends from Identifiable
                            // so it does not need to have an id property
    @Column(length=50)
    private String description;
 
    public void setDescription(String description) {
        this.description = description;
    }
 
    public String getDescription() {
        return description;
    }
}
</code></pre> The refactoring is plain vanilla. <em>Category</em> now extends
      from <em>Identifiable</em> and we have removed the oid field and the
      respective <em>getOid()</em> and <em>setOid()</em> methods. This way,
      not only is your code shorter, but it's more elegant, because you declare
      that your class is identifiable (the what, not the how), and you removed
      from your business logic class code that is somewhat technical.<br>
      Now, you can apply this same refactoring to the <em>Author</em> and <em>Invoice</em>
      entities, moreover, from now on you'll extend most of your entities from
      the <em>Identifiable</em> mapped superclass.<br>
      We have created our own <em>Identifiable</em> class to see the advantage
      of using mapped superclasses, however OpenXava provides for you a ready to
      use <em>Identifiable</em> class that you can find in the <em>org.openxava.model</em>
      package. So in your next project you don't need to write the <em>Identifiable</em>
      class again, just use the one included in OpenXava.<br>
      You have learned that a mapped superclass is a regular class with JPA
      mapping annotations that you can use as a base class for your entities.
      Moreover, you have learned how to use mapped superclasses to simplify your
      code.<br>
      <h2 id="toc2"><a name="Lesson 4: Inheritance-Entity inheritance"></a>Entity
        inheritance</h2>
      An entity may inherit from another entity. This entity inheritance is a
      useful tool to simplify your model. We are going to use it to add a new <em>Order</em>
      entity to your <em>Invoicing</em> application.<br>
      <h3 id="toc3"><a name="Lesson 4: Inheritance-Entity inheritance-New Order entity"></a>New
        Order entity</h3>
      We want to add a new concept to the <em>Invoicing</em> application, i.
      e., order. While an invoice is something you want to charge your customer,
      an order is something the customer has ordered from us. These two concepts
      are strongly related, because you will charge the things your customer has
      ordered from you, and you actually have served him.<br>
      It would be nice to manage orders in your application, and to associate
      those orders with its corresponding invoices. Just as shown in the next
      UML diagram:<br>
      <img src="files/inheritance_en010.png" alt="inheritance_en010.png" title="inheritance_en010.png"><br>
      And with Java code:<br>
      <pre><code class="java">@Entity
public class Invoice {
 
    @OneToMany(mappedBy="invoice")
    private Collection&lt;Order&gt; orders;
    ...
}
 
@Entity
public class Order {
 
    @ManyToOne // Without lazy fetching (1)
    private Invoice invoice;
    ...
}
</code></pre> That is, an invoice has several orders, and an order can reference
      an invoice. Note that we do not use lazy fetching for the <em>invoice</em>
      reference (1), this is because of a Hibernate bug when the reference owns
      the bidirectional relationship (that is, it's declared in the <em>mappedBy</em>
      attribute of the <em>@OneToMany</em>).<br>
      What shape does <em>Order</em> have? Well, it has a customer, several
      detail lines with product and quantity, a year and a number, something
      like this:<br>
      <img src="files/inheritance_en020.png" alt="inheritance_en020.png" title="inheritance_en020.png"><br>
      Incidentally, this UML diagram is identical to the <em>Invoice</em>
      diagram. That is, to create your <em>Order</em> entity you can just copy
      and paste the <em>Invoice</em> class, and the work is done. But, wait a
      moment! “Copy and paste” is a mortal sin. So, we have to find a way to
      reuse <em>Invoice</em> code for <em>Order</em>.<br>
      <h3 id="toc4"><a name="Lesson 4: Inheritance-Entity inheritance-CommercialDocument as an abstract entity"></a>CommercialDocument
        as an abstract entity</h3>
      A practical way to reuse the code for <em>Invoice</em> and <em>Order</em>
      is by using inheritance, moreover it's an excellent opportunity to learn
      how easy it is to use inheritance with JPA and OpenXava.<br>
      In most object oriented cultures you have to observe the <em>is a</em>
      rule. It means that we cannot do <em>Invoice</em> extends <em>Order</em>,
      because an <em>Invoice</em> is not an <em>Order</em>. The solution for
      this case is creating a base class for both <em>Order</em> and <em>Invoice</em>.
      We are going to call this class <em>CommercialDocument</em>.<br>
      Here you have the UML diagram for <em>CommercialDocument</em>:<br>
      <img src="files/inheritance_en030.png" alt="inheritance_en030.png" title="inheritance_en030.png"><br>
      And here you have the same idea expressed with Java:<br>
      <pre><code class="java">public class CommercialDocument { ... }
public class Order extends CommercialDocument { ... }
public class Invoice extends CommercialDocument { ... }
</code></pre> Let's start to refactor your current code. First, rename (using <em>Refactor
        &gt; Rename</em>) <em>Invoice</em> as <em>CommercialDocument</em>.
      Now, edit the <em>CommercialDocument</em> code to declare it as an
      abstract class, thus:<br>
      <pre><code class="java">abstract public class CommercialDocument // We add the abstract modifier
</code></pre> We want to create instances of <em>Invoice</em> and <em>Order</em>,
      but we do not want to create instances of <em>CommercialDocument</em>
      directly, so we declare it as abstract.<br>
      <h3 id="toc5"><a name="Lesson 4: Inheritance-Entity inheritance-Invoice refactored to use inheritance"></a>Invoice
        refactored to use inheritance</h3>
      Now, you have to create the <em>Invoice</em> entity extending it from <em>CommercialDocument</em>.
      See the new <em>Invoice</em> code:<br>
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import javax.persistence.*;
 
@Entity
public class Invoice extends CommercialDocument {
 
}
</code></pre> <em>Invoice</em> now has very succinct code, indeed the body of
      the class is, by now, empty.<br>
      This new code requires a slightly different database schema, now invoices
      and orders will be stored in the same table (the CommercialDocument table)
      using a discriminator column. Therefore you need to remove the old tables
      executing the next SQL statements:<br>
      <pre><code class="sql">DROP TABLE INVOICING.INVOICE_DETAILS;
DROP TABLE INVOICING.INVOICE;
</code></pre> To execute these SQL statements, first make sure your application
      is running, then go to the <i>DBManager</i> class in <i>Invoicing/src/_run</i>,
      and with the right mouse button choose <i>Run As &gt; Java Application</i>:<br>
      <img src="files/inheritance_en040.png" alt="inheritance_en040.png" title="inheritance_en040.png"><br>
      Then:<br>
      <img src="files/inheritance_en050.png" alt="inheritance_en050.png" title="inheritance_en050.png"><br>
      Now you can execute the <em>Invoice</em> module and see it working in
      your browser. Also, execute the <em>InvoiceTest</em>. It must be green.<br>
      <h3 id="toc6"><a name="Lesson 4: Inheritance-Entity inheritance-Creating Order using inheritance"></a>Creating
        Order using inheritance</h3>
      Thanks to <em>CommercialDocument</em> creating the <em>Order</em> entity
      is dead easy. See the code:<br>
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import javax.persistence.*;
 
@Entity
public class Order extends CommercialDocument {
 
}
</code></pre> After writing the above <em>Order</em> class, although it is
      empty by now, you can use the <em>Order</em> module from your browser.
      Yes, creating a new entity with a structure like <em>Invoice</em>, that
      is any commercial document entity, is very easy and rapid. You see how
      good use of inheritance is an elegant way to have simpler code.<br>
      <em>Order</em> module works perfectly, but it has a little problem. The
      new order number is calculated from the last invoice number, not from the
      last order number. This is because the calculator for the next number is
      read from the <em>Invoice</em> entity. An obvious solution is to move the
      <em>number</em> property definition from <em>CommercialDocument</em> to <em>Invoice</em>
      and <em>Order</em>. Although, we are not going to do it in this way,
      because in the next lesson we'll refine the way to calculate the next
      number, for now we simply do a little adjustment in the current code so
      that it does not fail. Edit the <em>NextNumberForYearCalculator</em>
      class and in the query change “Invoice” for “CommercialDocument”, leaving
      the <em>calculate()</em> method, in this way:<br>
      <pre><code class="java">public Object calculate() throws Exception {
    Query query = XPersistence.getManager().createQuery(
        "select max(i.number) from " +
        "CommercialDocument i " + // CommercialDocument instead of Invoice
        "where i.year = :year");
    query.setParameter("year", year);
    Integer lastNumber = (Integer) query.getSingleResult();
    return lastNumber == null?1:lastNumber + 1;
}
</code></pre> Now we search for the maximum number of any commercial document of
      the year in order to calculate the new number, therefore the numbering is
      shared across all the commercial documents. We'll improve it in the next
      lesson for having separate numbering for invoices and orders and to have
      better support for a multiuser environment.<br>
      <h3 id="toc7"><a name="Lesson 4: Inheritance-Entity inheritance-Naming convention and inheritance"></a>Naming
        convention and inheritance</h3>
      Note that you do not need to change the name of any property of <em>Invoice</em>
      to do the refactoring. This is because we follow the next pragmatic
      principle: <em>Do not use the class name in member names</em>, e.g.,
      inside an <em>Account</em> class do not use the “Account” word in any
      method or property:<br>
      <pre><code class="java">public class Account { // We'll not use Account in member names
 
    private int accountNumber; // Bad, because it uses “account”
    private int number; // Good, it does not use “account”
 
    public void cancelAccount() { } // Bad, because it uses “Account”
    public void cancel() { } // Good, it does not use “account”
    ...
}
</code></pre> Using this nomenclature you can refactor <em>Account</em> in an
      inheritance hierarchy without renaming its members, and you can write
      polymorphic code with <em>Account</em>.<br>
      <h3 id="toc8"><a name="Lesson 4: Inheritance-Entity inheritance-Associating Order with Invoice"></a>Associating
        Order with Invoice</h3>
      By now, <em>Order</em> and <em>Invoice</em> are exactly the same. We are
      going to do the first extensions on them, that is to associate <em>Order</em>
      with <em>Invoice</em>. Just as shown in the diagram:<br>
      <img src="files/inheritance_en010.png" alt="inheritance_en010.png" title="inheritance_en010.png"><br>
      You only need to add a reference from <em>Order</em> to <em>Invoice</em>:<br>
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import javax.persistence.*;
 
@Entity
public class Order extends CommercialDocument {
 
    @ManyToOne
    private Invoice invoice; // Reference to invoice added
 
    public Invoice getInvoice() {
        return invoice;
    }
 
    public void setInvoice(Invoice invoice) {
        this.invoice = invoice;
    }
 
}
</code></pre> Conversely in <em>Invoice</em> we add a collection of <em>Order</em>
      entities:<br>
      <pre><code class="java">package com.yourcompany.invoicing.model;
 
import java.util.*; // Add this import to use Collection
import javax.persistence.*;
 
@Entity
public class Invoice extends CommercialDocument {
 
    @OneToMany(mappedBy="invoice")
    private Collection&lt;Order&gt; orders; // Collection of Order entities added
 
    public Collection&lt;Order&gt; getOrders() {
        return orders;
    }
 
    public void setOrders(Collection&lt;Order&gt; orders) {
        this.orders = orders;
    }
 
}
</code></pre> After writing this simple code you are ready to test the newly
      created relationship. Restart your application and open your browser and
      explore the <em>Order</em> and the <em>Invoice</em> modules. Note that
      at the end of the <em>Order</em> user interface you have a reference to <em>Invoice</em>.
      The user can use this reference to associate an invoice with the current
      order. On the other hand, if you explore the <em>Invoice</em> module, you
      will see a collection of orders at the end. The user can use it to add
      orders to the current invoice.<br>
      Try to add orders to invoice, and to associate an invoice to an order. It
      works, although the user interface is a little ugly.<br>
      <h2 id="toc9"><a name="Lesson 4: Inheritance-View inheritance"></a>View
        inheritance</h2>
      You can use inheritance not only for reusing the Java code and mapping,
      but also for reusing the user interface definition, the <em>@View</em>
      definitions. This section shows how view inheritance works.<br>
      <h3 id="toc10"><a name="Lesson 4: Inheritance-View inheritance-The extendsView attribute"></a>The
        extendsView attribute</h3>
      Both <em>Order</em> and <em>Invoice</em> use a user interface generated
      by default with all its members one in each line. Note that the annotation
      <em>@View</em> that we have declared in <em>CommercialDocument</em> is
      not inherited by default. That is, if you do not define a view for an
      entity a default one is generated, and the <em>@View</em> of the parent
      entity is not used. Just in this way:<br>
      <pre><code class="java">@View(members = "a, b, c;") // This view is used to display Parent, but not for Child
public class Parent { ... }
 
public class Child extends Parent { ... }   // Child is displayed using an automatically
                                            // generated view, not the view from Parent
</code></pre> Usually the view of the parent entity “as is” is not very useful
      because it does not contain the new properties that the current entity
      has. So this behavior is good for default behavior.<br>
      Although, in a non-trivial entity you may need to refine the user
      interface, and it might be useful to inherit (instead of copy and paste)
      the view from the parent. You can do it using the <em>extendsView</em>
      attribute in <em>@View</em>:<br>
      <pre><code class="java">@View(members = "a, b, c;") // This view with no name is the DEFAULT view
public class Parent { ... }
 
@View(name="A" members = "d", // Adds d to the inherited view
    extendsView = "super.DEFAULT") // Extends the default view from Parent
@View(name="B" members = "a, b, c; d") // View B is equals to view A
public class Child extends Parent { ... }   // Child is displayed using an automatically
                                            // generated view, not the view from Parent
</code></pre> Using <em>extendsView</em> the members that appear will be those
      of the extended view plus those declared in members of the current one.<br>
      We are going to use this feature for defining the views for <em>CommercialDocument</em>,
      <em>Order</em> and <em>Invoice</em>.<br>
      <h3 id="toc11"><a name="Lesson 4: Inheritance-View inheritance-View for Invoice using inheritance"></a>View
        for Invoice using inheritance</h3>
      Given that the <em>@View</em> of <em>CommercialDocument</em> has not
      inherited the current user interface for <em>Invoice</em> it's pretty
      ugly to see, all the members, each in a line. We are going to define a
      better user interface. A view similar to the one we defined previously,
      but adding a tab for orders, thus:</div>
    <div class="wiki" style="display: block;"> <img src="files/inheritance_en060.png"

        alt="inheritance_en060.png" title="inheritance_en060.png"><br>
      Note that we have put all the members from the <em>CommercialDocument</em>
      part of the <em>Invoice</em> in the header and the first tab (data), and
      the collection of orders in the other tab. The next code shows the way to
      define this view without inheritance.<br>
      <pre><code class="java">@View( members=
    "year, number, date;" +
    "data {" +
        "customer;" +
        "details;" +
    "remarks" +
    "}" +
    "orders { orders } "
)
public class Invoice extends CommercialDocument {
</code></pre> You can note how all except the orders part is common for every <em>CommercialDocument</em>.
      Therefore, we are going to move this part to <em>CommercialDocument</em>
      and then redefine this view using view inheritance.<br>
      Remove the old <em>@View</em> in <em>CommercialDocument</em>, and write
      this one:<br>
      <pre><code class="java">@View(members=
    "year, number, date," + // The members for the header part in one line
    "data {" + // A tab 'data' for the main data of the document
        "customer;" +
        "details;" +
        "remarks" +
    "}"
)
abstract public class CommercialDocument extends Identifiable {
</code></pre> This view indicates how to layout the common data for all
      commercial documents. Now we can redefine the view for <em>Invoice</em>
      from this one:<br>
      <pre><code class="java">import org.openxava.annotations.*; // Add this import to use @View
 
@Entity
@View(extendsView="super.DEFAULT", // Extends from the CommercialDocument view
    members="orders { orders }" // We add the orders inside a tab
)
public class Invoice extends CommercialDocument {
</code></pre> In this way declaring the view for <em>Invoice</em> is shorter.
      What's more, the common layout for <em>Order</em>, <em>Invoice</em> and
      all other possible <em>CommercialDocument</em> objects are all in one
      place. So if you add a new property to <em>CommercialDocument</em> you
      only need to touch the view for <em>CommercialDocument</em>.<br>
      <h3 id="toc12"><a name="Lesson 4: Inheritance-View inheritance-View for Order using inheritance"></a>View
        for Order using inheritance</h3>
      Now that you have a suitable view in <em>CommercialDocument</em>,
      declararing the view for <em>Order</em> is plain vanilla. We want
      something like this:<br>
      <img src="files/inheritance_en070.png" alt="inheritance_en070.png" title="inheritance_en070.png"><br>
      To get this result, you can define the view for <em>Order</em> by
      extending the default view for <em>CommercialDocument</em>, adding the
      referenced invoice in a new tab:<br>
      <pre><code class="java">import org.openxava.annotations.*; // Add this import to use @View
 
@Entity
@View(extendsView="super.DEFAULT", // Extends from the CommercialDocument view
    members="invoice { invoice } " // We add the invoice inside a tab
)
public class Order extends CommercialDocument {
</code></pre> With this we get all the data from <em>CommercialDocument</em>
      plus a tab with the invoice.<br>
      <h3 id="toc13"><a name="Lesson 4: Inheritance-View inheritance-Using @ReferenceView and @CollectionView to refine views"></a>Using
        @ReferenceView and @CollectionView to refine views</h3>
    </div>
    <div class="wiki" style="display: block;">When an order is to be viewed from
      the <em>Invoice</em> user interface, we want the view used to do so to be
      simple, with no customer or invoice information, because this data is
      redundant in this case:<br>
      <img src="files/inheritance_en080.png" alt="inheritance_en080.png" title="inheritance_en080.png"><br>
      To get this result define a simpler view in <em>Order</em>:<br>
      <pre><code class="java">@View( extendsView="super.DEFAULT", // The default view
    members="invoice { invoice } "
)
@View( name="NoCustomerNoInvoice", // A view named NoCustomerNoInvoice
    members=                       // that does not include customer and invoice.
        "year, number, date;" +    // Ideal to be used from Invoice
        "details;" +
        "remarks"
)
public class Order extends CommercialDocument {
</code></pre> This new view defined in <em>Order</em> named <em>NoCustomerNoInvoice</em>
      can be referenced from <em>Invoice</em> to display the individual
      elements of the orders collection using <em>@CollectionView</em>:<br>
      <pre><code class="java">@OneToMany(mappedBy="invoice")
@CollectionView("NoCustomerNoInvoice") // This view is used to display orders
private Collection&lt;Order&gt; orders;
</code></pre> And with this code only, the orders collection will use a more
      appropriate view from <em>Invoice</em> to display individual elements.<br>
      Moreover, we do not want to display the customer and order information
      from the <em>Order</em> user interface because it is redundant data in
      this case. To do so, we are going to define a simpler view in <em>Invoice</em>:<br>
      <pre><code class="java">@View( extendsView="super.DEFAULT", // The default view
    members="orders { orders }"
)
@View( name="NoCustomerNoOrders", // A view named NoCustomerNoOrders
    members=                      // that does not include customer and orders
        "year, number, date;" +   // Ideal to be used from Order
        "details;" +
        "remarks"
)
public class Invoice extends CommercialDocument {
</code></pre> This new view defined in <em>Invoice</em> named <em>NoCustomerNoOrders</em>
      can be referenced from <em>Order</em> to display the reference to <em>Invoice</em>
      using <em>@ReferenceView</em>:<br>
      <pre><code class="java">public class Order extends CommercialDocument {
 
    @ManyToOne
    @ReferenceView("NoCustomerNoOrders") // This view is used to display invoice
    private Invoice invoice;
 
    ...
 
}
</code></pre> Now the <em>invoice</em> reference will be displayed from <em>Order</em>
      without customers and orders so you'll get a simpler user interface:<br>
      <img src="files/inheritance_en090.png" alt="inheritance_en090.png" title="inheritance_en090.png"><br>
      <h2 id="toc14"><a name="Lesson 4: Inheritance-Inheritance in JUnit tests"></a>Inheritance
        in JUnit tests</h2>
      <em>Invoice</em> has been refactored to use inheritance, also we have used
      inheritance to add a new <em>Order</em> entity. Moreover, this <em>Order</em>
      entity has a relationship with <em>Invoice</em>. You have a lot of new
      functionality, therefore you must test all the new features.<br>
      Because <em>Invoice</em> and <em>Order</em> have a lot of common stuff
      (the <em>CommercialDocument</em> part) we can refactor the tests in order
      to use inheritance, thus you avoid the harmful “copy and paste” in your
      test code as well.<br>
      <h3 id="toc15"><a name="Lesson 4: Inheritance-Inheritance in JUnit tests-Creating an abstract module test"></a>Creating
        an abstract module test</h3>
      If you examine the test for creating an invoice, from the <em>testCreate()</em>
      method of <em>InvoiceTest</em>. You can note that testing the creation of
      an invoice is exactly the same to testing the creation of an order.
      Because, both have year, number, date, customer, details and remarks. So,
      here inheritance is a good tool for code reuse.<br>
      We are going to rename <em>InvoiceTest</em> as <em>CommercialDocumentTest</em>,
      then we'll create <em>InvoiceTest</em> and <em>OrderTest</em> from it.
      See the UML diagram for this idea:<br>
      <img src="files/inheritance_en100.png" alt="inheritance_en100.png" title="inheritance_en100.png"><br>
      First rename your current <em>InvoiceTest</em> class to <em>CommercialDocumentTest</em>,
      then make the changes indicated in the next code:<br>
      <pre><code class="java">package com.yourcompany.invoicing.tests;
 
import java.time.*;
import java.time.format.*;
import javax.persistence.*;
import org.openxava.tests.*;
import static org.openxava.jpa.XPersistence.*;<br><br>abstract public class CommercialDocumentTest // Add abstract to class definition
    extends ModuleTestBase {
 
    private String number;
 
    public CommercialDocumentTest(
        String testName,
        String moduleName) // moduleName added as constructor argument
    {
        super(testName, "Invoicing", moduleName); // Send moduleName
    }
 
    public void testCreate() throws Exception { ... } // As original
 
    private void addDetails() throws Exception { ... } // As original
 
    private String getNumber() {
        if (number == null) {
            Query query = getManager().createQuery(
                "select max(i.number) from " +
                    "CommercialDocument i " + // Invoice changed for CommercialDocument
                    "i where i.year = :year");
            query.setParameter("year", LocalDate.now().getYear());
            Integer lastNumber = (Integer) query.getSingleResult();
            if (lastNumber == null)    lastNumber = 0;
            number = Integer.toString(lastNumber + 1);
        }
        return number;
    }
 
    private void remove() throws Exception { ... } // As original
 
    private void verifyCreated() throws Exception { ... } // As original
 
    private void save() throws Exception { ... } // As original
 
    private void setOtherProperties() throws Exception { ... } // As original
 
    private void chooseCustomer() throws Exception { ... } // As original
 
    private void verifyDefaultValues() throws Exception { ... } // As original
 
    private String getCurrentYear() { ... } // As original
 
    private String getCurrentDate() { ... } // As original
 
}
</code></pre> As you see you have to do a few changes in order to adapt <em>CommercialDocumentTest</em>.
      First, you declared it as an abstract class. This way this class is not
      executed by Eclipse as a JUnit test. It is only valid as base class for
      creating tests, but it is not a test itself.<br>
      Another important change is in the constructor, where you now use <em>moduleName</em>
      instead of “Invoice”, thus you can use this test for <em>Order</em>, <em>Invoice</em>
      or whatever other module you want. The other change is a simple detail:
      you have to change “Invoice” for “ComercialDocument” in the query to get
      the next number.<br>
      Now you have a base class ready to create the module tests for <em>Order</em>
      and <em>Invoice</em>. Let's do it.<br>
      <h3 id="toc16"><a name="Lesson 4: Inheritance-Inheritance in JUnit tests-Using the abstract module test to create concrete module tests"></a>Using
        the abstract module test to create concrete module tests</h3>
      Creating your first version of <em>OrderTest</em> and <em>InvoiceTest</em>
      is just a matter of extending from <em>CommercialDocumentTest</em>.
      Nothing more. See the <em>InvoiceTest</em> code:<br>
      <pre><code class="java">package com.yourcompany.invoicing.tests;
 
public class InvoiceTest extends CommercialDocumentTest {
 
    public InvoiceTest(String testName) {
        super(testName, "Invoice");
    }
 
}
</code></pre> And <em>OrderTest</em>:<br>
      <pre><code class="java">package com.yourcompany.invoicing.tests;
 
public class OrderTest extends CommercialDocumentTest {
 
    public OrderTest(String testName) {
        super(testName, "Order");
    }
 
}
</code></pre> Execute these two tests and you will see how <em>testCreate()</em>,
      inherited from <em>CommercialDocumentTest</em>, is executed in both
      cases, against its corresponding module. With this we are testing the
      common behavior of <em>Order</em> and <em>Invoice</em>. Let's test the
      different cases for them.<br>
      <h3 id="toc17"><a name="Lesson 4: Inheritance-Inheritance in JUnit tests-Adding new tests to the extended module test"></a>Adding
        new tests to the extended module test</h3>
      So far we tested how to create an invoice and an order. In this section
      we'll test also how to add orders to an invoice in the <em>Invoice</em>
      module, and how to set the invoice to an order from the <em>Order</em>
      module.<br>
      To test how to add an order to an invoice, add the <em>testAddOrders()</em>
      method to <em>InvoiceTest</em>:<br>
      <pre><code class="java">// This test assumes that at least one invoice and order order already exist
public void testAddOrders() throws Exception {
    login("admin", "admin");
    assertListNotEmpty(); // This test assumes that some invoices already exist
    execute("List.orderBy", "property=number"); // To always work with the same order
    execute("List.viewDetail", "row=0"); // Goes to detail mode editing the first invoice
    execute("Sections.change", "activeSection=1"); // Changes to tab 1
    assertCollectionRowCount("orders", 0); // This invoice has no orders
    execute("Collection.add", // Clicks on the button for adding a new order, this takes
        "viewObject=xava_view_section1_orders"); // you to a list of orders
    execute("AddToCollection.add", "row=0"); // Chooses the first order in the list
    assertCollectionRowCount("orders", 1); // Order added to the invoice
    checkRowCollection("orders", 0); // Checks the order, to remove it
    execute("Collection.removeSelected", // Removes the recently added order
        "viewObject=xava_view_section1_orders");
    assertCollectionRowCount("orders", 0); // The order has been removed
}
</code></pre> In this case we rely on the fact that there is at least one
      invoice, and that the first invoice in the list has no orders. Before
      running this test, if you have no invoices, create one with no orders, or
      if you already have invoices, be sure that the first one has no orders.<br>
      To test how to assign an invoice to an order add the <em>testSetInvoice()</em>
      method to <em>OrderTest</em>:<br>
      <pre><code class="java">public void testSetInvoice() throws Exception {
    login("admin", "admin");
    assertListNotEmpty(); // This test assumes that some orders already exist
    execute("List.viewDetail", "row=0"); // Goes to detail mode editing the first invoice
    execute("Sections.change", "activeSection=1"); // Changes to tab 1
    assertValue("invoice.number", ""); // This order has no
    assertValue("invoice.year", ""); // invoice assigned yet
    execute("Reference.search", // Clicks on the button to search the invoice, this
        "keyProperty=invoice.year"); // takes you to a list of invoices
    execute("List.orderBy", "property=number"); // To sort the list of invoices
    String year = getValueInList(0, "year"); // Stores the year and number of
    String number = getValueInList(0, "number"); // the first invoice in the list
    execute("ReferenceSearch.choose", "row=0"); // Chooses the first invoice
    assertValue("invoice.year", year); // On return to order detail we verify
    assertValue("invoice.number", number); // the invoice has been selected
}
</code></pre> In this case we rely on the fact that there is at least one order,
      and that the first order in the list has no invoice. Before running this
      test, if you have no orders, create one with no invoice, or if you already
      have orders, be sure that the first one has no invoice.<br>
      With this you have your tests ready. Just execute them, and you'll get the
      next result:<br>
      <img src="files/inheritance_en110.png" alt="inheritance_en110.png" title="inheritance_en110.png"><br>
      Note that the base test <em>CommercialDocumentTest</em> is not shown
      because it is abstract. And the <em>testCreate()</em> method of <em>CommercialDocumentTest</em>
      is executed for both <em>InvoiceTest</em> and <em>OrderTest</em>.<br>
      Not only have you adapted your testing code to the improved code for <em>Invoicing</em>,
      but you have also learned how to use inheritance in the test code as well.<br>
      <h2 id="toc18"><a name="Lesson 4: Inheritance-Summary"></a>Summary</h2>
      This lesson has shown you some practical examples about how to use the
      inheritance of Java and JPA to simplify your code. We used the default JPA
      configuration for inheritance, though you can refine JPA behavior for
      inheritance using some JPA annotations like <em>@Inheritance</em>, <em>@DiscriminatorColumn</em>,
      <em>@DiscriminatorValue</em>, etc. To learn more about inheritance in JPA
      read the documents cited in <a class="wiki_link" href="jpa_en.html">Appendix
        B</a>.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-4-inheritance_en.zip/download"

          rel="nofollow">Download source code of this lesson</a></strong><br>
      <br>
      <strong>Any problem with this lesson? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/419690/"

          rel="nofollow">Ask in the forum</a></strong> <strong>Everything fine?
        <a class="wiki_link" href="basic-business-logic_en.html">Go to Lesson 5</a></strong>
    </div>
  </body>
</html>
