<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lesson 11: JPA callback methods - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <h1 id="toc0"><a name="Lesson 5: Basic business logic"></a> <span id="breadcrumbs">
          <span id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava
              </a> </span> / <a href="index_en.html">documentation</a> / </span>
        Lesson 11: JPA callback methods</h1>
      <strong>Course</strong>: <a class="wiki_link" href="getting-started_en.html">1.
        Getting started</a> | <a class="wiki_link" href="basic-domain-model1_en.html">2.
        Basic domain model (1)</a> | <a class="wiki_link" href="basic-domain-model2_en.html">3.
        Basic domain model (2)</a> | <a class="wiki_link" href="refining-user-interface_en.html">4.
        Refining the user interface</a> | <a class="wiki_link" href="agile-development_en.html">5.
        Agile development</a> |&nbsp;<a class="wiki_link" href="mapped-superclass-inheritance_en.html">6.
        Mapped superclass inheritance</a> | <a class="wiki_link" href="entity-inheritance_en.html">7.
        Entity inheritance</a> | <a class="wiki_link" href="view-inheritance_en.html">8.
        View inheritance</a> | <a class="wiki_link" href="java-properties_en.html">9.Java
        properties</a> | <a class="wiki_link" href="total-properties-with-calculation_en.html">10.
        Total properties with @Calculation</a> | <strong>11. JPA callback
        methods</strong> | <a class="wiki_link" href="validation_en.html">12.
        Advanced validation</a> | <a class="wiki_link" href="refining-standard-behavior_en.html">13.
        Refining the standard behavior</a> | <a class="wiki_link" href="business-logic-behavior_en.html">14.
        Behavior &amp; business logic</a> | <a class="wiki_link" href="references-collections_en.html">15.
        References &amp; collections</a> | <a class="wiki_link" href="philosophy_en.html">A.
        Architecture &amp; philosophy</a> | <a class="wiki_link" href="jpa_en.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_en.html">C.
        Annotations</a> | <a class="wiki_link" href="testing_en.html">D.
        Automated testing</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">Table of contents</h1>
        <div style="margin-left: 1em;"><a href="#Lesson%205:%20Basic%20business%20logic">Lesson
            11: JPA callback methods<br>
          </a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%205:%20Basic%20business%20logic-JPA%20callback%20methods">JPA
            callback methods</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%205:%20Basic%20business%20logic-JPA%20callback%20methods-Multiuser%20safe%20default%20value%20calculation">Multiuser
            safe default value calculation</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%205:%20Basic%20business%20logic-JPA%20callback%20methods-Synchronizing%20persistent%20and%20calculated%20properties">Synchronizing
            persistent and calculated properties</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%205:%20Basic%20business%20logic-Database%20logic%20%28@Formula%29">Database
            logic (@Formula)</a></div>
        <div style="margin-left: 2em;"><a href="#Lesson%205:%20Basic%20business%20logic-Summary">Summary</a></div>
      </div>
    </div>
    <div class="wiki" style="display: block;">Our Application already works with
      computed and<i> persistent</i> properties to handle values, with a basic
      logical structure. We will now see how to further improve this logic,
      applying modifications to persistent objects and using Hibernate
      annotations such as <i>@Formula</i> to <i>map</i> properties to <i>SQL</i>
      fragments.</div>
    <div class="wiki" style="display: block;">
      <h2 id="toc6"><a name="Lesson 5: Basic business logic-JPA callback methods"></a>JPA
        callback methods</h2>
      Another useful way to add business logic to your model is using JPA
      callback methods. A callback method is a method in your entity that is
      called in some specific moment of its life cycle as a persistent object.
      That is, you can specify some logic to execute on save, read, remove or
      modification of the entity.<br>
      In this section we'll see some practical applications of JPA callback
      methods.<br>
      <h2 id="toc7"><a name="Lesson 5: Basic business logic-JPA callback methods-Multiuser safe default value calculation"></a>Multiuser
        safe default value calculation</h2>
      Until now we were calculating the <em>Invoice</em> and <em>Order</em>
      number using <em>@DefaultValueCalculator</em>. This calculates the
      default value when the user clicks to create a new <em>Invoice</em> or <em>Order</em>.
      So, if several users click on the <i>New</i> button at the same time all
      of them get the same number. This is not multiuser safe. The way to
      generate a unique number is by generating it just on save.<br>
      We are going to implement it using a JPA callback method. JPA allows you
      to mark any method of your class to be executed in any part of its life
      cycle. We'll indicate the calculation of the number just before the saving
      of the <em>CommercialDocument</em>. Using this approach we'll improve the
      number calculation for having a different numeration for <em>Order</em>
      and <em>Invoice</em>.<br>
      Edit the <em>CommercialDocument</em> entity and add the <em>calculateNumber()</em>
      method:<br>
      <pre><code class="java">@PrePersist // Executed just before saving the object for the first time
private void calculateNumber() throws Exception {
    Query query = XPersistence.getManager()
        .createQuery("select max(i.number) from " +
        getClass().getSimpleName() + // Thus it's valid for both Invoice and Order
        " i where i.year = :year");
    query.setParameter("year", year);
    Integer lastNumber = (Integer) query.getSingleResult();
    this.number = lastNumber == null ? 1 : lastNumber + 1;
}
</code></pre> </div>
    <div class="wiki" style="display: block;">This code is the same as that of
      the <em>NextNumberForYearCalculator</em> but using <em>getClass().getSimpleName()</em>
      instead of “CommercialDocument”. The <em>getSimpleName()</em> method
      returns the name of the class without the package, i.e., just the entity
      name. It will be “Order” for <em>Order</em> and “Invoice” for <em>Invoice</em>.
      Thus we can get a different numeration for <em>Order</em> and <em>Invoice</em>.<br>
      JPA specification states that you should not use JPA API inside a JPA
      callback method. So the above method is not legal from a strict JPA
      viewpoint. But, Hibernate (the JPA implementation OpenXava uses by
      default) allows you to use it in <em>@PrePersist</em>. And since JPA is
      the easier way to do this calculation we use it in our practice.<br>
      Now you can delete the <em>NextNumberForYearCalculator</em> class from
      your project, and modify the number property of <em>CommercialDocument</em>
      to avoid using it:<br>
      <pre><code class="java">@Column(length=6)
// @DefaultValueCalculator(value=NextNumberForYearCalculator.class, // Remove this
//     properties=@PropertyValue(name="year")
// )
@ReadOnly // The user cannot modify the value
int number;
</code></pre> Note that in addition to removing <em>@DefaultValueCalculator</em>,
      we have added the <em>@ReadOnly</em> annotation. This means that the user
      cannot enter or modify the <em>number</em>. This is the right approach
      given that the number is generated on saving the object, so the user typed
      value would always be overridden.<br>
    </div>
    <div class="wiki" style="display: block;">Try now the <em>Invoice</em> or <em>Order</em>
      module and you will see that the number is empty and not editable, and
      when you save the document the number is calculated and a message is shown
      with the year and the just generated number for that invoice/order.<br>
      <h2 id="toc8"><a name="Lesson 5: Basic business logic-JPA callback methods-Synchronizing persistent and calculated properties"></a>Synchronizing
        persistent and calculated properties</h2>
      As we already have learned, calculated properties do not allow to filter
      or ordering in list, so we prefer transient properties with <i>@Calculation</i>.
      However, <i>@Calculation</i> properties are only valid for simple
      arithmetic calculations. When you need loops, condition, read from
      database, connect to external services, or some complex logic, <i>@Calculation</i>
      is not enough. For these cases you need to write the logic with Java, in
      the getter. But, how we can do this and at the same time keep the ordering
      and filtering in list? Simple, you can use two properties, one calculated
      and one persistent, and synchronize both using JPA callback methods.
      You're going to learn how to do it in this section.</div>
    <div class="wiki" style="display: block;">Let's add a new property to <i>Order</i>
      entity called <i>estimatedDeliveryDays</i>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@Depends("date")
public int getEstimatedDeliveryDays() {
    if (getDate().getDayOfYear() &lt; 15) {
        return 20 - getDate().getDayOfYear(); 
    }
    if (getDate().getDayOfWeek() == DayOfWeek.SUNDAY) return 2;
    if (getDate().getDayOfWeek() == DayOfWeek.SATURDAY) return 3;
    return 1;
}
</code></pre> </div>
    <div class="wiki" style="display: block;"> This is a pure calculated
      property, a getter with Java logic. It calculates the estimated delivery
      days using <i>date</i> as source. This case cannot be solved with <i>@Calculation</i>
      that only supports basic arithmetic calculations. </div>
    <div class="wiki" style="display: block;">We also have to add <i>estimatedDeliveryDays</i>
      to the default <i>@View</i> declaration in <i>Order</i> code:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@View(extendsView="super.DEFAULT", 
    members=
        "estimatedDeliveryDays," + // ADD THIS LINE
        "invoice { invoice }"
)
...
public class Order extends CommercialDocument {
</code></pre> </div>
    <div class="wiki" style="display: block;">The result is this:</div>
    <img src="files/business-logic_en050.png" alt="business-logic_en050.png" title="business-logic_en050.png">
    <div class="wiki" style="display: block;">The value is recalculated each
      time the date changes in the user interface thanks to the <i>@Depends("date")</i>
      in <i>estimatedDeliveryDays.</i> This is all very nice, but when you go
      to list mode you cannot order or filter by estimated delivery days. To
      solve this problem we add a second property, this time a persistent one.
      Add the next code to your <i>Order</i> entity:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">@Column(columnDefinition="INTEGER DEFAULT 1")
int deliveryDays;
</code></pre> </div>
    <div class="wiki" style="display: block;">Note as we have used <i>@Column(columnDefinition="INTEGER
        DEFAULT 1")</i>, with this trick when OpenXava creates the column uses
      "INTEGER DEFAULT 1" as column definition, thus the new column has 1 as
      default value instead of null, and we avoid an ugly error with our int
      property. Yes, in many cases <i>@Column(columnDefinition=)</i> is an
      alternative to do an UPDATE over the table (as we did in "Manual schema
      evolution" section), although has the problem that is database dependent.
      Anyways, this <i>columnDefinition</i> dissertation is tangential to our
      calculated/persistent synchronization issue, <i>@Column</i> is not
      required at all, it's just convenient for this int property.</div>
    <div class="wiki" style="display: block;">This new <i>deliveryDays</i>
      property will contain the same value as <em>estimatedDeliveryDays</em>,
      but <i><em>deliveryDays</em></i> will be persistent with its
      corresponding column in the database. The tricky issue here is to have the
      <em>deliveryDays</em> property synchronized. We will use the JPA callback
      methods in <em>Order</em> to achieve this. It's enough to assign the
      value of <i>estimatedDeliveryDays</i> to <i>deliveryDays</i> each time
      that a new <i>Order</i> is created (<i>@PrePersist</i>) or updated (<i>@PreUpdate</i>).
      </div>
    <div class="wiki" style="display: block;">Add a new <i>recalculateDeliveryDays()</i>
      method to <i>Order</i> entity annotated with <i>@PrePersist</i> and <i>@PreUpdate</i>,
      thus:<br>
      <pre><code class="java">@PrePersist @PreUpdate 
private void recalculateDeliveryDays() {
    setDeliveryDays(getEstimatedDeliveryDays());
}
</code></pre>Basically, the <i>recalculateDeliveryDays()</i> method is called
      every time an <em>Order</em> entity is registered in the database for the
      first time and when the order is updated.</div>
    <div class="wiki" style="display: block;">You can try the <em>Order</em>
      module with this code, and you will see how when a order is created or
      modified, the column in the database for <em>deliveryDays</em> is
      correctly updated after saving, ready to be used in massive processing and
      available for ordering and filter in list.<br>
      <h2 id="toc9"><a name="Lesson 5: Basic business logic-Database logic (@Formula)"></a>Database
        logic (<em>@Formula</em>)</h2>
      Another alternative to <i>@Calculation</i> or having
      calculated/persistent properties synchronized is the <em>@Formula</em>
      annotation. <em>@Formula</em> is a Hibernate extension to the JPA
      standard, that allows you to map a property to a SQL statement. For
      example, you can define <em>estimatedProfit</em> with <em>@Formula</em>
      in <i>CommercialDocument</i> as shown the next code:<br>
      <pre><code class="java">@org.hibernate.annotations.Formula("TOTALAMOUNT * 0.10") // The calculation using SQL
@Setter(AccessLevel.NONE) // The setter is not generated, only the getter is needed
@Stereotype("MONEY")
BigDecimal estimatedProfit; // A field, as in the persistent property case
</code></pre> This means that when a <em>CommercialDocument</em> is read from
      the database, the <em>estimatedProfit</em> field will be filled with the
      calculation for <em>@Formula</em> that is done by the database. The user
      can filter and ordering by <i>@Formula</i> properties in list mode, but
      they are always read only and are not recalculated in real time in detail
      mode. Given they are read only they don't need the setter method, so we
      use <i>@Setter(AccessLevel.NONE)</i> to prevent the setter generation by
      Lombok. Moreover, <i>@Formula</i> properties are database dependent,
      because you can use syntax only supported by certain database vendor.</div>
    <div class="wiki" style="display: block;">
      <h2 id="toc14"><a name="Lesson 5: Basic business logic-Summary"></a>Summary</h2>
      In this lesson you have learned some common ways to add business logic to
      your entities. There should be no doubt about the utility of calculated
      properties, <i>@Calculation</i>, callback methods or <em>@Formula</em>.
      Nevertheless, there are many other ways to add logic to your OpenXava
      application, and we are going to learn them.<br>
      In the coming lessons you'll see how to add validation, modify the
      standard module behavior and add your own business logic, among other ways
      to add custom logic to your application.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-5-basic-business-logic_en.zip/download"
          rel="nofollow">Download source code of this lesson</a></strong><br>
      <br>
      <strong>Any problem with this lesson? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/419690/"
          rel="nofollow">Ask in the forum</a></strong> <strong>Everything fine?
        <a class="wiki_link" href="validation_en.html">Go to Lesson 12</a></strong>
    </div>
  </body>
</html>
