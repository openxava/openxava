<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lección 10: Propiedades de total con Calculation - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" style="display: block;">
      <h1 id="toc0"><a name="Leccion-5-Logica-de-negocio-basica"></a> <span id="breadcrumbs">
          <span id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava
              </a> </span> / <a href="index_es.html">documentación</a> / </span>
        Lección 10: Propiedades de total con Calculation</h1>
      <strong>Curso</strong>: <a class="wiki_link" href="getting-started_es.html">1.
        Primeros pasos</a> | <a class="wiki_link" href="basic-domain-model1_es.html">2.
        Modelo básico del dominio (1)</a> | <a class="wiki_link" href="basic-domain-model2_es.html">3.
        Modelo básico del dominio (2)</a> | <a class="wiki_link" href="refining-user-interface_es.html">4.
        Refinar la interfaz de usuario</a> | <a class="wiki_link" href="agile-development_es.html">5.
        Desarrollo ágil</a> | <a class="wiki_link" href="mapped-superclass-inheritance_es.html">6.
        Herencia de superclases mapedas</a> | <a class="wiki_link" href="entity-inheritance_es.html">7.
        Herencia de entidades</a> | <a class="wiki_link" href="view-inheritance_es.html">8.
        Herencia de vistas</a> | <a class="wiki_link" href="java-properties_es.html">9.
        Propiedades Java</a> | <strong>10. Propiedades de total con Calculation</strong>
      | <a class="wiki_link" href="jpa-retrocalling-methods_es.html">11.
        Métodos de retrollamadas JPA</a> | <a class="wiki_link" href="validation_es.html">12.
        Validación avanzada</a> | <a class="wiki_link" href="refining-standard-behavior_es.html">13.
        Refinar el comportamiento predefinido</a> | <a class="wiki_link" href="business-logic-behavior_es.html">14.
        Comportamiento y lógica del negocio</a> | <a class="wiki_link" href="references-collections_es.html">15.
        Referencias y colecciones</a> | <a class="wiki_link" href="philosophy_es.html">A.
        Arquitectura y filosofía</a> | <a class="wiki_link" href="jpa_es.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_es.html">C.
        Anotaciones</a> | <a class="wiki_link" href="testing_es.html">D.
        Pruebas automáticas</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">Tabla de contenidos</h1>
        <div style="margin-left: 1em;"><a href="#Leccion-5-Logica-de-negocio-basica">Lección
            10: Propiedades de total con Calculation<br>
          </a></div>
        <div style="margin-left: 2em;"><a href="#Propiedades-calculadas-Propiedades-persistentes-con-Calculation">Propiedades
            persistentes con @Calculation</a></div>
        <span style="color: #0000ee;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </span><a

          href="#Propiedades-calculadas-Propiedades-de-total-de-una-coleccion">Propiedades
          de total de una colección</a>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Valor-por-defecto-desde-un-archivo-de-propiedades">Valor
            por defecto desde un archivo de propiedades</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Evolucion-de-esquema-manual">Evolución
            de esquema manual</a></div>
        <div style="margin-left: 2em;"><a href="#Resumen">Resumen</a></div>
      </div>
    </div>
    <div class="wiki" style="display: block;">Hemos logrado añadir a nuestra
      aplicación una propiedad calculada que nos permite añadir valores a la
      misma, y utilizamos @DefaultValueCalculator para almacenar dicho valor de
      cada producto en cada línea de detalle. Continuaremos mejorando nuestra
      aplicación de la siguiente manera:<br>
      <h2><a name="Propiedades-en-Java"></a>Propiedades persistentes con <i>@Calculation</i></h2>
      A veces las propiedades calculadas no son la mejor opción. Imagínate que
      tienes una propiedad calculada en <em>Factura</em>, digamos <em>descuento</em>:<br>
      <div class="wiki" style="display: block;">
        <pre><code class="java">// NO LO AÑADAS A TU CÓDIGO, ES SÓLO PARA ILUSTRAR
public BigDecimal getDescuento() {
    return getImporte().multiply(new BigDecimal("0.10"));
}
</code></pre> Si necesitas procesar todas las facturas cuyo descuento sea mayor
        de 1000, has de escribir un código como el siguiente:<br>
        <pre><code class="java">// NO LO AÑADAS A TU CÓDIGO, ES SÓLO PARA ILUSTRAR
Query query = getManager().createQuery("from Factura"); // Sin condición en la consulta
for (Object o: query.getResultList()) { // Itera por todos los objetos
    Factura f = (Factura) o;
    if (f.getDescuento() // Pregunta a cada objeto
        .compareTo(new BigDecimal("1000")) &gt; 0) {
            f.hacerAlgo();
    }
}
</code></pre> No puedes usar una condición en la consulta para discriminar por <i>descuento</i>,
        porque <i>descuento</i> no está en la base de datos, está sólo en el
        objeto Java, por lo que has de instanciar todos y cada uno de los
        objetos para poder preguntar por el <i>descuento</i>. En algunos casos
        esta forma es una buena opción, pero si tienes una cantidad inmensa de
        facturas y sólo unas pocas tiene el <i>descuento</i> mayor de 1000,
        entonces tu proceso va a ser muy ineficiente. ¿Qué alternativas tenemos?<br>
        Nuestra alternativa es usar la anotación <em>@Calculation</em>. <em>@Calculation</em>
        es una anotación OpenXava que permite asociar un cálculo simple a una
        propiedad persistente. Puedes definir <em>descuento</em> con <em>@Calculation</em>
        como se muestra en el siguiente código:<br>
        <pre><code class="java">// NO LO AÑADAS A TU CÓDIGO, ES SÓLO PARA ILUSTRAR
@ReadOnly
@Calculation("importe * 0.10")
BigDecimal descuento;
</code></pre> Esto es una propiedad persistente convencional, es decir con una
        columna correspondiente en la base de datos, pero tiene un cálculo
        definido con <i>@Calculation</i>. En este caso el cálculo es <i>importe
          * 0.10</i>, de tal manera que cuando el usuario cambia <i>importe</i>
        en la interfaz de usuario <i>descuento</i> se recalcula
        instantaneamente. El valor recalculado se graba en la base de datos
        cuando el usuario pulsa en <i>Grabar</i>, como con cualquier otra
        propiedad persistente. También hemos anotado <i>descuento</i> con <i>@ReadOnly</i>,
        por lo que parece y se comporta como una propiedad calculada, aunque
        puedes omitir <i>@ReadOnly</i> y así el usuario podría modificar el
        valor calculado.</div>
      <div class="wiki" style="display: block;"> Lo más útil de las propiedades
        <em>@Calculation</em> es que se pueden usar en las condiciones, por lo
        que puedes reescribir el proceso de arriba como se muestra en el
        siguiente código:<br>
        <pre><code class="java">// NO LO AÑADAS A TU CÓDIGO, ES SÓLO PARA ILUSTRAR
Query query = getManager().createQuery("from Factura f where f.descuento &gt; :descuento"); // Condición permitida
query.setParameter("descuento", new BigDecimal(1000));
for (Object o: query.getResultList()) { // Itera sólo por los objectos seleccionados
    Factura f = (Factura) o;
    f.hacerAlgo();
}
</code></pre>De esta manera ponemos el peso de seleccionar los registros en el
        servidor de la base de datos y no en el servidor Java. Además, los
        descuentos no se recalculan cada vez, sino que ya está calculados y
        grabados.<br>
        Este hecho tiene también efecto en el modo lista, porque el usuario no
        puede filtrar ni ordenar por las propiedades calculadas, pero sí que lo
        puede hacer usando propiedades persistentes con <em>@Calculation</em>:<br>
        <img src="files/business-logic_es025.png" alt="business-logic_es025.png"

          title="business-logic_es025.png"><br>
        <em>@Calculation</em> es una buena opción cuando necesitas filtrar y
        ordenar, y un cálculo simple es suficiente. Una desventaja de las
        propiedades con <i>@Calculation</i> es que sus valores se recalculan
        sólo cuando el usuario interactúa con el registro y cambia algún valor
        de las propiedades usadas en el cálculo, por lo tanto cuando añades una
        nueva propiedad <i>@Calculation</i> a una entidad con datos existente
        has de actualizar los valores de la nueva columna en la tabla usando
        SQL. Por otra parte si necesitas un cálculo complejo, con bucles o
        consultando otras entidades, todavía sigues necesitando una propiedad
        calculada con tu lógica Java en el getter. En este último caso si además
        necesitas ordenar y filtrar en modo lista por la propiedad calculada un
        opción es tener ambas, la calculada y la persistente, y sincronizar sus
        valores usando los métodos de retrollamada de JPA (hablaremos sobre los
        métodos de retrollamada más abajo).</div>
      <h3 id="toc4"><a name="Propiedades-calculadas-Propiedades-de-total-de-una-coleccion"></a>Propiedades
        de total de una colección</h3>
      También queremos añadir importes a <em>Pedido</em> y <em>Factura</em>.
      Tener IVA, importe base e importe total es indispensable. Para hacerlo
      sólo necesitas añadir unas pocas propiedades a la clase <i>DocumentoComercial</i>.
      La siguiente figura muestra la interfaz de usuario para estas propiedades:<br>
      <img src="files/business-logic_es030.png" alt="business-logic_es030.png" title="business-logic_es030.png"><br>
      Añade el siguiente código a la entidad <i>DocumentoComercial</i>:<br>
      <pre><code class="java">@Digits(integer=2, fraction=0) // Para indicar su tamaño
BigDecimal porcentajeIVA;
   
@ReadOnly
@Stereotype("DINERO")
@Calculation("sum(detalles.importe) * porcentajeIVA / 100")
BigDecimal iva;

@ReadOnly
@Stereotype("DINERO")
@Calculation("sum(detalles.importe) + iva")    
BigDecimal importeTotal;    
</code></pre> Fíjate como hemos escogido propiedades persistentes con <i>@Calculation
        + @ReadOnly</i> en lugar de propiedades calculadas para <i>iva</i> e <i>importeTotal</i>,
      porque los cálculos son simples, y filtrar y ordenar por ellos es muy
      útil. También, puedes ver como en <i>@Calculation</i> puedes usar <i>sum(detalles.importe)</i>
      para referirte a la suma de columna <i>importe</i> de la colección <i>detalles</i>,
      de esta manera podemos prescindir de una propiedad <i>importeBase</i>.
      Por otra parte, <em>porcentajeIVA</em> es un propiedad persistente
      convencional. En este caso usamos <em>@Digits</em> (una anotación de Bean
      Validation, el estándar de validación de Java) como una alternativa a <em>@Column</em>
      para especificar su tamaño. <br>
      Ahora que ya has escrito las propiedades para los importes de <em>DocumentoComercial</em>,
      tienes que modificar la lista de propiedades de la colección <em>detalles</em>
      para mostrar las <a class="wiki_link" href="view_es.html#Vista-Personalizacion+de+coleccion-Propiedades+de+total+%28nuevo+en+v4.3%29">propiedades
        de total</a> de <em>DocumentoComercial</em>. Veámoslo:<br>
      <pre><code class="java">abstract public class DocumentoComercial extends Identificable {
 
    @ElementCollection
    @ListProperties(
        "producto.numero, producto.descripcion, cantidad, precioPorUnidad, " +
        "importe+[" + 
        	"documentoComercial.porcentajeIVA," +
        	"documentoComercial.iva," +
        	"documentoComercial.importeTotal" +
        "]" 
    )	
    private Collection&lt;Detalle&gt; detalles;
 
    ...
}
</code></pre>Las propiedades de total son propiedades normales de la entidad (<i>DocumentoComercial</i>
      en este caso) que en la interfaz de usuario se localizan debajo de una
      columna de una colección. Para eso, en <i>@ListProperties</i> se usan
      corchetes después de la propiedad para enumerarlas, algo así como <i>importe[documentoComercial.importeTotal]</i>.
      Además, si simplemente quieres la suma de la columna no necesitas una
      propiedad para ello, con un + después de la propiedad en <i>@ListProperties</i>
      es suficiente, como <i>importe+</i>. En nuestro caso combinamos ambas
      cosas, + y propiedades de total entre [ ].</div>
    <div class="wiki" style="display: block;">Ahora puedes probar tu aplicación.
      Debería funcionar casi como en la figura del inicio de esta sección.
      “Casi” porque <em>porcentajeIVA</em> todavía no tiene un valor por
      defecto. Lo añadiremos en la siguiente sección.<br>
      <h3 id="toc5"><a name="Propiedades-calculadas-Valor-por-defecto-desde-un-archivo-de-propiedades"></a>Valor
        por defecto desde un archivo de propiedades</h3>
      Es conveniente para el usuario tener el campo <em>porcentajeIVA</em>
      lleno por defecto con un valor adecuado. Podrías usar un calculador (<em>@DefaultValueCalculator</em>)
      que devuelva un valor fijo, pero en ese caso cambiar el valor por defecto
      implica cambiar el código fuente. O podrías leer el valor por defecto de
      una base de datos (usando JPA desde tu calculador), pero en ese caso
      cambiar el valor por defecto implica actualizar la base de datos.<br>
      Otra opción es tener estos valores de configuración en un archivo de
      propiedades, un archivo plano con pares clave=valor. En este caso cambiar
      el valor por defecto de <em>porcentajeIVA</em> es tan simple como editar
      un archivo plano con un editor de texto.<br>
      Implementemos la opción del archivo de propiedades. Crea un archivo
      llamado <em>facturacion.properties</em> en la carpeta <em>Facturacion/properties</em>
      con el siguiente contenido:<br>
      <pre><code class="properties">porcentajeIVADefecto=21
</code></pre> Aunque puedes usar la clase <em>java.util.Properties</em> de Java
      para leer este archivo preferimos usar una clase propia para leer estas
      propiedades. Vamos a llamar a esta clase <em>PreferenciasFacturacion</em>
      y la pondremos en un nuevo paquete llamado <em>com.tuempresa.facturacion.util</em>.
      Veamos el código:<br>
      <pre><code class="java">package com.tuempresa.facturacion.util; // En el paquete 'util'
 
import java.io.*;
import java.math.*;
import java.util.*;
import org.apache.commons.logging.*;
import org.openxava.util.*;
 
public class PreferenciasFacturacion {
 
    private final static String ARCHIVO_PROPIEDADES="facturacion.properties";
    private static Log log = LogFactory.getLog(PreferenciasFacturacion.class);
 
    private static Properties propiedades; // Almacenamos las propiedades aquí
 
    private static Properties getPropiedades() {
        if (propiedades == null) { // Usamos inicialización vaga
            PropertiesReader reader = // PropertiesReader es una clase de OpenXava
                new PropertiesReader(
                    PreferenciasFacturacion.class, ARCHIVO_PROPIEDADES);
            try {
                propiedades = reader.get();
            }
            catch (IOException ex) {
                log.error(
                    XavaResources.getString( // Para leer un mensaje i18n
                        "properties_file_error",
                        ARCHIVO_PROPIEDADES),
                    ex);
                  propiedades = new Properties();
             }
        }
        return propiedades;
    }
 
    public static BigDecimal getPorcentajeIVADefecto() { // El único método público
        return new BigDecimal(getPropiedades().getProperty("porcentajeIVADefecto"));
    }
}
</code></pre> Como puedes ver <em>PreferenciasFacturacion</em> es una clase con
      un método estático, <em>getPorcentajeIVADefecto()</em>. La ventaja de
      usar esta clase en lugar de leer directamente del archivo de propiedades
      es que si cambias la forma en que se obtienen las preferencias, por
      ejemplo leyendo de una base de datos o de un directorio LDAP, solo has de
      cambiar esta clase en toda tu aplicación.<br>
      Puedes usar esta clase desde el calculador por defecto para la propiedad <em>porcentajeIVA</em>.
      Aquí tienes el código del calculador:<br>
      <pre><code class="java">package com.tuempresa.facturacion.calculadores; // En el paquete 'calculadores'
 
import org.openxava.calculators.*; // Para usar 'ICalculator'
import com.tuempresa.facturacion.util.*; // Para usar 'PreferenciasFacturacion'
 
public class CalculadorPorcentajeIVA implements ICalculator {
 
    public Object calculate() throws Exception {
        return PreferenciasFacturacion.getPorcentajeIVADefecto();
    }
}
</code></pre> Como ves, simplemente devuelve <em>porcentajeIVADefecto</em> de <em>PreferenciasFacturacion</em>.
      Ahora, ya puedes usar este calculador en la definición de la propiedad <em>porcentajeIVA</em>
      en <em>DocumentoComercial</em>. Mira el código:<br>
      <pre><code class="java">@DefaultValueCalculator(CalculadorPorcentajeIVA.class)
BigDecimal porcentajeIVA;
</code></pre> Con este código cuando el usuario pulsa para crear una nueva
      factura, el campo <em>porcentajeIVA</em> se rellenará con 21, o cualquier
      otro valor que hayas puesto en <em>facturacion.properties</em>.</div>
    <div class="wiki" style="display: block;">
      <h3><a name="Propiedades-calculadas-Evolucion-de-esquema-manual"></a>Evolución
        de esquema manual</h3>
      Cuando usamos cosas como <i>@Calculation</i> o <i>@DefaultValueCalculator</i>
      la evolución de esquema automática que provee OpenXava se nos queda corta,
      porque añade una nueva columna cuando tu añades una nueva propiedad, pero
      no rellena la columna con los valores correctos. En este caso hemos
      añadido varias propiedades persistentes con <i>@Calculation</i> cuyos
      valores no se recalculan hasta que el usuario interactua con el registro.
      Además, tenemos un valor por defecto para <i>porcentajeIVA</i> que sólo
      tiene efecto cuando el usuario crea un nuevo registro pero no en los
      registros ya existentes. Hemos de rellenar las nuevas columnas con valores
      razonables.
      <div class="wiki" style="display: block;">Dado que estamos en una etapa
        temprana del desarrollo una buena opción sería borrar todos los
        registros, pero es seguro que esto no es una buena idea para producción,
        por tanto vamos a ajustar nuestra base de datos al nuevo código sin
        perder información para ilustrar la evolución manual de esquema.</div>
      <div class="wiki" style="display: block;">Lo más fácil es usar la propia
        aplicación para hacer las actualizaciones. Vamos a hacerlo para
        actualizar los precios de los productos. Para que las nuevas propiedades
        calculadas funcionen bien todos los productos deberían tener un precio,
        por tanto ve al módulo <i>Producto</i> con tu navegador y asegurate de
        que todos los productos tienen precio:</div>
      <img src="files/business-logic_es040.png" alt="business-logic_es040.png" title="business-logic_es040.png">
      <div class="wiki" style="display: block;">Si algún producto no tiene
        precio edítalo e introduce un precio.</div>
      <div class="wiki" style="display: block;">Los siguientes cambios no son
        tan sencillos, por lo que vamos a ejecutar sentencias SQL contra nuestra
        base de datos. Para ejecutar estas sentencias SQL, primero asegurate de
        que tu aplicación se está ejecutando, después usa la opción de menú <i>OpenXava
          &gt; Database Manager</i> de OpenXava Studio::<br>
        <img src="files/inheritance040.png" alt="inheritance040.png" title="inheritance040.png"><br>
        Ahora estás listo para escribir y ejecutar SQLs. Primero, establecemos
        el valor para la columna <i>precioPorUnidad</i> en todos los detalles:
      </div>
      <div class="wiki" style="display: block;">
        <pre><code class="sql">UPDATE FACTURACION.DOCUMENTOCOMERCIAL_DETALLES 
SET PRECIOPORUNIDAD = (
    SELECT PRECIO FROM FACTURACION.PRODUCTO 
    WHERE NUMERO = PRODUCTO_NUMERO
)
</code></pre> </div>
      <div class="wiki" style="display: block;">Ahora actualizamos <i>porcentajeIVA</i>
        para todas las facturas:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="sql">UPDATE FACTURACION.DOCUMENTOCOMERCIAL
SET PORCENTAJEIVA = 21
</code></pre> </div>
      <div class="wiki" style="display: block;">Lo siguiente es actualizar <i>iva</i>:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="sql">UPDATE FACTURACION.DOCUMENTOCOMERCIAL
SET IVA = (
    SELECT SUM(PRECIOPORUNIDAD * CANTIDAD) * 0.21 
    FROM FACTURACION.DOCUMENTOCOMERCIAL_DETALLES D 
    WHERE D.DOCUMENTOCOMERCIAL_OID = DOCUMENTOCOMERCIAL.OID
)
</code></pre> </div>
      <div class="wiki" style="display: block;">Finalmente, actualizamos <i>importeTotal</i>
        en todas las facturas:</div>
      <div class="wiki" style="display: block;">
        <pre><code class="sql">UPDATE FACTURACION.DOCUMENTOCOMERCIAL
SET IMPORTETOTAL = (
    SELECT SUM(PRECIOPORUNIDAD * CANTIDAD) * 1.21 
    FROM FACTURACION.DOCUMENTOCOMERCIAL_DETALLES D 
    WHERE D.DOCUMENTOCOMERCIAL_OID = DOCUMENTOCOMERCIAL.OID
)
</code></pre> </div>
      <div class="wiki" style="display: block;">Ten cuidado, las setencias de
        arriba funciona bien con HSQLDB, la base de datos incluida con OpenXava.
        Si usas otra base de datos probablemente tengas que adaptar la sintaxis.
        Después de ejecutar estas sentencias puedes probar tu aplicación.
        Debería funcionar como en la figura al principio de la sección
        "Propiedades de total de una colección" incluso para facturas y pedidos
        ya existentes.</div>
    </div>
    <br>
    <div class="wiki" style="display: block;">
      <h2 id="toc14"><a name="Resumen"></a>Resumen</h2>
      <p>En esta lección, has aprendido a utilizar la anotación @Calculation
        para asociar un cálculo simple a una propiedad persistente, mejorando de
        manera notable la eficiencia y velocidad de respuesta al consultar y
        permitiéndonos agregar diferentes funcionalidades a total, como el
        cálculo de IVA. También aprendimos como agregar valores por defecto, y
        como modificar de manera manual el esquema de nuestra base de datos. En
        la próxima lección, revisaremos diferentes métodos de retrollamadas JPA,
        sincronizar propiedades persistentes y calculadas y utilizar la
        anotación @Formula.</p>
      <br>
      <strong>¿Problemas con la lección? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/437013/"

          rel="nofollow">Pregunta en el foro</a></strong> <strong>¿Ha ido bien?
        <a class="wiki_link" href="jpa-retrocalling-methods_es.html">Ve a la
          lección 11</a></strong> </div>
  </body>
</html>
