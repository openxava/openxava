<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Apéndice D: Pruebas automáticas - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <h1 id="toc0"> <span id="breadcrumbs"> <span id="openxava"> <a href="https://www.openxava.org/">
              <span>o</span>pen<span>x</span>ava </a> </span> / <a href="index_es.html">documentación</a>
          / </span> Apéndice D: Pruebas automáticas</h1>
      <strong>Curso</strong>: <a class="wiki_link" href="getting-started_es.html">1.
        Primeros pasos</a> | <a class="wiki_link" href="basic-domain-model1_es.html">2.
        Modelo básico del dominio (1)</a> | <a class="wiki_link" href="basic-domain-model2_es.html">3.
        Modelo básico del dominio (2)</a> | <a class="wiki_link" href="refining-user-interface_es.html">4.
        Refinar la interfaz de usuario</a> | <a class="wiki_link" href="agile-development_es.html">5.
        Desarrollo ágil</a> | <a class="wiki_link" href="mapped-superclass-inheritance_es.html">6.
        Herencia de superclases mapedas</a> | <a class="wiki_link" href="entity-inheritance_es.html">7.
        Herencia de entidades</a> | <a class="wiki_link" href="view-inheritance_es.html">8.
        Herencia de vistas</a> | <a class="wiki_link" href="java-properties_es.html">9.
        Propiedades Java</a> | <a class="wiki_link" href="total-properties-with-calculation_es.html">10.
        Propiedades de total con </a><a class="wiki_link" href="total-properties-with-calculation_en.html">@</a><a
        class="wiki_link" href="total-properties-with-calculation_es.html">Calculation</a>
      | <a class="wiki_link" href="jpa-callback-methods_es.html">11. Métodos de
        retrollamadas JPA</a> | <a class="wiki_link" href="validation_es.html">12.
        Validación avanzada</a> | <a class="wiki_link" href="refining-standard-behavior_es.html">13.
        Refinar el comportamiento predefinido</a> | <a class="wiki_link" href="business-logic-behavior_es.html">14.
        Comportamiento y lógica del negocio</a> | <a class="wiki_link" href="references-collections_es.html">15.
        Referencias y colecciones</a> | <a class="wiki_link" href="philosophy_es.html">A.
        Arquitectura y filosofía</a> | <a class="wiki_link" href="jpa_es.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_es.html">C.
        Anotaciones</a> | <strong>D. Pruebas automáticas</strong>
      <hr>
      <div id="toc">
        <h1 class="nopad">Tabla de contenidos</h1>
        <div style="margin-left: 1em;"><a href="#Leccion+3:+Pruebas+automaticas">Apéndice
            D: Pruebas automáticas</a></div>
        <div style="margin-left: 2em;"><a href="#Leccion+3:+Pruebas+automaticas-JUnit">JUnit</a></div>
        <div style="margin-left: 2em;"><a href="#Leccion+3:+Pruebas+automaticas-ModuleTestBase+para+probar+modulos">ModuleTestBase
            para probar módulos</a></div>
        <div style="margin-left: 3em;"><a href="#Leccion+3:+Pruebas+automaticas-ModuleTestBase+para+probar+modulos-El+codigo+para+la+prueba">El
            código para la prueba</a></div>
        <div style="margin-left: 3em;"><a href="#Leccion+3:+Pruebas+automaticas-ModuleTestBase+para+probar+modulos-Ejecutar+las+pruebas+desde+OpenXava+Studio">Ejecutar
            las pruebas desde OpenXava Studio</a></div>
        <div style="margin-left: 2em;"><a href="#Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA">Crear
            datos de prueba usando JPA</a></div>
        <div style="margin-left: 3em;"><a href="#Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA-Los+metodos+setUp%28%29+y+tearDown%28%29">Los
            métodos setUp() y tearDown()</a></div>
        <div style="margin-left: 3em;"><a href="#Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA-Crear+datos+con+JPA">Crear
            datos con JPA</a></div>
        <div style="margin-left: 3em;"><a href="#Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA-Borrar+datos+con+JPA">Borrar
            datos con JPA</a></div>
        <div style="margin-left: 3em;"><a href="#Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA-Filtrar+datos+desde+modo+lista+en+una+prueba">Filtrar
            datos desde modo lista en una prueba</a></div>
        <div style="margin-left: 3em;"><a href="#Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA-Usar+instancias+de+entidad+dentro+de+una+prueba">Usar
            instancias de entidad dentro de una prueba</a></div>
        <div style="margin-left: 2em;"><a href="#Leccion+3:+Pruebas+automaticas-Usar+datos+ya+existentes+para+probar">Usar
            datos ya existentes para probar</a></div>
        <div style="margin-left: 2em;"><a href="#Leccion+3:+Pruebas+automaticas-Probar+colecciones">Probar
            colecciones</a></div>
        <div style="margin-left: 3em;"><a href="#Leccion+3:+Pruebas+automaticas-Probar+colecciones-Dividir+la+prueba+en+varios+metodos">Dividir
            la prueba en varios métodos</a></div>
        <div style="margin-left: 3em;"><a href="#Leccion+3:+Pruebas+automaticas-Probar+colecciones-Verificar+valores+por+defecto">Verificar
            valores por defecto</a></div>
        <div style="margin-left: 3em;"><a href="#Leccion+3:+Pruebas+automaticas-Probar+colecciones-Entrada+de+datos">Entrada
            de datos</a></div>
        <div style="margin-left: 3em;"><a href="#Leccion+3:+Pruebas+automaticas-Probar+colecciones-Verificar+los+datos">Verificar
            los datos</a></div>
        <div style="margin-left: 2em;"><a href="#Leccion+3:+Pruebas+automaticas-Suite">Suite</a></div>
        <div style="margin-left: 2em;"><a href="#codigo-fuente-hasta-la-leccion-5">Código
            fuente hasta la lección 5</a></div>
        <div style="margin-left: 2em;"><a href="#Herencia-en-las-pruebas-JUnit">Herencia
            en las pruebas JUnit</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-en-las-pruebas-JUnit-Crear-una-prueba-de-modulo-abstracta">Crear
            una prueba de módulo abstracta</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-en-las-pruebas-JUnit-Prueba-base-abstracta-para-crear-pruebas-de-modulo-concretas">Prueba
            base abstracta para crear pruebas de módulo concretas</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-en-las-pruebas-JUnit-Anadir-nuevas-pruebas-a-las-pruebas-de-modulo-extendidas">Añadir
            nuevas pruebas a las pruebas de módulo extendidas</a></div>
        <div style="margin-left: 2em;"><a href="#probar-logica-de-negocio-basica">Probar
            lógica de negocio básica</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Modificar-la-prueba-existente">Modificar
            la prueba existente</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Verificar-valores-por-defecto-propiedades-calculadas-y-Calculation">Verificar
            valores por defecto, propiedades calculadas y @Calculation</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Verificar-Formula">Verificar
            @Formula</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Probar-sincronizacion-de-propiedades-calculadas-y-persistentes">Probar
            sincronización de propiedades calculadas y persistentes</a></div>
        <div style="margin-left: 2em;"><a href="#probar-validacion">Probar
            validación</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Probar-la-validacion-al-anadir-a-una-coleccion">Probar
            la validación al añadir a una colección</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Probar-validacion-al-asignar-una-referencia-y-al-borrar">Probar
            validación al asignar una referencia y al borrar</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Probar-el-Bean-Validation-propio">Probar
            el Bean Validation propio</a></div>
        <div style="margin-left: 2em;"><a href="#probar-refinar-el-comportamiento-predefinido">Probar
            refinar el comportamiento predefinido</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Probar-el-comportamiento-personalizado-para-borrar">Probar
            el comportamiento personalizado para borrar</a></div>
        <div style="margin-left: 3em;"><a href="#Pruebas-JUnit-Probar-varios-modulos-en-el-mismo-metodo-de-prueba">Probar
            varios módulos en el mismo método de prueba</a></div>
        <div style="margin-left: 2em;"><a href="#probar-comportamiento-y-logica-de-negocio">Probar
            comportamiento y lógica de negocio</a></div>
        <div style="margin-left: 3em;"><a href="#probar-la-accion-de-modo-detalle">Probar
            la acción de modo detalle</a></div>
        <div style="margin-left: 3em;"><a href="#buscar-una-entidad-para-la-prueba-usando-el-modo-lista-y-jpa">Buscar
            una entidad para la prueba usando el modo lista y JPA</a></div>
        <div style="margin-left: 3em;"><a href="#probar-que-la-accion-se-oculta-cuando-no-aplica">Probar
            que la acción se oculta cuando no aplica</a></div>
        <div style="margin-left: 3em;"><a href="#probar-la-accion-de-modo-lista">Probar
            la acción de modo lista</a></div>
        <div style="margin-left: 3em;"><a href="#verificar-datos-de-prueba">Verificar
            datos de prueba</a></div>
        <div style="margin-left: 3em;"><a href="#probar-casos-excepcionales">Probar
            casos excepcionales</a></div>
        <div style="margin-left: 2em;"><a href="#probar-referencias-y-colecciones">Probar
            referencias y colecciones</a></div>
        <div style="margin-left: 3em;"><a href="#adaptar-pruebapedido">Adaptar
            PruebaPedido</a></div>
        <div style="margin-left: 3em;"><a href="#probar-searchaction">Probar
            @SearchAction</a></div>
        <div style="margin-left: 3em;"><a href="#probar-onchangesearch">Probar
            @OnChangeSearch</a></div>
        <div style="margin-left: 3em;"><a href="#adaptar-pruebafactura">Adaptar
            PruebaFactura</a></div>
        <div style="margin-left: 3em;"><a href="#probar-addaction">Probar
            @AddAction</a></div>
        <div style="margin-left: 3em;"><a href="#probar-la-accion-para-anadir-elementos-a-la-coleccion">Probar
            la acción para añadir elementos a la colección</a></div>
        <div style="margin-left: 2em;"><a href="#resumen">Resumen</a></div>
      </div>
      Las pruebas son la parte más importante del desarrollo de software. No
      importa cuan bonita, rápida o tecnológicamente avanzada sea tu aplicación,
      si falla, darás una impresión muy pobre.<br>
      Hacer pruebas manuales, es decir, abrir el navegador y ejecutar la
      aplicación exactamente como lo haría un usuario final, no es viable;
      porque el problema real no está en el código que acabas de escribir, sino
      en el código que ya estaba ahí. Normalmente pruebas el código que acabas
      de escribir, pero no pruebas todo el código que ya existe en tu
      aplicación. Y sabes muy bien que cuando tocas cualquier parte de tu
      aplicación puedes romper cualquier otra parte inadvertidamente.<br>
      Necesitas poder hacer cualquier cambio en tu código con la tranquilidad de
      que no vas a romper tu aplicación. Una forma de conseguirlo, es usando
      pruebas automáticas. Vamos a hacer pruebas automáticas usando JUnit.</div>
    <div class="wiki" style="display: block;"><b><span style="color: green;">El
          código fuente a partir de aquí es para ponerlo encima del código de la
          sección <i>Modelar con Java</i> (lección 5), hasta nuevo aviso.</span></b>
      <h2 id="toc1"><a name="Leccion+3:+Pruebas+automaticas-JUnit"></a>JUnit</h2>
      JUnit es una herramienta muy popular para hacer pruebas automáticas. Esta
      herramienta está integrada con OpenXava Studio, por tanto no necesitas
      descargarla para poder usarla. OpenXava extiende las capacidades de JUnit
      para permitir probar un módulo de OpenXava exactamente de la misma forma
      que lo haría un usuario final. De hecho, OpenXava usa HtmlUnit, un
      software que simula un navegador real (incluyendo JavaScript) desde Java.
      Todo está disponible desde la clase de OpenXava <em>ModuleTestBase</em>,
      que te permite automatizar las pruebas que tú harías a mano usando un
      navegador de verdad de una forma simple.<br>
      La mejor manera de entender como funcionan las pruebas en OpenXava es
      verlo en acción.<br>
      <h2 id="toc2"><a name="Leccion+3:+Pruebas+automaticas-ModuleTestBase+para+probar+modulos"></a>ModuleTestBase
        para probar módulos</h2>
      Para crear una prueba para un módulo de OpenXava extendemos de la clase <em>ModuleTestBase</em>
      del paquete <em>org.openxava.tests</em>. Esta clase te permite conectar
      con un módulo OpenXava como un navegador real, y tiene muchos métodos
      útiles para probar tu módulo. Creemos la prueba para tu módulo <em>Cliente</em>.<br>
      <h3 id="toc3"><a name="Leccion+3:+Pruebas+automaticas-ModuleTestBase+para+probar+modulos-El+codigo+para+la+prueba"></a>El
        código para la prueba</h3>
      Crea un paquete nuevo llamado <em>com.tuempresa.facturacion.pruebas</em>
      y dentro de él una nueva clase llamada <em>PruebaCliente</em> con el
      siguiente código:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.pruebas;
 
import org.openxava.tests.*;
 
public class PruebaCliente extends ModuleTestBase { // Ha de extender de ModuleTestBase
 
    public PruebaCliente(String nombrePrueba) {
        super(nombrePrueba, "Facturacion", // Indicamos el nombre de aplicación (Facturacion)
                "Cliente"); // y nombre de módulo (Cliente)
    }
 
    // Los métodos de prueba han de empezar por 'test'
    public void testCrearLeerActualizarBorrar() throws Exception {
        login("admin", "admin"); // Identificación de usuario para acceder al módulo
 
        // Crear
        execute("CRUD.new"); // Pulsa el botón 'Nuevo'
        setValue("numero", "77"); // Teclea 77 como valor para el campo 'numero'
        setValue("nombre", "Cliente JUNIT"); // Pone valor en el campo 'nombre'
        setValue("direccion.viaPublica", "Calle JUNIT"); // Fíjate en la notación del punto
                                                // para acceder al miembro de la referencia
        setValue("direccion.codigoPostal", "77555"); // Etc
        setValue("direccion.municipio", "La ciudad JUNIT"); // Etc
        setValue("direccion.provincia", "La provincia JUNIT"); // Etc
        execute("CRUD.save"); // Pulsa el botón 'Grabar'
        assertNoErrors(); // Verifica que la aplicación no muestra errores
        assertValue("numero", ""); // Verifica que el campo 'numero' está vacío
        assertValue("nombre", ""); // Verifica que el campo 'nombre' está vacío
        assertValue("direccion.viaPublica", ""); // Etc
        assertValue("direccion.codigoPostal", ""); // Etc
        assertValue("direccion.municipio", ""); // Etc
        assertValue("direccion.provincia", ""); // Etc
 
        // Leer
        setValue("numero", "77"); // Pone 77 como valor para el campo 'numero'
        execute("CRUD.refresh"); // Pulsa el botón 'Refrescar'
        assertValue("numero", "77"); // Verifica que el campo 'numero' tiene un 77
        assertValue("nombre", "Cliente JUNIT"); // y 'nombre' tiene 'Cliente JUNIT'
        assertValue("direccion.viaPublica", "Calle JUNIT"); // Etc
        assertValue("direccion.codigoPostal", "77555"); // Etc
        assertValue("direccion.municipio", "La ciudad JUNIT"); // Etc
        assertValue("direccion.provincia", "La provincia JUNIT"); // Etc
 
        // Actualizar
        setValue("nombre", "Cliente JUNIT MODIFICADO"); // Cambia el valor del campo 'nombre'
        execute("CRUD.save"); // Pulsa el botón 'Grabar'
        assertNoErrors(); // Verifica que la aplicación no muestra errores
        assertValue("numero", ""); // Verifica que el campo 'numero' está vacío
        assertValue("nombre", ""); // Verifica que el campo 'nombre' está vacío
 
        // Verifica si se ha modificado
        setValue("numero", "77"); // Pone 77 como valor para el campo 'numero'
        execute("CRUD.refresh"); // Pulsa en el botón 'Refrescar'
        assertValue("numero", "77"); // Verifica que el campo 'numero' tiene un 77
        assertValue("nombre", "Cliente JUNIT MODIFICADO"); // y 'nombre' tiene
                                                        // 'Cliente JUNIT MODIFICADO'
        // Borrar
        execute("CRUD.delete"); // Pulsa en el botón 'Borrar'
        assertMessage("Cliente borrado satisfactoriamente"); // Verifica que el mensaje
                                // 'Cliente borrado satisfactoriamente' se muestra al usuario
    }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Esta prueba crea un nuevo cliente,
      lo busca, lo modifica y al final lo borra. Aquí ves como puedes usar
      métodos como <em>execute()</em> o <em>setValue()</em> para simular las
      acciones del usuario, y métodos como <em>assertValue()</em>, <em>assertNoErrors()</em>
      o <em>assertMessage()</em> para verificar el estado de la interfaz de
      usuario. Tu prueba actúa como las manos y los ojos del usuario:<br>
      <img src="files/testing_es010.png" alt="testing_es010.png" title="testing_es010.png"><br>
      En <em>execute()</em> tienes que especificar el nombre calificado de la
      acción, esto quiere decir <em>NombreControlador.nombreAccion</em>. ¿Cómo
      puedes saber el nombre de la acción? Pasea tu ratón sobre el vínculo de la
      acción y verás en la barra inferior de tu navegador un código JavaScript
      que incluye el nombre calificado de la acción:<br>
      <img src="files/testing_es020.png" alt="testing_es020.png" title="testing_es020.png"><br>
      Ahora ya sabes como crear una prueba para probar las operaciones de
      mantenimiento básicas de un módulo. No es necesario escribir una prueba
      demasiado exhaustiva al principio. Simplemente prueba las cosas básicas,
      aquellas cosas que normalmente probarías con un navegador. Tu prueba
      crecerá de forma natural a medida que tu aplicación crezca y los usuarios
      vayan encontrando fallos.<br>
      Aprendamos como ejecutar tu prueba desde OpenXava Studio.<br>
      <h3 id="toc4"><a name="Leccion+3:+Pruebas+automaticas-ModuleTestBase+para+probar+modulos-Ejecutar+las+pruebas+desde+OpenXava+Studio"></a>Ejecutar
        las pruebas desde OpenXava Studio</h3>
      JUnit está integrado dentro del OpenXava Studio, por eso ejecutar tus
      pruebas es más fácil que quitarle un caramelo a un niño. Para que la
      prueba funcione tu aplicación tiene que estar ejecutándose, si no es el
      caso iníciala antes de nada. Para ejecutar la prueba pon el ratón sobre tu
      clase de prueba, <i>PruebaCliente</i>, y con el botón derecho escoge <em>Run
        As &gt; JUnit Test</em>:<br>
      <img src="files/testing_es030.png" alt="testing_es030.png" title="testing_es030.png"
        style="height: 285px; width: 800px;"><br>
      Si la prueba no es satisfactoria la barra sale roja. Puedes probarlo.
      Edita <em>PruebaCliente</em> y comenta la línea que da valor al campo <em>nombre</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">...
setValue("numero", "77");
// setValue("nombre", "Cliente JUNIT"); // Comenta esta línea
setValue("direccion.viaPublica", "Calle JUNIT");
...
</code></pre> </div>
    <div class="wiki" style="display: block;">Ahora, reejecuta la prueba. Ya que
      <em>nombre</em> es una propiedad requerida, un mensaje de error será
      mostrado al usuario, y el objeto no se grabará:<br>
      <img src="files/testing_es040.png" alt="testing_es040.png" title="testing_es040.png"><br>
      El assert culpable es <em>assertNoErrors()</em>, el cual además de fallar
      muestra en la consola los errores mostrados al usuario. Por eso, en la
      consola de ejecución de tu prueba verás un mensaje como este:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="plaintext">16-jul-2019 18:03 org.openxava.tests.ModuleTestBase assertNoMessages
SEVERE: Error unexpected: Es ogligado que Nombre en Cliente tenga valor
</code></pre> </div>
    <div class="wiki" style="display: block;">El problema es claro. El cliente
      no se ha grabado porque el nombre es obligatorio y éste no se ha
      especificado.<br>
      Has aprendido como se comporta la prueba cuando falla. Ahora, puedes
      descomentar la línea culpable y volver a ejecutar la prueba para verificar
      que todo sigue en su sitio.<br>
      <h2 id="toc5"><a name="Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA"></a>Crear
        datos de prueba usando JPA</h2>
      En tu primera prueba, <em>PruebaCliente</em>, la prueba misma empieza
      creando los datos que van a ser usados en el resto de la prueba. Este es
      un buen enfoque, especialmente si quieres probar la entrada de datos
      también. Pero a veces te interesa probar solo un pequeño caso que falla, o
      simplemente tu módulo no permite entrada de datos. En cualquier caso
      puedes crear los datos que necesites para probar usando JPA desde tu
      prueba.<br>
      <h3 id="toc6"><a name="Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA-Los+metodos+setUp()+y+tearDown()"></a>Los
        métodos setUp() y tearDown()</h3>
      Vamos a usar <em>PruebaProducto</em> para aprender como usar JPA para
      crear datos de prueba. Crearemos algunos productos antes de ejecutar cada
      prueba y los borraremos después. Veamos el código de <em>PruebaProducto</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.pruebas;
 
import java.math.*;
import com.tuempresa.facturacion.modelo.*;
import org.openxava.tests.*;
import static org.openxava.jpa.XPersistence.*;
 
public class PruebaProducto extends ModuleTestBase {
 
    private Autor autor; // Declaramos las entidades a crear
    private Categoria categoria; // como miembros de instancia para que
    private Producto producto1; // estén disponibles en todos los métodos de prueba
    private Producto producto2; // y puedan ser borradas al final de cada prueba
 
    public PruebaProducto(String testName) {
        super(testName, "Facturacion", "Producto");
    }
 
    protected void setUp() throws Exception { // setUp() se ejecuta siempre antes de cada prueba
        super.setUp(); // Es necesario porque ModuleTestBase lo usa para inicializarse, JPA se inicializa aquí
        crearProductos(); // Crea los datos usados en las pruebas
    }
 
    protected void tearDown() throws Exception { // tearDown() se ejecuta
                                                 // siempre después de cada prueba
        super.tearDown(); // Necesario, ModuleTestBase cierra recursos aquí
        borrarProductos(); // Se borran los datos usados en las pruebas
    }
 
    public void testBorrarDesdeLista() throws Exception { ... }
 
    public void testSubirFotos() throws Exception { ... }
 
    private void crearProductos() { ... }
 
    private void borrarProductos() { ... }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Aquí estamos sobrescribiendo los
      métodos <em>setUp()</em> y <em>tearDown()</em>. Estos métodos son
      métodos de JUnit que son ejecutados justo antes y después de ejecutar cada
      método de prueba. Creamos los datos de prueba antes de ejecutar cada
      prueba y borramos los datos después de cada prueba. Así, cada prueba puede
      contar con unos datos concretos para ejecutarse. No importa si otras
      pruebas borran o modifican datos o el orden de ejecución de las pruebas.
      Siempre, al principio de cada método de prueba tenemos todos los datos
      listos para usar.<br>
      <h3 id="toc7"><a name="Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA-Crear+datos+con+JPA"></a>Crear
        datos con JPA</h3>
      El método <em>crearProductos()</em> es el responsable de crear los datos
      de prueba usando JPA. Examinémoslo:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void crearProductos() {
    // Crear objetos Java
    autor = new Autor(); // Se crean objetos de Java convencionales
    autor.setNombre("JUNIT Author"); // Usamos setters como se suele hacer con Java
    categoria = new Categoria();
    categoria.setDescripcion("Categoria JUNIT");
    producto1 = new Producto();
    producto1.setNumero(900000001);
    producto1.setDescripcion("Producto JUNIT 1");
    producto1.setAutor(autor);
    producto1.setCategoria(categoria);
    producto1.setPrecio(new BigDecimal("10"));
    producto2 = new Producto();
    producto2.setNumero(900000002);
    producto2.setDescripcion("Producto JUNIT 2");
    producto2.setAutor(autor);
    producto2.setCategoria(categoria);
    producto2.setPrecio(new BigDecimal("20"));
 
    // Marcar los objetos como persistentes
    getManager().persist(autor); // getManager() es de XPersistence
    getManager().persist(categoria); // persist() marca el objeto como persistente
    getManager().persist(producto1); // para que se grabe en la base de datos
    getManager().persist(producto2);
 
    // Confirma los cambios en la base de datos
    commit(); // commit() es de XPersistence. Graba todos los objetos en la base de datos
              // y confirma la transacción
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Como puedes ver, primero creas los
      objetos al estilo convencional de Java. Fíjate que los asignamos a
      miembros de instancia, así puedes usarlos dentro de la prueba. Entonces,
      los marcas como persistentes, usando el método <em>persist()</em> del <em>EntityManager</em>
      de JPA. Para obtener el <em>PersistenceManager</em> solo has de escribir
      <em>getManager()</em> porque tienes un import estático arriba:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">import static org.openxava.jpa.XPersistence.*;
...
getManager().persist(autor);
    // Gracias al static import de XPersistence es lo mismo que
XPersistence.getManager().persist(autor);
...
commit();
    // Gracias al static import de XPersistence es lo mismo que
XPersistence.commit();
</code></pre> </div>
    <div class="wiki" style="display: block;">Para finalizar, <em>commit()</em>
      (también de <em>XPersistence</em>) graba todos los objetos a la base de
      datos y entonces confirma la transacción. Después de eso, los datos ya
      están en la base de datos listos para ser usados por tu prueba.<br>
      <h3 id="toc8"><a name="Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA-Borrar+datos+con+JPA"></a>Borrar
        datos con JPA</h3>
      Después de que se ejecute la prueba borraremos los datos de prueba para
      dejar la base de datos limpia. Esto se hace en el método <em>borrarProductos()</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void borrarProductos() { // Llamado desde tearDown()
                                 // por tanto ejecutado después de cada prueba
    borrar(producto1, producto2, autor, categoria); // borrar() borra
    commit(); // Confirma los cambios en la base de datos, en este caso borrando datos
}
 
private void borrar(Object ... entidades) { // Usamos argumentos varargs
    for (Object entidad : entidades) { // Iteramos por todos los argumentos
        getManager().remove(getManager().merge(entidad)); // Borrar(1)
    }
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Es un simple bucle por todas las
      entidades usadas en la prueba, borrándolas. Para borrar una entidad con
      JPA has de usar el método <em>remove()</em>, aunque en este caso has de
      usar el método <em>merge()</em> también (1). Esto es porque no puedes
      borrar una entidad desasociada (<em>detached entity</em>). Al usar <em>commit()</em>
      en <em>crearProductos()</em> todas la entidades grabadas pasaron a ser
      entidades desasociadas, porque continúan siendo objetos Java válidos pero
      el contexto persistente (<em>persistent context</em>, la unión entre las
      entidades y la base de datos) se perdió en el <em>commit()</em>, por eso
      tienes que reasociarlas al nuevo contexto persistente. Este concepto es
      fácil de entender con el siguiente código:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">getManager().persist(autor); // autor está asociado al contexto persistente actual
commit(); // El contexto persistente actual se termina y autor pasa a estar desasociado
 
getManager().remove(autor); // Falla porque autor está desasociado
 
autor = getManager().merge(autor); // Reasocia autor al contexto actual
getManager().remove(autor); // Funciona
</code></pre> </div>
    <div class="wiki" style="display: block;">Aparte de este curioso detalle
      sobre el <em>merge()</em>, el código para borrar es bastante sencillo.<br>
      <h3 id="toc9"><a name="Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA-Filtrar+datos+desde+modo+lista+en+una+prueba"></a>Filtrar
        datos desde modo lista en una prueba</h3>
      Ahora que ya sabes como crear y borrar datos para las pruebas, examinemos
      los métodos de prueba para tu módulo <em>Producto</em>. El primero es <em>testBorrarDesdeLista()</em>
      que selecciona una fila en el modo lista y pulsa en el botón <i>Borrar
        seleccionados</i>. Veamos su código:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">public void testBorrarDesdeLista() throws Exception {
    login("admin", "admin");
    setConditionValues("", "JUNIT"); // Establece los valores para filtrar los datos
    setConditionComparators("=", "contains_comparator"); // Pone los comparadores para filtrar los datos
    execute("List.filter"); // Pulsa el botón para filtrar
    assertListRowCount(2); // Verifica que hay 2 filas
    checkRow(1); // Seleccionamos la fila 1 (que resulta ser la segunda)
    execute("CRUD.deleteSelected"); // Pulsa en el botón para borrar
    assertListRowCount(1); // Verifica que ahora solo hay una fila
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Aquí filtramos en modo lista todos
      los productos que contienen la palabra “JUNIT” (recuerda que has creado
      dos de estos en el método <em>crearProductos()</em>), entonces
      verificamos que hay dos filas, seleccionamos el segundo producto y lo
      borramos, verificando al final que la lista se queda con un solo producto.<br>
      Has aprendido como seleccionar una fila (usando <em>checkRow()</em>) y
      como verificar el número de filas (usando <em>assertListRowCount()</em>).
      Quizás la parte más intrincada es usar <em>setConditionValues()</em> y <em>setConditionComparators()</em>.
      Ambos métodos reciben una cantidad variable de cadenas con valores y
      comparadores para la condición, tal como se muestra aquí:<br>
      <img src="files/testing_es050.png" alt="testing_es050.png" title="testing_es050.png"><br>
      Los valores son asignados al filtro de la lista secuencialmente (de
      izquierda a derecha). En este caso hay dos valores, pero puedes usar todos
      los que necesites. No es necesario que especifiques todos los valores. El
      método <em>setConditionValues()</em> admite cualquier cadena mientras que
      <em>setConditionComparators()</em> admite los siguientes valores posibles:
      <em>contains_comparator,</em><em><em> starts_comparator, </em>
        ends_comparator, not_contains_comparator, empty_comparator,
        not_empty_comparator, =, &lt;&gt;, &gt;=, &lt;=, &gt;,</em> <em>&lt;,
        in_comparator</em>, <em>not_in_comparator</em> y <em>range_comparator</em>.<br>
      <h3 id="toc10"><a name="Leccion+3:+Pruebas+automaticas-Crear+datos+de+prueba+usando+JPA-Usar+instancias+de+entidad+dentro+de+una+prueba"></a>Usar
        instancias de entidad dentro de una prueba</h3>
      La prueba que queda, <em>testSubirFotos()</em>, escoge un producto y sube
      fotos en él. Vamos a usar en la prueba una entidad creada en <em>crearProductos()</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">public void testSubirFotos() throws Exception { 
	login("admin", "admin");
 
	// Buscar producto1
	execute("CRUD.new");
	setValue("numero", Integer.toString(producto1.getNumero())); // (1)
	execute("CRUD.refresh");
	assertFilesCount("fotos", 0);
 
	// Subir fotos
	uploadFile("fotos", "web/xava/images/add.gif"); // (2)
	uploadFile("fotos", "web/xava/images/attach.gif"); // (2)
 
	// Verificar
	execute("CRUD.new");
	assertFilesCount("fotos", 0);
	setValue("numero", Integer.toString(producto1.getNumero())); // (1)
	execute("CRUD.refresh");
	assertFilesCount("fotos", 2);
	assertFile("fotos", 0, "image");
	assertFile("fotos", 1, "image");
	
	// Quitar fotos
	removeFile("fotos", 1);
	removeFile("fotos", 0);
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Lo interesante de esta prueba es
      que para dar valor al número usado para buscar el producto, lo obtenemos
      de <em>producto1.getNumero()</em> (1). Recuerda que <em>producto1</em>
      es una variable de instancia de la prueba a la que se asigna valor en <em>crearProductos()</em>,
      el cual es llamado desde <em>setUp()</em>, es decir se ejecuta antes de
      cada prueba. También has aprendido como usar los métodos <i>uploadFile(),
        assertFileCount(), assertFile()</i> y <i>removeFile()</i> para trabajar
      con las fotos. Estos métodos funcionan con cualquier propiedad que permita
      subir archivos (GALERIA_IMAGENES, FOTO, IMAGEN, ARCHIVO, ARCHIVOS, etc).
      En este caso usamos imágenes incluidas en OpenXava, gifs de <i>web/xava/images
        </i>(2), pero puedes crear tu propia carpeta con tus propias imágenes
      para las pruebas.<br>
      <br>
      Ya tienes la prueba para <em>Producto</em> y al mismo tiempo has
      aprendido como probar usando datos de prueba creados mediante JPA.
      Ejecútalo, debería salir verde.<br>
      <h2 id="toc11"><a name="Leccion+3:+Pruebas+automaticas-Usar+datos+ya+existentes+para+probar"></a>Usar
        datos ya existentes para probar</h2>
      A veces puedes simplificar la prueba usando una base de datos que contenga
      los datos necesarios para la prueba. Si no quieres probar la creación de
      datos desde el módulo, y no borras datos en la prueba, ésta puede ser una
      buena opción.<br>
      Por ejemplo, puedes probar <em>Autor</em> y <em>Categoria</em> con una
      prueba tan simple como esta:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.pruebas;
 
import org.openxava.tests.*;
 
public class PruebaAutor extends ModuleTestBase {
 
    public PruebaAutor(String nombrePrueba) {
        super(nombrePrueba, "Facturacion", "Autor");
    }
 
    public void testReadAuthor() throws Exception {
        login("admin", "admin");
        assertValueInList(0, 0, "JAVIER CORCOBADO"); // El primer autor en la
                                                    // lista es JAVIER CORCOBADO
        execute("List.viewDetail", "row=0"); // Pulsamos en la primera fila
        assertValue("nombre", "JAVIER CORCOBADO");
        assertCollectionRowCount("productos", 2); // Tiene 2 productos
        assertValueInCollection("productos", 0, // Fila 0 de productos
                                "numero", "2"); // tiene “2” en la columna “numero”
        assertValueInCollection("productos", 0, "descripcion", "Arco iris de lágrimas");
        assertValueInCollection("productos", 1, "numero", "3");
        assertValueInCollection("productos", 1, "descripcion", "Ritmo de sangre");
    }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Esta prueba verifica que el primer
      autor en la lista es “JAVIER CORCOBADO”, recuerda crearlo antes de
      ejecutar la prueba. Entonces va al detalle y confirma que tiene una
      colección llamada "productos" con 2 productos: “Arco iris de lágrimas” y
      “Ritmo de sangre”, antes de ejecutar la prueba créalos y asocialos a
      "JAVIER CORCOBADO". De paso, has aprendido como usar los métodos <em>assertValueInList()</em>,
      <em>assertValueInCollection()</em> y <em>assertCollectionRowCount()</em>.<br>
      Podemos usar la misma técnica para probar el módulo <em>Categoria</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.pruebas;
 
import org.openxava.tests.*;
 
public class PruebaCategoria extends ModuleTestBase {
 
    public PruebaCategoria(String nombrePrueba) {
        super(nombrePrueba, "Facturacion", "Categoria");
    }
 
    public void testCategoriasEnLista() throws Exception {
        login("admin", "admin");
        assertValueInList(0, 0, "MÚSICA"); // Fila 0 columna 0 tiene “MÚSICA”
        assertValueInList(1, 0, "LIBROS"); // Fila 1 columna 0 tiene “LIBROS”
        assertValueInList(2, 0, "SOFTWARE"); // Fila 2 columna 0 tiene “SOFTWARE”
    }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">En este caso solo verificamos que
      en la lista las tres primeras categorías son “MÚSICA”, “LIBROS” y
      “SOFTWARE”. Acuerdate de crearlos antes de ejecutar esta prueba.<br>
      Puedes ver como la técnica de usar datos preexistentes de una base de
      datos de prueba te permite crear pruebas más simples. Empezar con una
      prueba simple e ir complicándolo bajo demanda es una buena idea. </div>
    <div class="wiki" style="display: block;">Recuerda añadir los datos
      correspondientes usando los módulos antes de ejecutar estas pruebas.<br>
      <h2 id="toc12"><a name="Leccion+3:+Pruebas+automaticas-Probar+colecciones"></a>Probar
        colecciones</h2>
      Es el momento de enfrentarnos a la prueba del módulo principal de tu
      aplicación, <em>PruebaFactura</em>. Por ahora la funcionalidad del módulo
      <em>Factura</em> es limitada, solo puedes añadir, borrar y modificar
      facturas. Aun así, esta es la prueba más extensa; además contiene una
      colección, por tanto aprenderás como probar las colecciones.<br>
      <h3 id="toc13"><a name="Leccion+3:+Pruebas+automaticas-Probar+colecciones-Dividir+la+prueba+en+varios+metodos"></a>Dividir
        la prueba en varios métodos</h3>
      La prueba para crear una factura está dividida en varios métodos:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">package com.tuempresa.facturacion.pruebas;
 
import java.time.*;
import java.time.format.*;<br>import javax.persistence.*;
import org.openxava.tests.*;
import static org.openxava.jpa.XPersistence.*; // Para usar JPA
 
public class PruebaFactura extends ModuleTestBase {
 
    private String numero; // Para almacenar el número de la factura que probamos
 
    public PruebaFactura(String nombrePrueba) {
        super(nombrePrueba, "Facturacion", "Factura");
    }
 
    public void testCrear() throws Exception { // El método de prueba
        login("admin", "admin");
        verificarValoresDefecto();
        escogerCliente();
        anyadirDetalles();
        ponerOtrasPropiedades();
        grabar();
        verificarCreado();
        borrar();
    }
 
    private void verificarValoresDefecto() throws Exception { … }
 
    private void escogerCliente() throws Exception { … }
 
    private void anyadirDetalles() throws Exception { … }
 
    private void ponerOtrasPropiedades() throws Exception { … }
 
    private void grabar() throws Exception { … }
 
    private void verificarCreado() throws Exception { … }
 
    private void borrar() throws Exception { … }
 
    private String getAnyoActual() { … }
 
    private String getFechaActual() { … }
 
    private String getNumero() { … }
 
}
</code></pre> </div>
    <div class="wiki" style="display: block;">El único método de prueba de esta
      clase es <em>testCrear()</em>, pero dado que es bastante extenso, es
      mejor dividirlo en varios métodos más pequeños. De hecho, es una buena
      práctica de orientación a objetos escribir métodos cortos.<br>
      Ya que el método es corto puedes ver con un solo golpe de vista que es lo
      que hace. En este caso verifica los valores por defecto para una factura
      nueva, escoge un cliente, añade las líneas de detalle, añade otras
      propiedades, graba la factura, verifica que ha sido guardada correctamente
      y al final la borra. Entremos en los detalles de cada uno de estos pasos.<br>
      <h3 id="toc14"><a name="Leccion+3:+Pruebas+automaticas-Probar+colecciones-Verificar+valores+por+defecto"></a>Verificar
        valores por defecto</h3>
      Lo primero es verificar que los valores por defecto para una factura nueva
      son calculados correctamente. Esto se hace en el método <em>verificarValoresDefecto()</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void verificarValoresDefecto() throws Exception {
    execute("CRUD.new");
    assertValue("anyo", getAnyoActual());
    assertValue("numero", getNumero());
    assertValue("fecha", getFechaActual());
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Cuando el usuario pulsa en <i>Nuevo</i>,
      los campos año, número y fecha tienen que rellenarse con datos válidos. El
      método <em>verificarValoresDefecto()</em> precisamente comprueba esto.
      Usa varios métodos de utilidad para calcular los valores esperados:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private String getAnyoActual() { // Año actual en formato cadena
    return Integer.toString(LocalDate.now().getYear()); // La forma
                                            // típica de hacerlo con Java
}
 
private String getFechaActual() { // Fecha actual como una cadena
    return LocalDate.now().format( // La forma típica de hacerlo con Java
        DateTimeFormatter.ofPattern("dd/MM/yyyy"));
}
 
private String getNumero() { // El número de factura para una factura nueva
    if (numero == null) { // Usamos inicialización vaga
        Query query = getManager(). // Una consulta JPA para obtener el último número
                createQuery("select max(f.numero) from Factura f where f.anyo = :anyo");
        query.setParameter("anyo", LocalDate.now().getYear());  
        Integer ultimoNumero = (Integer) query.getSingleResult();
        if (ultimoNumero == null) ultimoNumero = 0;
        numero = Integer.toString(ultimoNumero + 1); // Añadimos 1 al
                                                     // último número de factura
    }
    return numero;
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Los métodos <em>getAnyoActual()</em>
      y <em>getFechaActual()</em> usan técnicas clásicas de Java para formatear
      la fecha como una cadena.<br>
      El método <em>getNumero()</em> es un poco más complejo: usa JPA para
      calcular el último número de factura del año en curso y después devuelve
      este valor más uno. Dado que acceder a la base de datos es más pesado que
      un simple cálculo Java, usamos una inicialización vaga. Una inicialización
      vaga retrasa el cálculo hasta la primera vez que se necesita y después lo
      almacena para futuros usos. Esto lo hacemos guardando el valor en el campo
      <em>numero</em>.<br>
      <h3 id="toc15"><a name="Leccion+3:+Pruebas+automaticas-Probar+colecciones-Entrada+de+datos"></a>Entrada
        de datos</h3>
      Ahora es el momento de <em>escogerCliente()</em> de la factura:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void escogerCliente() throws Exception {
    setValue("cliente.numero", "1");
    assertValue("cliente.nombre", "JAVIER PANIZA"); // El cliente 1 debe de existir en la DB
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Al introducir el número de cliente
      el nombre del cliente se rellena con un valor apropiado. La prueba confía
      en que el cliente 1 con nombre "JAVIER PANIZA" existe, deberías crearlo
      antes de ejecutar la prueba. Ya hemos asociamos el cliente 1 con la
      factura actual.<br>
      Y ahora viene la parte más peliaguda de la prueba: añadir las líneas de
      detalle:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void anyadirDetalles() throws Exception {
    assertCollectionRowCount("detalles", 0); // La colección esta vacía
 
    // Añadir una línea de detalle
    setValueInCollection("detalles", 0, // 0 es la primera fila
        "producto.numero", "1");
    assertValueInCollection("detalles", 0,
        "producto.descripcion", "Peopleware: Productive Projects and Teams");
    setValueInCollection("detalles", 0, "cantidad", "2");
 
    // Añadir otro detalle
    setValueInCollection("detalles", 1, "producto.numero", "2");
    assertValueInCollection("detalles", 1, "producto.descripcion", "Arco iris de lágrimas");
    setValueInCollection("detalles", 1, "cantidad", "1");
 
    assertCollectionRowCount("detalles", 2); // Ahora tenemos 2 filas
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Probar una colección es
      exactamente igual que probar cualquier otra parte de tu aplicación, solo
      has de seguir los mismos pasos que un usuario haría con el navegador.
      Tienes métodos como <em>setValueInCollection()</em>, <em>assertValueInCollection()</em>
      o <em>assertCollectionRowCount()</em> para trabajar con colecciones. Nota
      que estos métodos tienen el nombre de la colección como primer argumento y
      algunos reciben el número de fila siendo el 0 la primera fila. Recuerda
      añadir a la base de datos los productos 1 y 2 con sus correspondientes
      descripciones antes de ejecutar esta prueba.<br>
      Ahora que tenemos los detalles añadidos, vamos a llenar los datos
      restantes y grabar la factura. Los datos restantes se establecen en el
      método <em>ponerOtrasPropiedades()</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void ponerOtrasPropiedades() throws Exception {
    setValue("observaciones", "Esto es una prueba JUNIT");
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Aquí ponemos valor al campo <em>observaciones</em>.
      Y ahora estamos listos para grabar la factura:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void grabar() throws Exception {
    execute("CRUD.save");
    assertNoErrors();
    assertValue("cliente.numero", "");
    assertCollectionRowCount("detalles", 0);
    assertValue("observaciones", "");
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Simplemente pulsa en <i>Grabar</i>,
      entonces verifica que no ha habido errores y la vista se ha limpiado.<br>
      <h3 id="toc16"><a name="Leccion+3:+Pruebas+automaticas-Probar+colecciones-Verificar+los+datos"></a>Verificar
        los datos</h3>
      Ahora, buscamos la factura recién creada para verificar que ha sido
      grabada correctamente. Esto se hace en el método <em>verificarCreado()</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void verificarCreado() throws Exception {
    setValue("anyo", getAnyoActual()); // El año actual en el campo año
    setValue("numero", getNumero()); // El número de la factura usada en la prueba
    execute("CRUD.refresh"); // Carga la factura desde la base de datos
 
    // En el resto de la prueba confirmamos que los valores son los correctos
    assertValue("anyo", getAnyoActual());
    assertValue("numero", getNumero());
    assertValue("fecha", getFechaActual());
    assertValue("cliente.numero", "1");
    assertValue("cliente.nombre", "JAVIER PANIZA");
    assertCollectionRowCount("detalles", 2);
 
    // Fila 0
    assertValueInCollection("detalles", 0, "producto.numero", "1");
    assertValueInCollection("detalles", 0, "producto.descripcion",
        "Peopleware: Productive Projects and Teams");
    assertValueInCollection("detalles", 0, "cantidad", "2");
 
    // Fila 1
    assertValueInCollection("detalles", 1, "producto.numero", "2");
    assertValueInCollection("detalles", 1, "producto.descripcion",
        "Arco iris de lágrimas");
    assertValueInCollection("detalles", 1, "cantidad", "1");
    assertValue("observaciones", "Esto es una prueba JUNIT");
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Después de buscar la factura
      creada verificamos que los valores que hemos grabado están ahí. Si la
      prueba llega a este punto tu módulo <em>Factura</em> funciona bien. Solo
      nos queda borrar la factura creada para que la prueba se pueda ejecutar la
      siguiente vez. Hacemos esto en el método <em>borrar()</em>:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">private void borrar() throws Exception {
    execute("CRUD.delete");
    assertNoErrors();
}
</code></pre> </div>
    <div class="wiki" style="display: block;">Simplemente presiona en <i>Borrar</i>
      y verifica que no se han producido errores.<br>
      <br>
      ¡Enhorabuena! Has completado tu <em>PruebaFactura</em>. Ya puedes
      ejecutarla, debería salir verde, si no comprueba que los datos en la base
      de datos están bien, puede que tengas que añadir los productos, cliente,
      etc. correspondientes.<br>
      <h2 id="toc17"><a name="Leccion+3:+Pruebas+automaticas-Suite"></a>Suite</h2>
      Tienes 5 casos de prueba que velan por tu código, preservando la calidad
      de tu aplicación. Cuando termines alguna mejora o corrección en tu
      aplicación ejecuta todas tus pruebas unitarias para verificar que la
      funcionalidad existente no se ha roto.<br>
      Tradicionalmente, para ejecutar todos las pruebas de tu aplicación
      deberías crear una suite de pruebas y ejecutarla. Una suite de pruebas es
      una clase que agrega todas tus pruebas JUnit para que puedas ejecutarlas
      todas de un golpe. Afortunadamente, con OpenXava Studio no necesitas
      escribir una clase de suite, te permite ejecutar todas las pruebas de tu
      aplicación automáticamente:<br>
      <img src="files/testing_es060.png" alt="testing_es060.png" title="testing_es060.png"><br>
      Es decir, si ejecutas <em>Run As &gt; JUnit Test</em> en el proyecto, se
      ejecutarán todas sus pruebas JUnit.</div>
    <div class="wiki" style="display: block;">
      <h2><a name="codigo-fuente-hasta-la-leccion-5"></a>Código fuente hasta la
        lección 5</h2>
      <p>El código de prueba hasta aquí es para aplicar sobre el código de la
        lección 5. Aquí puedes descarga el código fuente de la lección 5 pero
        incluyendo el código de prueba de arriba:</p>
      <p><strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-testing_es.zip/download"
            rel="nofollow">Descarga el código fuente hasta la lección 5 con
            pruebas</a></strong></p>
      <p>Todo el código a descargar a partir de la lección 5 ya include el
        código de prueba, que puedes ver con explicaciones a partir de aquí.</p>
      <h2 id="Herencia-en-las-pruebas-JUnit">Herencia en las pruebas JUnit</h2>
      <b><span style="color: green;">El código fuente a partir de aquí es para
          ponerlo encima del código de la sección <i>Herencia</i>, hasta nuevo
          aviso.</span></b></div>
    <div class="wiki" style="display: block;"><em>Factura</em> ha sido
      refactorizada para usar herencia y también hemos usado herencia para
      añadir una nueva entidad, <em>Pedido</em>. Además, esta entidad <em>Pedido</em>
      tiene relación con <em>Factura</em>. Lo cual es una nueva funcionalidad,
      por ende has de probar todas estas nuevas características.<br>
      Dado que <em>Factura</em> y <em>Pedido</em> tienen bastantes cosas en
      común (la parte de <em>DocumentoComercial</em>) podemos refactorizar las
      pruebas para usar herencia, y así eludir el dañino “copiar y pegar”
      también en tu código de prueba.<br>
      <h3 id="toc15"><a name="Herencia-en-las-pruebas-JUnit-Crear-una-prueba-de-modulo-abstracta"></a>Crear
        una prueba de módulo abstracta</h3>
      Si examinas la prueba para crear una factura, en el método <em>testCrear()</em>
      de <em>PruebaFactura</em>. Puedes notar que probar la creación de una
      factura es exactamente igual que probar la creación de un pedido. Porque
      ambos tienen año, número, fecha, cliente, detalles y observaciones. Por
      tanto, aquí la herencia es una buena herramienta para la reutilización de
      código.<br>
      Vamos a renombrar <em>PruebaFactura</em> como <em>PruebaDocumentoComercial</em>,
      y entonces crearemos <em>PruebaFactura</em> y <em>PruebaPedido</em> a
      partir de él. Éste es el diagrama UML de esta idea:<br>
      <img src="files/inheritance_es100.png" alt="inheritance_es100.png" title="inheritance_es100.png"><br>
      Primero renombra tu actual clase <em>PruebaFactura</em> a <em>PruebaDocumentoComercial</em>,
      y después haz los cambios indicados en el siguiente código:<br>
      <pre><code class="java">package com.tuempresa.facturacion.pruebas;
 
import java.time.*;
import java.time.format.*;
import javax.persistence.*;
import org.openxava.tests.*;
import static org.openxava.jpa.XPersistence.*; 
 
abstract public class PruebaDocumentoComercial // Añade abstract a la definición de clase
    extends ModuleTestBase {
 
    private String numero;
 
    public PruebaDocumentoComercial(
        String nombrePrueba,
        String nombreModulo) // nombreModulo añadido como argumento en el constructor
    {
        super(nombrePrueba, "Facturacion", nombreModulo); // nombreModulo en vez de "Factura"
    }
 
    public void testCrear() throws Exception { … } // Como el original
 
    private void anyadirDetalles() throws Exception { … } // Como el original
 
    private String getNumero() {
        if (numero == null) {
            Query query = getManager().
                createQuery(
                    "select max(f.numero) "
                    + "from DocumentoComercial f " // Factura cambiada por DocumentoComercial
                    + "where f.anyo = :anyo");
            query.setParameter("anyo", LocalDate.now().getYear());
            Integer ultimoNumero = (Integer) query.getSingleResult();
            if (ultimoNumero == null) ultimoNumero = 0;
            numero = Integer.toString(ultimoNumero + 1);
        }
        return numero;
    }
 
    private void borrar() throws Exception { … } // Como original
 
    private void verificarCreado() throws Exception { … } // Como original
 
    private void grabar() throws Exception { … } // Como original
 
    private void ponerOtrasPropiedades() throws Exception { … } // Como original
 
    private void escogerCliente() throws Exception { … } // Como original
 
    private void verificarValoresDefecto() throws Exception { … } // Como original
 
    private String getAnyoActual() { … } // Como original
 
    private String getFechaActual() { … } // Como original
 
}
</code></pre> Como ves has tenido que hacer unos pocos cambios para adaptar <em>PruebaDocumentoComercial</em>.
      Primero, la has declarado abstracta, de esta forma esta clase no es
      ejecutada por OpenXava Studio como una prueba JUnit, es solo válida como
      clase base para crear pruebas, pero ella misma no es una prueba.<br>
      Otro cambio importante nos lo encontramos en el constructor, donde ahora
      tienes <em>nombreModulo</em> en vez de “Factura”, así puedes usar esta
      prueba para <em>Pedido</em>, <em>Factura</em> o cualquier otro módulo
      que quieras. El otro cambio es un simple detalle: has de cambiar “Factura”
      por “DocumentoComercial” en la consulta para obtener el siguiente número.<br>
      Ahora ya tienes una clase base lista para crear los módulos de prueba para
      <em>Pedido</em> y <em>Factura</em>. Hagámoslo sin más dilación.<br>
      <h3 id="toc16"><a name="Herencia-en-las-pruebas-JUnit-Prueba-base-abstracta-para-crear-pruebas-de-modulo-concretas"></a>Prueba
        base abstracta para crear pruebas de módulo concretas</h3>
      Crear tu primera versión para <em>PruebaFactura</em> y <em>PruebaPedido</em>
      es simplemente extender de <em>PruebaDocumentoComercial</em>. Nada más.
      Mira el código de <em>PruebaFactura</em>:<br>
      <pre><code class="java">package com.tuempresa.facturacion.pruebas;
 
public class PruebaFactura extends PruebaDocumentoComercial {
 
    public PruebaFactura(String nombrePrueba) {
        super(nombrePrueba, "Factura");
    }
 
}
</code></pre> Y <em>PruebaPedido</em>:<br>
      <pre><code class="java">package com.tuempresa.facturacion.pruebas;
 
public class PruebaPedido extends PruebaDocumentoComercial {
 
    public PruebaPedido(String nombrePrueba) {
        super(nombrePrueba, "Pedido");
    }
 
}
</code></pre> Ejecuta estas dos prueba y verás como <em>testCrear()</em>,
      heredado de <em>PruebaDocumentoComercial</em>, se ejecuta en ambos casos,
      contra su módulo correspondiente. Con esto estamos probando el
      comportamiento común para <em>Pedido</em> y <em>Factura</em>. Probemos
      ahora la funcionalidad particular de cada uno.<br>
      <h3 id="toc17"><a name="Herencia-en-las-pruebas-JUnit-Anadir-nuevas-pruebas-a-las-pruebas-de-modulo-extendidas"></a>Añadir
        nuevas pruebas a las pruebas de módulo extendidas</h3>
      Hasta ahora hemos probado como crear una factura y un pedido. En esta
      sección probaremos como añadir pedidos a una factura en el módulo <em>Factura</em>
      y como establecer la factura a un pedido en el módulo <em>Pedido</em>.<br>
      Para probar como añadir un pedido a una factura añade el método <em>testAnyadirPedidos()</em>
      a <em>PruebaFactura</em>:<br>
      <pre><code class="java">// Esta prueba confía en que al menos exista una factura y un pedido
public void testAnyadirPedidos() throws Exception {
    login("admin", "admin");
    assertListNotEmpty(); // Esta prueba confía en que ya existen facturas
    execute("List.orderBy", "property=numero"); // Para usar siempre el mismo pedido
    execute("List.viewDetail", "row=0"); // Va al modo detalle editando la primera factura
    execute("Sections.change", "activeSection=1"); // Cambia a la pestaña 1
    assertCollectionRowCount("pedidos", 0); // Esta factura no tiene pedidos
    execute("Collection.add", // Pulsa el botón para añadir un nuevo pedido, esto te lleva
        "viewObject=xava_view_section1_pedidos"); // a la lista de pedidos
    execute("AddToCollection.add", "row=0"); // Escoge el primer pedido de la lista
    assertCollectionRowCount("pedidos", 1); // El pedido se ha añadido a la factura
    checkRowCollection("pedidos", 0); // Marca el pedido, para borrarlo
    execute("Collection.removeSelected", // Borra el pedido recién añadido
        "viewObject=xava_view_section1_pedidos");
    assertCollectionRowCount("pedidos", 0); // El pedido ha sido borrado
}
</code></pre> En este caso asumimos que hay al menos una factura y que la
      primera factura de la lista no tiene pedidos. Antes de ejecutar esta
      prueba, si no tienes facturas todavía, crea una sin pedidos, o si ya
      tienes facturas, asegúrate de que la primera no tiene pedidos.<br>
      Para probar como asignar una factura a un pedido añade el método <em>testPonerFactura()</em>
      a <em>PruebaPedido</em>:<br>
      <pre><code class="java">public void testPonerFactura() throws Exception {
    login("admin", "admin");
    assertListNotEmpty(); // Esta prueba confía en que existen pedidos
    execute("List.viewDetail", "row=0"); // Va a modo detalle editando la primera factura
    execute("Sections.change", "activeSection=1"); // Cambia a la pestaña 1
    assertValue("factura.numero", ""); // Este pedido todavía no tiene
    assertValue("factura.anyo", ""); // una factura asignada
    execute("Reference.search", // Pulsa en el botón para buscar la factura, esto te
        "keyProperty=factura.anyo"); // lleva a la lista de facturas
    String anyo = getValueInList(0, "anyo"); // Memoriza el año y el número de
    String numero = getValueInList(0, "numero"); // la primera factura de la lista
    execute("ReferenceSearch.choose", "row=0"); // Escoge la primera factura
    assertValue("factura.anyo", anyo); // Al volver al detalle del pedido verificamos
    assertValue("factura.numero", numero); // que la factura ha sido seleccionada
}
</code></pre> En este caso asumimos que hay al menos un pedido y el primer
      pedido de la lista no tiene factura. Antes de ejecutar esta prueba, si no
      tienes pedidos, crea uno sin factura, o si ya tienes pedidos, asegúrate de
      que el primero no tiene factura.<br>
      Con esto ya tienes tus pruebas listas. Ejecútalas y obtendrás el siguiente
      resultado:<br>
      <img src="files/inheritance_es110.png" alt="inheritance_es110.png" title="inheritance_es110.png"><br>
      Fíjate que la prueba base <em>PruebaDocumentoComercial</em> no se muestra
      porque es abstracta. Y <em>testCrear()</em> de <em>PruebaDocumentoComercial</em>
      se ejecuta para <em>PruebaFactura</em> y <em>PruebaPedido</em>.<br>
      No solo has adaptado tu código de pruebas al nuevo código de <em>Facturacion</em>,
      sino que también has aprendido como usar herencia en el mismo código de
      pruebas.</div>
    <div class="wiki" style="display: block;">
      <h2 id="probar-logica-de-negocio-basica">Probar lógica de negocio básica</h2>
      <b><span style="color: green;">El código fuente a partir de aquí es para
          ponerlo encima del código de la sección <i>Lógica de negocio básica</i>,
          hasta nuevo aviso.</span></b></div>
    <div class="wiki" style="display: block;">Vamos a escribir el código JUnit
      para la sección <i>Lógica de negocio básica</i>. Recuerda, el código no
      está terminado si no tiene pruebas JUnit. Puedes escribir las pruebas
      antes, durante o después del código principal. Pero siempre has de
      escribirlas.<br>
      El código de prueba mostrado aquí no es solo para darte un buen ejemplo,
      sino también para enseñarte maneras de probar diferentes casos en tu
      aplicación OpenXava.<br>
      <h3 id="toc11"><a name="Pruebas-JUnit-Modificar-la-prueba-existente"></a>Modificar
        la prueba existente</h3>
      Crear una nueva prueba para cada nuevo caso parece una buena idea desde un
      punto de vista estructural, pero en la mayoría de los casos no es
      práctico, porque de esa forma tu código de prueba crecerá muy rápido, y
      con el tiempo, ejecutar todas las pruebas supondrá muchísimo tiempo.<br>
      El enfoque más pragmático es modificar el código de prueba existente para
      cubrir todos los nuevos casos que hemos desarrollado. Hagámoslo de esta
      forma.<br>
      En nuestro caso, la mayoría del código de esta lección aplica a <em>DocumentoComercial</em>,
      por tanto vamos a modificar el método <em>testCrear()</em> de <em>PruebaDocumentoComercial</em>
      para ajustarlo a la nueva funcionalidad. Dejamos el método <em>testCrear()</em>
      tal como muestra el siguiente código:<br>
      <pre><code class="java">public void testCrear() throws Exception {
    login("admin", "admin");
    calcularNumero(); // Añadido para calcular primero el siguiente número de documento
    verificarValoresDefecto();
    escogerCliente();
    anyadirDetalles();
    ponerOtrasPropiedades();
    grabar();
    verificarBeneficioEstimado(); // Prueba @Formula
    verificarCreado();
    borrar();
}
</code></pre> Como ves, añadimos una nueva línea, después de <em>login(...)</em>,
      para calcular el siguiente número de documento, y una llamada al nuevo
      método <em>verificarBeneficioEstimado()</em>.<br>
      Ahora nos conviene más calcular el siguiente número de documento al
      principio para usarlo en el resto de la prueba. Para hacer esto, cambia el
      viejo método <em>getNumero()</em> por los dos métodos mostrados en el
      siguiente código:<br>
      <pre><code class="java">private void calcularNumero() {
    Query query = getManager().createQuery(
        "select max(f.numero) from " +
        modelo + // Cambiamos DocumentoComercial por una variable
        " f where f.anyo = :anyo");
    query.setParameter("anyo", LocalDate.now().getYear());
    Integer ultimoNumero = (Integer) query.getSingleResult();
    if (ultimoNumero == null) ultimoNumero = 0;
    numero = Integer.toString(ultimoNumero + 1);
}
 
private String getNumero() {
    return numero;
}
</code></pre> Anteriormente, teníamos solo <em>getNumero()</em> que calculaba y
      devolvía el número, ahora tenemos un método para calcular (<em>calcularNumero()</em>),
      y otro para devolver el resultado (<em>getNumero()</em>). Puedes notar que
      la lógica del cálculo tiene un pequeño cambio, en vez de usar
      “DocumentoComercial” como fuente de la consulta usamos <i>modelo</i>, una
      variable. Esto es así porque ahora la numeración para facturas y pedidos
      está separada. Llenamos esta variable, un campo de la clase de prueba, en
      el constructor, tal como muestra el siguiente código:<br>
      <pre><code class="java">private String modelo; // Nombre del modelo para la condición. Puede ser 'Factura' o 'Pedido'
 
public PruebaDocumentoComercial(String nombrePrueba, String nombreModulo) {
    super(nombrePrueba, "Facturacion", nombreModulo);
    this.modelo = nombreModulo; // El nombre del módulo coincide con el del modelo
}
</code></pre> En este caso el nombre de módulo, <i>Factura</i> o <i>Pedido</i>,
      coincide con el nombre de modelo, <em>Factura</em> o <em>Pedido</em>,
      así que la forma más fácil de obtener el nombre de modelo es desde el
      nombre de módulo.<br>
      Veamos el código que prueba la nueva funcionalidad.<br>
      <h3 id="toc12"><a name="Pruebas-JUnit-Verificar-valores-por-defecto-propiedades-calculadas-y-Calculation"></a>Verificar
        valores por defecto, propiedades calculadas y <i>@Calculation</i></h3>
      En esta lección hemos hecho algunas modificaciones en los valores por
      defecto. Ahora, el valor por defecto para <em>numero</em> ya no se
      calcula mediante un <em>@DefaultValueCalculator</em> en su lugar usamos
      un método de retrollamada JPA. Para probar este caso hemos de modificar el
      método <em>verificarValoresDefecto()</em> como ves en el siguiente
      código:<br>
      <pre><code class="java">private void verificarValoresDefecto() throws Exception {
    execute("CRUD.new");
    assertValue("anyo", getAnyoActual());
    // assertValue("numero", getNumero()); // Ahora el número no tiene valor inicial...
    assertValue("numero", ""); // ... al crear un documento nuevo
    assertValue("fecha", getFechaActual());
}
</code></pre>Verificamos que <em>numero</em> no tiene valor inicial, porque
      ahora <em>numero</em> no se calcula hasta el momento de grabar el
      documento (sección <a class="wiki_link" href="basic-business-logic_es.html#Metodos-de-retrollamadas-JPA-Calculo-de-valor-por-defecto-multiusuario">Cálculo
        de valor por defecto multiusuario</a>). Cuando el documento (factura o
      pedido) se grabe verificaremos que <em>numero</em> se calcula.
      <div class="wiki" style="display: block;">Cuando la línea se añade podemos
        verificar el cálculo de <em>importe</em> de <em>Detalle</em> (la
        propiedad calculada simple, sección <a class="wiki_link" href="basic-business-logic_es.html#Propiedades-calculadas-Propiedad-calculada-simple">Propiedad
          calculada simple</a>), el valor por defecto para <em>precioPorUnidad</em>
        (<em>@DefaultValueCalculator</em>, sección <a class="wiki_link" href="basic-business-logic_es.html#Propiedades-calculadas-Usar-DefaultValueCalculator">Usar
          @DefaultValueCalculator</a>) y las propiedades de importes del
        documento (sección <a class="wiki_link" href="basic-business-logic_es.html#Propiedades-calculadas-Propiedades-de-total-de-una-coleccion">Propiedades
          de total de una colección</a>). Entre las propiedades de total
        probamos <i>porcentajeIVA</i> cuyo valor por defecto se calcula leyendo
        de un archivo de propiedades. Todo esto lo probamos haciendo unas
        ligeras modificaciones en el ya existente método <em>anyadirDetalles()</em>:<br>
        <pre><code class="java">private void anyadirDetalles() throws Exception {
    assertCollectionRowCount("detalles", 0);
	<br>    // Antes de ejecutar esta prueba asegurate de que
    //   producto 1 tenga 19 como precio y 
    //   producto 2 tenga 20 como precio
 
    // Añadir una línea de detalle
    setValueInCollection("detalles", 0, "producto.numero", "1");
    assertValueInCollection("detalles", 0,
        "producto.descripcion", "Peopleware: Productive Projects and Teams");
    assertValueInCollection("detalles", 0,
        "precioPorUnidad", "19,00"); // @DefaultValueCalculator
    setValueInCollection("detalles", 0, "cantidad", "2");
    assertValueInCollection("detalles", 0,
        "importe", "38,00"); // Propiedada calculada, sección 'Propiedad calculada simple'
 
    // Verificando propiedades de total de la colección
    assertTotalInCollection("detalles", 0, "importe", "38,00"); // Suma de importes usando +
    assertTotalInCollection("detalles", 1, "importe", "21"); // Valor por defecto desde un archivo de propiedades
    assertTotalInCollection("detalles", 2, "importe", "7,98"); // IVA, con @Calculation
    assertTotalInCollection("detalles", 3, "importe", "45,98"); // Importe total, con @Calculation
 
    // Añadir otro detalle
    setValueInCollection("detalles", 1, "producto.numero", "2");
    assertValueInCollection("detalles", 1, "producto.descripcion", "Arco iris de lágrimas");
    assertValueInCollection("detalles", 1, "precioPorUnidad", "20,00"); 
    setValueInCollection("detalles", 1, "precioPorUnidad", "10,00"); // Modificando el valor por defecto
    setValueInCollection("detalles", 1, "cantidad", "1");
    assertValueInCollection("detalles", 1, "importe", "10,00");
 
    assertCollectionRowCount("detalles", 2); // Ahora tenemos dos líneas
 
    // Verificando propiedades de total de la colección
    assertTotalInCollection("detalles", 0, "importe", "48,00");
    assertTotalInCollection("detalles", 1, "importe", "21");
    assertTotalInCollection("detalles", 2, "importe", "10,08");
    assertTotalInCollection("detalles", 3, "importe", "58,08");
}
</code></pre>Como ves, con estas modificaciones sencillas probamos la mayoría de
        nuestro nuevo código. Nos quedan sólo las propiedades <em></em><em>beneficioEstimado</em>
        y <i>diasEntrega</i>. Las cuales probaremos en las siguientes
        secciones.<br>
        <h3 id="toc13"><a name="Pruebas-JUnit-Verificar-Formula"></a>Verificar <em>@Formula</em></h3>
        En la sección <a class="wiki_link" href="basic-business-logic_es.html#Logica-desde-la-base-de-datos-Formula">Lógica
          desde la base de datos</a> hemos creado una propiedad que usa <em>@Formula</em>,
        <em>beneficioEstimado</em>. Esta propiedad se muestra sólo en modo
        lista.<br>
        Obviamente, la forma más simple de probarlo es yendo a modo lista y
        verificando que el valor para esta propiedad es el esperado. En <em>testCrear()</em>
        llamamos a <em>verificarBeneficioEstimado()</em>. Veamos su código:<br>
        <pre><code class="java">private void verificarBeneficioEstimado() throws Exception {
    execute("Mode.list"); // Cambiar a modo lista
    setConditionValues(new String [] { // Filtra para ver en la lista solamente
        getAnyoActual(), getNumero() // el documento que acabamos de crear
    });
    execute("List.filter"); // Hace filtro
    assertValueInList(0, 0, getAnyoActual()); // Verifica que
    assertValueInList(0, 1, getNumero()); // el filtro ha funcionado
    assertValueInList(0, "beneficioEstimado", "5,81"); // Confirma el beneficio estimado
    execute("List.viewDetail", "row=0"); // Va a modo detalle
}
</code></pre> Dado que ahora vamos a modo lista y después volvemos a detalles,
        hemos de hacer una pequeña modificación en el método <em>verificarCreado()</em>,
        que es ejecutado justo después de <em>verificarBeneficioEstimado()</em>.
        Veamos la modificación:<br>
        <pre><code class="java">private void verificarCreado() throws Exception {
    // setValue("anyo", getAnyoActual()); // Borramos estas líneas
    // setValue("numero", getNumero());  // para buscar el documento
    // execute("CRUD.refresh"); // porque ya lo hemos buscado desde el modo lista
    // El resto de la prueba ...
    ...
</code></pre> Quitamos estas líneas porque ahora no es necesario buscar el
        documento recién creado. Ahora en el método <em>verificarBeneficioEstimado()</em>
        vamos a modo lista y escogemos el documento, por tanto ya estamos
        editando el documento.</div>
      <div class="wiki" style="display: block;">
        <h3><a name="Pruebas-JUnit-Probar-sincronizacion-de-propiedades-calculadas-y-persistentes"></a>Probar
          sincronización de propiedades calculadas y persistentes</h3>
        En la sección <a class="wiki_link" href="basic-business-logic_es.html#Metodos-de-retrollamadas-JPA-Sincronizar-propiedades-persistentes-y-calculadas">Sincronizar
          propiedades persistentes y calculadas</a> usamos métodos de
        retrollamada JPA en <em>Pedido</em> para tener una propiedad
        persistente, <em>diasEntrega</em><em></em>, sincronizada con una
        calculada, <em>diasEntregaEstimados</em>. La propiedad <em>diasEntrega</em>
        sólo se muestra en modo lista.<br>
        Ve a la clase <i>PruebaPedido</i> y añade un nuevo método <i>testDiasEntrega()</i>:<br>
        <pre><code class="java">public void testDiasEntrega() throws Exception {
    login("admin", "admin");
    assertListNotEmpty(); 
    execute("List.viewDetail", "row=0"); 
	
    setValue("fecha", "5/6/2020");
    assertValue("diasEntregaEstimados", "1");
    setValue("fecha", "6/6/2020");
    assertValue("diasEntregaEstimados", "3");
    setValue("fecha", "7/6/2020");
    assertValue("diasEntregaEstimados", "2");
    execute("CRUD.save");
    execute("Mode.list"); // Para verificar que diasEntrega está sincronizado
    assertValueInList(0, "diasEntrega", "2"); 

    execute("List.viewDetail", "row=0");
    setValue("fecha", "13/1/2020");
    assertValue("diasEntregaEstimados", "7");
    execute("CRUD.save");
    execute("Mode.list"); // Para verificar que diasEntrega está sincronizado
    assertValueInList(0, "diasEntrega", "7");        
}
</code></pre>Probamos varios valores para <i>fecha</i> para verificar que <i>diasEntregaEstimados</i>
        se calcula correctamente cada vez, además vamos a modo lista para
        verificar que <i>diasEntrega</i> tiene el valor correcto y por tanto
        ambas propiedades están sincronizadas.
        <div class="wiki" style="display: block;"><br>
        </div>
      </div>
      <div class="wiki" style="display: block;"> ¡Enhorabuena! Ahora tus pruebas
        ya están sincronizadas con tu código. Es un buen momento para ejecutar
        todas las pruebas de tu aplicación.<br>
        <h2 id="probar-validacion"><a name="Pruebas-JUnit"></a>Probar validación</h2>
        <b><span style="color: green;">El código fuente a partir de aquí es para
            ponerlo encima del código de la sección <i>Validación avanzada</i>,
            hasta nuevo aviso.</span></b></div>
      <div class="wiki" style="display: block;"> Nuestra meta no es desarrollar
        una ingente cantidad de código, sino crear software de calidad. Al
        final, si creas software de calidad acabarás escribiendo más cantidad de
        software, porque podrás dedicar más tiempo a hacer cosas nuevas y
        excitantes, y menos depurando legiones de bugs. Y tú sabes que la única
        forma de conseguir calidad es mediante las pruebas automáticas, por
        tanto actualicemos nuestro código de prueba.<br>
        <h3 id="toc17"><a name="Pruebas-JUnit-Probar-la-validacion-al-anadir-a-una-coleccion"></a>Probar
          la validación al añadir a una colección</h3>
        Recuerda que hemos refinado tu código para que el usuario no pueda
        asignar pedidos a una factura si los pedidos no están servidos. Después
        de esto, tu actual <em>testAnyadirPedidos()</em> de <em>PruebaFactura</em>
        puede fallar, porque trata de añadir el primer pedido y es posible que
        ese primer pedido no esté marcado como servido.<br>
        Modifiquemos la prueba para que funcione y también para comprobar la
        nueva funcionalidad de validación. Mira como:<br>
        <pre><code class="java">public void testAnyadirPedidos() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=numero");
    execute("List.viewDetail", "row=0");
    execute("Sections.change", "activeSection=1");
    assertCollectionRowCount("pedidos", 0);
    execute("Collection.add",
        "viewObject=xava_view_section1_pedidos");
    // execute("AddToCollection.add", "row=0"); // Ahora no seleccionamos al azar
 
    seleccionarPrimerPedidoConEntregadoIgual("Entregado"); // Selecciona un pedido entregado
    seleccionarPrimerPedidoConEntregadoIgual(""); // Selecciona uno no entregado
    execute("AddToCollection.add"); // Tratamos de añadir ambos
    assertError( // Un error, porque el pedido no entregado no se puede añadir
        "¡ERROR! 1 elemento(s) NO añadido(s) a Pedidos de Factura");
    assertMessage( // Un mensaje de confirmación, porque el pedido entregado ha sido añadido
        "1 elemento(s) añadido(s) a Pedidos de Factura");
 
    assertCollectionRowCount("pedidos", 1);
    checkRowCollection("pedidos", 0);
    execute("Collection.removeSelected",
        "viewObject=xava_view_section1_pedidos");
    assertCollectionRowCount("pedidos", 0);
}
</code></pre> Hemos modificado la parte de la selección de pedidos a añadir,
        antes seleccionábamos el primero, no importaba si estaba servido o no.
        Ahora seleccionamos un pedido servido y otro no servido, de esta forma
        comprobamos que el pedido servido se añade y el no servido es rechazado.<br>
        La pieza que nos falta es la forma de seleccionar los pedidos. Esto es
        el trabajo del método <em>seleccionarPrimerPedidoConEntregadoIgual()</em>.
        Veámoslo:<br>
        <pre><code class="java">private void seleccionarPrimerPedidoConEntregadoIgual(String valor) throws Exception {
    int c = getListRowCount(); // El total de filas visualizadas en la lista
    for (int i = 0; i &lt; c; i++) {
        if (valor.equals(getValueInList(i, 12))) { // Obtenermos valor de la columna 'entregado'    
            checkRow(i);
            return;
        }
    }
    fail("Debe tener al menos una fila con entregado=" + valor);
}
</code></pre> Aquí ves una buena técnica para hacer un bucle sobre los elementos
        visualizados de una lista para seleccionarlos y coger algunos datos, o
        cualquier otra cosa que quieras hacer con los datos de la lista. Para
        que esta prueba funcione la primera factura no ha de tener pedidos y
        además tiene que haber al menos un pedido entregado, pero que no sea el
        primero.<br>
        <h3 id="toc18"><a name="Pruebas-JUnit-Probar-validacion-al-asignar-una-referencia-y-al-borrar"></a>Probar
          validación al asignar una referencia y al borrar</h3>
        Desde el módulo <em>Factura</em> el usuario no puede asignar pedidos a
        una factura si los pedidos no están servidos, por lo tanto, desde el
        módulo <em>Pedido</em> el usuario tampoco debe poder asignar una
        factura a un pedido si éste no está servido. Es decir, hemos de probar
        también la otra parte de la asociación. Lo haremos modificando el actual
        <em>testPonerFactura()</em> de <em>PruebaPedido</em>.<br>
        Además, aprovecharemos este caso para probar la validación al borrar que
        vimos en las secciones <a class="wiki_link" href="validation_es.html#toc7">Validar
          al borrar con @RemoveValidator</a> y <a class="wiki_link" href="validation_es.html#toc8">Validar
          al borrar con un método de retrollamada</a>. Allí modificamos la
        aplicación para impedir que un usuario borrara un pedido si éste tenía
        una factura asociada. Ahora probaremos este hecho.<br>
        Todo esto está en el <em>testPonerFactura()</em> de <i>PruebaPedido</i>
        mejorado que puedes ver a continuación:<br>
        <pre><code class="java">public void testPonerFactura() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=numero"); // Establece el orden de la lista
    execute("List.viewDetail", "row=0");
    assertValue("entregado", "false"); // El pedido no debe estar entregado
    execute("Sections.change", "activeSection=1");
    assertValue("factura.numero", "");
    assertValue("factura.anyo", "");
    execute("Reference.search",
        "keyProperty=factura.anyo");
    String anyo = getValueInList(0, "anyo");
    String numero = getValueInList(0, "numero");
    execute("ReferenceSearch.choose", "row=0");
    assertValue("factura.anyo", anyo);
    assertValue("factura.numero", numero);
 
    // Los pedidos no entregados no pueden tener factura
    execute("CRUD.save");
    assertErrorsCount(1); // No podemos grabar porque no ha sido entregado
    setValue("entregado", "true");
    execute("CRUD.save"); // Con 'entregado=true' podemos grabar el pedido
    assertNoErrors();
 
    // Un pedido con factura no se puede borrar
    execute("Mode.list"); // Vamos al modo lista
    execute("CRUD.deleteRow", "row=0"); // y eliminanos el pedido grabado
    assertError("Imposible borrar Pedido por: " + // No podemos borrar porque tiene
        "Pedido asociado a factura no puede ser eliminado"); // una factura asociada
 
    // Restaurar los valores originales
    execute("List.viewDetail", "row=0");
    setValue("factura.anyo", "");
    setValue("entregado", "false");
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> La prueba original solo buscaba una factura, ni siquiera intentaba
        grabar. Ahora, hemos añadido código al final para probar la grabación de
        un pedido marcado como servido y marcado como no servido, de esta forma
        comprobamos la validación. Después de eso, tratamos de borrar el pedido,
        el cual tiene una factura, así probamos también la validación al borrar.
        Antes de ejecutar esta prueba asegurate de que el primer pedido no esté
        entregado y no tenga factura.<br>
        <h3 id="toc19"><a name="Pruebas-JUnit-Probar-el-Bean-Validation-propio"></a>Probar
          el <em>Bean Validation</em> propio</h3>
        Solo nos queda probar tu <em>Bean Validation ISBN</em>, el cual usa un
        servicio REST para hacer la validación. Simplemente hemos de escribir
        una prueba que trate de asignar un ISBN incorrecto, uno inexistente y
        uno correcto a un producto, y ver que pasa. Para hacer esto añadamos un
        método <em>testValidarISBN()</em> a <em>PruebaProducto</em>.<br>
        <pre><code class="java">public void testValidarISBN() throws Exception {
    login("admin", "admin");
 
    // Buscar producto1
    execute("CRUD.new");
    setValue("numero", Integer.toString(producto1.getNumero()));
    execute("CRUD.refresh");
    assertValue("descripcion", "Producto JUNIT 1");
    assertValue("isbn", "");
 
    // Con un formato de ISBN incorrecto
    setValue("isbn", "1111");
    execute("CRUD.save"); // Falla por el formato (apache commons validator)
    assertError("1111 no es un valor válido para ISBN de Producto: " +
        "ISBN inválido o inexistente");
 
    // ISBN no existe aunque tiene un formato correcto
    setValue("isbn", "9791034369997");
    execute("CRUD.save"); // Falla porque no existe ISBN (el servicio REST)
    assertError("9791034369997 no es un valor válido para ISBN de " +
        "Producto: ISBN inválido o inexistente");
 
    // ISBN existe
    setValue("isbn", "9780932633439");
    execute("CRUD.save"); // No falla
    assertNoErrors();
}
</code></pre> Seguramente la prueba manual que hacías mientras estabas
        escribiendo el validador <em>@ISBN</em> era parecida a esta. Por eso,
        si hubieras escrito tu <a href="http://www.extremeprogramming.org/rules/testfirst.html"
          rel="nofollow">código de prueba antes que el código de la aplicación</a>,
        lo hubieras podido usar mientras que desarrollabas, lo cual es más
        eficiente que repetir una y otra vez a mano las pruebas con el
        navegador.<br>
        Fíjate que si usas <i>@ISBN(search=false)</i> esta prueba no funciona
        porque no solo comprueba el formato sino que también hace la búsqueda
        con el servicio REST. Por tanto, has de usar <em>@ISBN</em> sin
        atributos para anotar la propiedad <i>isbn </i>y poder ejecutar esta
        prueba.<br>
        Ahora ejecuta todas las prueba de tu aplicación <em>Facturación</em>
        para verificar que todo sigue en su sitio.</div>
      <div class="wiki" style="display: block;">
        <h2 id="probar-refinar-el-comportamiento-predefinido"><a name="Pruebas-JUnit"></a>Probar
          refinar el comportamiento predefinido</h2>
        <b><span style="color: green;">El código fuente a partir de aquí es para
            ponerlo encima del código de la sección <i>Refinar el
              comportamiento predefinido</i>, hasta nuevo aviso.</span></b></div>
      <div class="wiki" style="display: block;"> Hemos refinado la manera en que
        tu aplicación borra entidades, además hemos añadido dos módulos
        personalizados, los módulos papelera. Antes de seguir adelante, tenemos
        que escribir las pruebas de estas nuevas funcionalidades.<br>
        <h3 id="toc21"><a name="Pruebas-JUnit-Probar-el-comportamiento-personalizado-para-borrar"></a>Probar
          el comportamiento personalizado para borrar</h3>
        No hemos de escribir una prueba para esto, porque el código actual de
        prueba ya comprueba esta funcionalidad de borrado. Generalmente, cuando
        cambias la implementación de cierta funcionalidad pero no su uso desde
        el punto de vista del usuario, como es nuestro caso, no necesitas añadir
        nuevas pruebas.<br>
        Ejecuta todas las prueba de tu aplicación y ajusta los detalles
        necesarios para que funcionen bien. Realmente, solo necesitarás cambiar
        “CRUD.delete” por “Facturacion.delete” y “CRUD.deleteSelected” por
        “Facturacion.deleteSelected” en algunas pruebas. El siguiente código
        resume los cambios que necesitas aplicar a tu código de pruebas.<br>
        <pre><code class="java">// En el archivo PruebaCliente.java
public class PruebaCliente extends ModuleTestBase {
    ...
    public void testCrearLeerActualizarBorrar() throws Exception {
        ...
        // Borrar
        // execute("CRUD.delete");
        execute("Facturacion.delete");
        assertMessage("Cliente borrado satisfactoriamente");
    }
    ...
}
 
// En el archivo PruebaDocumentoComercial.java
abstract public class PruebaDocumentoComercial extends ModuleTestBase {
    ...
    private void borrar() throws Exception {
        // execute("CRUD.delete");
        execute("Facturacion.delete");
        assertNoErrors();
    }
    ...
}
 
// En el archivo PruebaProducto.java
public class PruebaProducto extends ModuleTestBase {
    ...
    public void testBorrarDesdeLista() throws Exception {
        //execute("CRUD.deleteSelected");
        execute("Facturacion.deleteSelected");
        assertListRowCount(1);
    }
    ...
}
 
// En el archivo PruebaPedido.java
public class PruebaPedido extends PruebaDocumentoComercial {
    ...
    public void testPonerFactura() throws Exception {
        ...
        //execute("CRUD.deleteRow", "row=0");
        execute("Facturacion.deleteRow", "row=0");
        ...
    }
}
</code></pre> Después de estos cambios todas tus prueba funcionarán bien y esto
        confirma que tus acciones para borrar personalizadas conservan la
        semántica original. Solo ha cambiado la implementación.<br>
        <h3 id="toc22"><a name="Pruebas-JUnit-Probar-varios-modulos-en-el-mismo-metodo-de-prueba"></a>Probar
          varios módulos en el mismo método de prueba</h3>
        También has de probar los nuevos módulos personalizados, <em>PapeleraPedido</em>
        y <em>PapeleraFactura</em>. De paso, verificaremos que la lógica de
        borrado funciona bien, y que la entidades son solo marcadas como
        borradas y no son borradas de verdad.<br>
        Para probar el módulo <em>PapeleraFactura</em> seguiremos los
        siguientes pasos:<br>
        <ul>
          <li>Empezamos en el módulo <em>Factura</em>.</li>
          <li>Borramos una factura desde modo detalle y verificamos que ha sido
            borrada.</li>
          <li>Borramos una factura desde modo lista y verificamos que ha sido
            borrada.</li>
          <li>Vamos al módulo <em>PapeleraFactura</em>.</li>
          <li>Verificamos que contiene las dos facturas borradas.</li>
          <li>Las restauramos y verificamos que desaparecen de la lista del
            módulo papelera.</li>
          <li>Volvemos al módulo <em>Factura</em>.</li>
          <li>Verificamos que las dos facturas restauradas están en la lista.</li>
        </ul>
        Puedes observar como empezamos en el módulo <em>Factura</em>. Además,
        seguramente te hayas dado cuenta de que la prueba para <em>Pedido</em>
        es exactamente igual. Por tanto, en vez de crear dos nuevas clases de
        prueba, <em>PruebaPapeleraPedido</em> y <em>PruebaPapeleraFactura</em>,
        simplemente añadiremos un método de prueba en la ya existente <em>PruebaDocumentoComercial</em>.
        Así, reutilizaremos el mismo código para probar <em>PedidoPapelera</em>,
        <em>PapeleraFactura</em> y la lógica personalizada de borrado. Añade el
        código del siguiente método <em>testPapelera()</em> a <em>PruebaDocumentoComercial</em>:<br>
        <pre><code class="java">public void testPapelera() throws Exception {
    login("admin", "admin");
    confirmarSoloUnaPaginaEnLista(); // Sólo una página en la lista, es decir menos de 10 filas
 
    // Borrar desde modo detalle
    int numeroFilasInicial = getListRowCount();
    String anyo1 = getValueInList(0, 0);
    String numero1 = getValueInList(0, 1);
    execute("List.viewDetail", "row=0");
    execute("Facturacion.delete");
    execute("Mode.list");
 
    assertListRowCount(numeroFilasInicial - 1); // Hay una fila menos
    confirmarDocumentoNoEstaEnLista(anyo1, numero1); // La entidad borrada no está en lista
 
    // Borrar desde el modo lista
    String anyo2 = getValueInList(0, 0);
    String numero2 = getValueInList(0, 1);
    checkRow(0);
    execute("Facturacion.deleteSelected");
    assertListRowCount(numeroFilasInicial - 2); // Hay dos filas menos
    confirmarDocumentoNoEstaEnLista(anyo2, numero2); // La otra entidad borrada no está en la lista
 
    // Verificar la entidades borradas en el módulo papelera
    changeModule("Papelera" + modelo); // model puede ser 'Factura' o 'Pedido'
    confirmarSoloUnaPaginaEnLista();
    int numeroFilasInicialPapelera = getListRowCount();
    confirmarDocumentoEstaEnLista(anyo1, numero1); // Verificamos que las entidades borradas
    confirmarDocumentoEstaEnLista(anyo2, numero2); // están en la lista del módulo papelera
 
    // Restaurar usando una acción de fila
    int fila1 = getFilaDocumentoEnLista(anyo1, numero1);
    execute("Papelera.restaurar", "row=" + fila1);
    assertListRowCount(numeroFilasInicialPapelera - 1); // 1 fila menos después de restaurar
    confirmarDocumentoNoEstaEnLista(anyo1, numero1); // La entidad restaurada ya
        // no se muestra en la lista del módulo papelera
 
    // Restaurar seleccionando una fila y usando el botón de abajo
    int fila2 = getFilaDocumentoEnLista(anyo2, numero2);
    checkRow(fila2);
    execute("Papelera.restaurar");
    assertListRowCount(numeroFilasInicialPapelera - 2); // 2 filas menos
    confirmarDocumentoNoEstaEnLista(anyo2, numero2); // La entidad restaurada ya
        // no se muestra en la lista del módulo papelera
 
    // Verificar las entidades restauradas
    changeModule(modelo);
    assertListRowCount(numeroFilasInicial); // Después de restaurar tenemos
    confirmarDocumentoEstaEnLista(anyo1, numero1); // las filas originales de nuevo
    confirmarDocumentoEstaEnLista(anyo2, numero2);
}
</code></pre> Como ves <em>testPapelera()</em> sigue los susodichos pasos.
        Fíjate como usando el método <i>changeModule()</i> de <i>ModuleTestBase</i>
        tu prueba puede cambiar a otro módulo. Usamos esto para cambiar al
        módulo papelera y volver atrás.<br>
        Aquí estamos utilizando algunos métodos auxiliares que has de añadir a <em>PruebaDocumentoComercial</em>.
        El primero es <em>confirmarSoloUnaPaginaEnLista()</em> que confirma que
        el modo lista es apropiado para ejecutar esta prueba. Mira su código:<br>
        <pre><code class="java">private void confirmarSoloUnaPaginaEnLista() throws Exception {
    assertListNotEmpty(); // De ModuleTestBase
    assertTrue("Debe tener menos de 10 filas para ejecutar esta prueba",
        getListRowCount() &lt; 10);
}
</code></pre> Necesitamos tener menos de 10 filas, porque el método <i>getListRowCount()</i>
        informa solo de las filas visualizadas, por tanto si tienes más de 10
        filas (10 es el número de filas por página por defecto) no puedes
        aprovechar <i>getListRowCount()</i>, ya que siempre devolvería 10.<br>
        Los métodos restantes son para verificar que cierto pedido o factura
        está (o no está) en la lista. Míralos a continuación:<br>
        <pre><code class="java">private void confirmarDocumentoNoEstaEnLista(String anyo, String numero)
    throws Exception
{
    assertTrue(
        "Documento " + anyo + "/" + numero + " no debe estar en la lista",
            getFilaDocumentoEnLista(anyo, numero) &lt; 0);
}
 
private void confirmarDocumentoEstaEnLista(String anyo, String numero)
    throws Exception
{
    assertTrue(
        "Documento " + anyo + "/" + numero + " debe estar en la lista",
            getFilaDocumentoEnLista(anyo, numero) &gt;= 0);
}
 
private int getFilaDocumentoEnLista(String anyo, String numero)
    throws Exception
{
    int c = getListRowCount();
    for (int i = 0; i &lt; c; i++) {
        if (anyo.equals(getValueInList(i, 0)) &amp;&amp;
            numero.equals(getValueInList(i, 1)))
        {
            return i;
        }
    }
    return -1;
}
</code></pre> Puedes ver en <em>getFilaDocumentoEnLista()</em> como se hace un
        bucle para buscar valores concretos en una lista.<br>
        Ahora puedes ejecutar todas las pruebas de tu aplicación <em>Facturacion</em>.
        Todo tiene que salir en color verde.</div>
      <div class="wiki" style="display: block;">
        <h2><a name="probar-comportamiento-y-logica-de-negocio"></a>Probar
          comportamiento y lógica de negocio</h2>
        <b><span style="color: green;">El código fuente a partir de aquí es para
            ponerlo encima del código de la sección <i>Comportamiento y lógica
              de negocio</i>, hasta nuevo aviso.</span></b></div>
      <div class="wiki" style="display: block;"> El código que escribimos en la
        sección <i>Comportamiento y lógica de negocio</i> no estará completo
        hasta que no escribamos las pruebas. Recuerda, todo código nuevo tiene
        que tener su correspondiente código de prueba. Escribamos pues las
        pruebas para estas dos nuevas acciones.
        <h3><a name="probar-la-accion-de-modo-detalle"></a>Probar la acción de
          modo detalle</h3>
        Primero probaremos la acción <i>Pedido.crearFactura</i>, la acción para
        crear una factura a partir del modo detalle del pedido visualizado.
        Recordamos aquí como funciona este proceso:<br>
        <img src="files/business-logic-behavior_es010.png" alt="business-logic-behavior_es010.png"
          title="business-logic-behavior_es010.png"><br>
        Ahora vamos a escribir la prueba para verificar que funciona justo de
        esta forma. Añade el método <i>testCrearFacturaDesdePedido()</i> a la
        clase <i>PruebaPedido</i>:
        <pre><code class="java">public void testCrearFacturaDesdePedido() throws Exception {
    login("admin", "admin");
    
    // Buscar el pedido
    buscarPedidoSusceptibleDeSerFacturado(); // Busca un pedido  
    assertValue("entregado", "true"); // El pedido está entregado
    int cantidadDetallesPedido = getCollectionRowCount("detalles"); // Toma nota de
                                      // la cantidad de detalles en el pedido
    execute("Sections.change", "activeSection=1"); // La sección de la factura
    assertValue("factura.anyo", ""); // Todavía no hay factura
    assertValue("factura.numero", ""); // en este pedido

    // Crear la factura
    execute("Pedido.crearFactura"); // Ejecuta la acción que estamos probando (1)
    String anyoFactura = getValue("factura.anyo"); // Verifica que ahora
    assertTrue("Año de fectura ha de tener valor", // hay una factura
        !Is.emptyString(anyoFactura)); // en la pestaña de factura (2)
    String numeroFactura = getValue("factura.numero");
    assertTrue("Número de factura ha de tener valor",
        !Is.emptyString(numeroFactura)); // Is.emptyString() es de org.openxava.util
    assertMessage("Factura " + anyoFactura + "/" + numeroFactura +
        " creada a partir del pedido actual"); // El mensaje de confirmación (3)
    assertCollectionRowCount("factura.detalles", // La factura recién creada
        cantidadDetallesPedido); // tiene el mismo número de detalles que el pedido (4)

    // Restaurar el pedido para poder ejecutar la prueba la siguiente vez
    setValue("factura.anyo", "");
    assertValue("factura.numero", "");
    assertCollectionRowCount("factura.detalles", 0);
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> Esta prueba pulsa el botón para ejecutar la acción <i>Pedido.crearFactura</i>
        (1), entonces verifica que una factura ha sido creada, está siendo
        visualizada en la pestaña de factura (2) y tiene la misma cantidad de
        líneas de detalle que el pedido actual (4). También comprueba que se ha
        generado el mensaje de confirmación correcto (3).<br>
        Para ejecutarla es necesario escoger un pedido susceptible de ser
        facturado. Esto se hace en el método <i>buscarPedidoSusceptibleDeSerFacturado()</i>
        que vamos a examinar en la siguiente sección.
        <h3><a name="buscar-una-entidad-para-la-prueba-usando-el-modo-lista-y-jpa"></a>Buscar
          una entidad para la prueba usando el modo lista y JPA</h3>
        Para seleccionar un pedido adecuado para nuestra prueba usaremos JPA
        para determinar el año y número de ese pedido, y entonces usaremos el
        modo lista para seleccionar este pedido y editarlo en modo detalle. Aquí
        tienes los métodos para implementar esto:
        <pre><code class="java">private void buscarPedidoSusceptibleDeSerFacturado() throws Exception {
    buscarPedidoUsandoLista("entregado = true and factura = null"); // Envía la condición,
}                            // en este caso buscamos por un pedido entregado y sin factura

private void buscarPedidoUsandoLista(String condicion) throws Exception {
    Pedido pedido = buscarPedido(condicion); // Busca el pedido con la condición usando JPA
    String anyo = String.valueOf(pedido.getAnyo());
    String numero = String.valueOf(pedido.getNumero());
    setConditionValues(new String [] { anyo, numero }); // Llena el año y el número
    execute("List.filter"); // y pulsa en el botón filtrar en la lista
    assertListRowCount(1); // Sólo una fila, correspondiente al pedido buscado
    execute("List.viewDetail", "row=0"); // Para ver el pedido en modo detalle
    assertValue("anyo", anyo); // Verifica que el pedido editado
    assertValue("numero", numero); // es el deseado
}

private Pedido buscarPedido(String condicion) {
    Query query = XPersistence.getManager().createQuery( // Crea una consulta JPA
        "from Pedido p where p.eliminado = false and " // a partir de la condición. Fíjate en
        + condicion); // deleted = false para excluir los pedidos borrados
    List&lt;Pedido&gt; pedidos = query.getResultList();
    if (pedidos.isEmpty()) { // Es necesario al menos un pedido con la condición
        fail("Para ejecutar esta prueba necesitas tener al menos un pedido con " + condicion);
    }
    return pedidos.get(0);
}
</code></pre>Además necesitas añadir los siguiente imports a <i>PruebaPedido</i>
        para que te compile:
        <pre><code class="java">import java.util.*;
import javax.persistence.*;
import org.openxava.jpa.*;
import org.openxava.util.*;
import com.tuempresa.facturacion.modelo.*;
</code></pre>El método <i>buscarPedidoSusceptibleDeSerFacturado()</i>
        simplemente llama a un método más genérico, <i>buscarPedidoUsandoLista()</i>,
        para buscar una entidad por una condición. El método <i>buscarPedidoUsandoLista()</i>
        obtiene la entidad <i>Pedido</i> mediante <i>buscarPedido()</i>,
        entonces usa la lista para filtrar por el año y el número a partir de
        este <i>Pedido</i>, yendo a modo detalle al finalizar. El método <i>buscarPedido()</i>
        usa JPA simple y llano para buscar.<br>
        Como puedes ver, combinar el modo lista con JPA es una herramienta muy
        útil en ciertas circunstancias. Usaremos los métodos <i>buscarPedidoUsandoLista()</i>
        y <i>buscarPedido()</i> en las siguientes pruebas.
        <h3><a name="probar-que-la-accion-se-oculta-cuando-no-aplica"></a>Probar
          que la acción se oculta cuando no aplica</h3>
        Recuerda que refinamos el módulo <i>Pedido</i> para que mostrara la
        acción para crear la factura sólo cuando el pedido visualizado fuese
        susceptible de ser facturado. Éste es el método de prueba para este
        caso, añádelo a <i>PruebaPedido</i>:
        <pre><code class="java">public void testOcultaCrearFacturaDesdePedidoCuandoNoAplicable() throws Exception {
    login("admin", "admin");
    buscarPedidoUsandoLista(
        "entregado = true and factura &lt;&gt; null"); // Si el pedido ya tiene factura
    assertNoAction("Pedido.crearFactura"); // no se puede facturar otra vez
    execute("Mode.list");
    buscarPedidoUsandoLista(
        "entregado = false and factura = null"); // Si el pedido no está entregado
    assertNoAction("Pedido.crearFactura"); // no se puede facturar
    execute("CRUD.new"); // Si el pedido todavía no está grabado
    assertNoAction("Pedido.crearFactura"); // no puede ser facturado
}
</code></pre> Probamos tres casos en los que el botón para crear la factura no
        tiene que estar presente. Fíjate en el uso de <i>assertNoAction()</i>
        para preguntar si el vínculo o botón para una acción está presente en la
        interfaz de usuario. Aquí estamos reutilizando el método <i>buscarPedidoUsandoLista()</i>
        desarrollado en la sección anterior.<br>
        Ya hemos probado que el botón está presente cuando el pedido es adecuado
        en la prueba <i>testCrearFacturaDesdePedido()</i>, porque <i>execute()</i>
        falla si la acción no está en la interfaz de usuario.
        <h3><a name="probar-la-accion-de-modo-lista"></a>Probar la acción de
          modo lista</h3>
        Ahora probaremos <i>Pedido.crearFacturaDesdePedidosSeleccionados</i>,
        la acción que crea una factura desde varios pedidos en modo lista.
        Recordemos su funcionamiento:<br>
        <img src="files/business-logic-behavior_es030.png" alt="business-logic-behavior_es030.png"
          title="business-logic-behavior_es030.png"><br>
        Escribamos una prueba para verificar que esto funciona justo de esta
        forma. Añade el método <i>testCrearFacturaDesdePedidosSeleccionados()</i>
        a la clase <i> PruebaPedido</i>:
        <pre><code class="java">public void testCrearFacturaDesdePedidosSeleccionados() throws Exception {
    login("admin", "admin");
    verificarPedido(2021, 2, 1, "45.98"); // El pedido 2021/2 tiene 1 línea y 45,98 de importe base
    verificarPedido(2021, 4, 2, "98.01"); // El pedido 2021/4 tiene 2 líneas y 98,01 de importe base
	
    execute("List.orderBy", "property=numero"); // Ordena la lista por número
    checkRow( // Marca la fila a partir del número de fila
        getFilaDocumentoEnLista("2021", "2") // Obtiene la fila del año y número del pedido
    );             // por tanto, esta línea marca la línea del pedido 2021/2 en la lista (1)
    checkRow(
        getFilaDocumentoEnLista("2021", "4") // Marca el pedido 2021/4 en la lista (1)
    ); 
    execute("Pedido.crearFacturaDesdePedidosSeleccionados"); // Ejecuta la acción que
                                                             // estamos probando (2)
    String anyoFactura = getValue("anyo"); // Ahora estamos viendo el detalle de
    String numeroFactura = getValue("numero"); // la factura recién creada
    assertMessage("Factura " + anyoFactura + "/" + numeroFactura +
        " creada a partir de los pedidos: [2021/2, 2021/4]"); // El mensaje de confirmación
    assertCollectionRowCount("detalles", 3); // Confirma que el número de líneas de la
                      // factura recién creada es la suma de la de los pedidos fuente (3)
    assertValue("importeTotal", "143,99"); // Confirma que el importe base de la factura
                               // recién creada es la suma de la de los pedidos fuente (4)
    execute("Sections.change", "activeSection=1"); // Cambia a la pestaña de
                                                   // pedidos de la factura
    assertCollectionRowCount("pedidos", 2); // La nueva factura tiene 2 pedidos (5)
    assertValueInCollection("pedidos", 0, 0, "2021"); // y son los correctos
    assertValueInCollection("pedidos", 0, 1, "2");
    assertValueInCollection("pedidos", 1, 0, "2021");
    assertValueInCollection("pedidos", 1, 1, "4");
	
    assertAction("EdicionFactura.grabar"); // Los botones GRABAR (6)
    assertAction("EdicionFactura.cerrar"); // y CERRAR (6)
	
    checkRowCollection("pedidos", 0); // Seleccionamos los 2 pedidos
    checkRowCollection("pedidos", 1);
    execute("Collection.removeSelected", // y los borramos, para ejecutar esta prueba
        "viewObject=xava_view_section1_pedidos"); // otra vez usando los mismo pedidos
    assertNoErrors();
	
    execute("EdicionFactura.cerrar"); // Vuelve a la lista de pedidos (7)
    confirmarDocumentoEstaEnLista("2021", "2"); // Confirma que estamos realmente
    confirmarDocumentoEstaEnLista("2021", "4"); // en la lista de pedidos
}
</code></pre> Esta prueba marca dos pedidos (1) y pulsa en el botón CREAR
        FACTURA DESDE LOS PEDIDOS SELECCIONADOS (2). Entonces verifica que se ha
        creado una nueva factura con el número correcto de líneas (3), importe
        total (4) y lista de pedidos (5). También verifica que las acciones
        GRABAR y CERRAR están disponibles (6) y usa el botón CERRAR para volver
        a la lista de pedidos (7).<br>
        Usamos <i>getFilaDocumentoEnLista()</i> y <i>confirmarDocumentoEstaEnLista()</i>,
        métodos de la clase base <i>PruebaDocumentoComercial</i>, que fueron
        definidos originalmente como privados, por lo tanto tenemos que
        redefinirlos como protegidos para poder utilizarlos desde <i>PruebaPedido</i>.
        Edita <i>PruebaDocumentoComercial</i> y haz los siguientes cambios:
        <pre><code class="java">protected void confirmarDocumentoEstaEnLista(String anyo, String numero) ... // protected en lugar
// private void confirmarDocumentoEstaEnLista(String anyo, String numero) ... // de private

protected int getFilaDocumentoEnLista(String anyo, String numero) ... // protected en lugar
// private int getFilaDocumentoEnLista(String anyo, String numero) ... // de private
</code></pre> El único detalle pendiente es el método <i>verificarPedido()</i>
        que veremos en la siguiente sección.
        <h3><a name="verificar-datos-de-prueba"></a>Verificar datos de prueba</h3>
        En la lección sobre pruebas automáticas aprendiste como confiar en datos
        existentes en la base de datos para tus pruebas. Obviamente, si tu base
        de datos se altera accidentalmente tus pruebas, aunque correctas, no
        pasarán. Por tanto, verificar los valores de la base de datos antes de
        ejecutar la prueba que confía en ellos es una buena práctica. En nuestro
        ejemplo lo hacemos llamando a <i>verificarPedido()</i> al principio.
        Veamos el contenido de <i>verificarPedido()</i> en <i>PruebaPedido</i>:
        <pre><code class="java">private void verificarPedido(
    int anyo, int numero, int cantidadDetalles, String importeTotal)
{
    Pedido pedido = buscarPedido("anyo = " + anyo + " and numero=" + numero);
    assertEquals("Para ejecutar esta prueba el pedido " +
        pedido + " tiene que tener " + cantidadDetalles + " detalles",
        cantidadDetalles, pedido.getDetalles().size());
    assertTrue("Para ejecutar esta prueba el pedido " +
        pedido + " must have " + importeTotal + " como importe total",
        pedido.getImporteTotal().compareTo(new BigDecimal(importeTotal)) == 0);
    assertTrue("Para ejecutar esta prueba el pedido " + pedido + " tiene que estar entegrado",
        pedido.isEntregado());        
}
</code></pre> Este método busca un pedido y verifica la cantidad de líneas, el
        importe total y si el pedido está entregado. Usar este método tiene la
        ventaja de que si los pedidos necesarios para la prueba no están en la
        base de datos con los valores correctos obtienes un mensaje preciso.
        Así, no derrocharás tu tiempo intentando adivinar que es lo que está
        mal. Esto es especialmente útil si la prueba no la está ejecutando el
        programador original. Por cierto, si te resulta dificil adaptar tus
        pedidos para que se ajusten a esta prueba (número de pedido, importe,
        número de líneas), puedes adaptar los valores en la prueba a tus pedidos
        actuales.<br>
        <h3><a name="probar-casos-excepcionales"></a>Probar casos excepcionales</h3>
        Dado que la acción para crear la factura se oculta si el pedido no está
        listo para ser facturado, no podemos probar el código para los casos
        excepcionales desde modo detalle. Sin embargo, en modo lista el usuario
        todavía tiene la opción de escoger cualquier pedido para facturar. Por
        tanto, intentaremos crear la factura desde la lista de pedidos para
        probar que los casos excepcionales se comportan correctamente. Añade el
        siguiente código a <i>PruebaPedido</i>:
        <pre><code class="java">public void testExcepcionesCreandoFacturaDesdePedido() throws Exception {
    login("admin", "admin");
    confirmarExcepcionCreandoFacturaDesdePedido( // Confirma que cuando el pedido ya tiene (1)
        "entregado = true and factura &lt;&gt; null", // factura se produce el error correcto
        "Ha sido imposible ejecutar la acción Crear factura desde pedidos seleccionados: " +
            "El pedido ya tiene una factura"
    );
    confirmarExcepcionCreandoFacturaDesdePedido( // Confirma que cuando el pedido no está (2)
        "entregado = false and factura = null", // entregado se produce el error correcto
        "Ha sido imposible ejecutar la acción Crear factura desde pedidos seleccionados: " + 
            "El pedido todavía no está entregado"
    );
}

private void confirmarExcepcionCreandoFacturaDesdePedido(
    String condicion, String mensaje) throws Exception
{
    Pedido pedido = buscarPedido(condicion); // Busca el pedido por la condición (3)
    int fila = getFilaDocumentoEnLista( // y obtiene el número de fila para ese pedido (4)
       String.valueOf(pedido.getAnyo()),
       String.valueOf(pedido.getNumero())
    );
    checkRow(fila); // Marca la fila (5)
    execute("Pedido.crearFacturaDesdePedidosSeleccionados"); // Trata de crear la factura (6)
    assertError(mensaje); // ¿Se ha mostrado el mensaje esperado? (7)
    uncheckRow(fila); // Desmarca la fila, así podemos llamar a este método otra vez
}
</code></pre> La prueba verifica que el mensaje es el correcto cuando tratamos
        de crear una factura a partir de un pedido que ya tiene factura (1), y
        también desde un pedido no entregado todavía (2). Para hacer estas
        verificaciones llama al método <i>confirmarExcepcionCreandoFacturaDesdePedido()</i>.
        Este método busca la entidad <i>Pedido</i> usando la condición (3),
        localiza la fila donde la entidad se está visualizando (4) y la marca
        (5). Después, la prueba ejecuta la acción (6) y verifica que el mensaje
        esperado se muestra (7).</div>
      <div class="wiki" style="display: block;">
        <h2><a name="probar-referencias-y-colecciones"></a>Probar referencias y
          colecciones</h2>
        <b><span style="color: green;">El código fuente a partir de aquí es para
            ponerlo encima del código de la sección <i>Referencias y
              colecciones</i>.</span></b></div>
      <div class="wiki" style="display: block;"> Todavía tenemos la sana
        costumbre de hacer un poco de código de aplicación, y después un poco de
        código de pruebas. Y ahora es el tiempo de escribir el código de pruebas
        para las nuevas características añadidas en la sección <i>Referencias y
          colecciones</i>.
        <h3><a name="adaptar-pruebapedido"></a>Adaptar <i>PruebaPedido</i></h3>
        Si ejecutaras <i>PruebaPedido</i> ahora, no pasaría. Esto es porque
        nuestro código confía en ciertos detalles que han cambiado. Por lo
        tanto, hemos de modificar nuestro código de pruebas actual. Edita el
        método <i> testPonerFactura()</i> de <i>PruebaPedido</i> y aplica los
        siguientes cambios:
        <pre><code class="java">public void testPonerFactura() throws Exception {

    ...

    assertValue("factura.numero", "");
    assertValue("factura.anyo", "");
    // execute("Reference.search", // Ya no usamos la acción estándar para
    //    "keyProperty=factura.anyo"); // buscar la factura, en su lugar
    execute("Pedido.buscarFactura", // usamos nuestra acción personalizada (1)
        "keyProperty=factura.numero");
    execute("List.orderBy", "property=numero");

    ...
	
    // Restaurar valores
    setValue("factura.anyo", ""); // Ahora es necesario teclear el año
    setValue("factura.numero", ""); // y el número para buscar la factura (2)
    setValue("entregado", "false");
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> Recuerda que anotamos la referencia <i>factura</i> en <i>Pedido</i>
        con <i>@SearchAction("Pedido.buscarFactura")</i>, por tanto hemos de
        modificar la prueba para llamar a <i>Pedido.buscarFactura</i> (1) en
        vez de a <i>Reference.search</i>. También añadimos <i>@SearchKey</i> a
        <i>anyo</i> y <i>numero</i> de <i>CommercialDocument</i>, por lo tanto
        nuestra prueba ha de indicar <i>anyo</i> tanto como <i>numero</i> para
        obtener (o en este caso borrar) una factura (2). Por causa de esto
        último también hemos de modificar <i> testCrearFacturaDesdePedido()</i>
        de <i>PruebaPedido</i> como se muestra:
        <pre><code class="java">public void testCrearFacturaDesdePedido() throws Exception {

    ...

    // Restaurar el pedido para ejecutar la prueba la siguiente vez
    setValue("factura.anyo", ""); // Ahora es necesario teclear el año
    setValue("factura.numero", ""); // y el número para buscar la factura (2)
    assertValue("factura.numero", "");
    assertCollectionRowCount("factura.detalles", 0);
    execute("CRUD.save");
    assertNoErrors();
}
</code></pre> Después de estos cambios <i>PruebaPedido</i> tiene que pasar. Sin
        embargo, todavía nos queda probar la nueva funcionalidad del módulo <i>Pedido</i>.
        <h3><a name="probar-searchaction"></a>Probar <i>@SearchAction</i></h3>
        Hemos usado <i>@SearchAction</i> en la referencia <i>factura</i> de <i>Pedido</i>
        para mostrar en la lista de búsqueda solo facturas del cliente del
        pedido actual. Añade el siguiente método a <i>PruebaPedido</i> para
        probar esta funcionalidad :
        <pre><code class="java">public void testBuscarFacturaDesdePedido() throws Exception {
    login("admin", "admin");      
    execute("CRUD.new");
    setValue("cliente.numero", "1"); // Si el cliente es 1...
    execute("Sections.change", "activeSection=1");
    execute("Pedido.buscarFactura", // ...cuando el usuario pulsa para escoger una factura...
        "keyProperty=factura.numero");
    confirmarClienteEnTodasFilas("1"); // ...sólo se muestran las facturas del cliente 1
    execute("ReferenceSearch.cancel");
    execute("Sections.change", "activeSection=0");
    setValue("cliente.numero", "2"); // Y si el cliente es 2...
    execute("Sections.change", "activeSection=1");
    execute("Pedido.buscarFactura", // ...cuando el usuario pulsa para escoger una factura...
        "keyProperty=factura.numero");
    confirmarClienteEnTodasFilas("2"); // ...sólo se muestran las facturas del cliente 2
}
</code></pre> La parte más peliaguda es verificar la lista de facturas, este es
        el trabajo <i>confirmarClienteEnTodasFilas()</i> en <i>PruebaPedido</i>:<br>
        <pre><code class="java">private void confirmarClienteEnTodasFilas(String numeroCliente) throws Exception {
    assertListNotEmpty();
    int c = getListRowCount();
    for (int i=0; i&lt;c; i++) { // Un bucle por todas las filas
        if (!numeroCliente.equals(getValueInList(i, "cliente.numero"))) {
            fail("Cliente en fila " + i + // Si el cliente no es el esperado falla
                " no es " + numeroCliente);
        }
    }
}
</code></pre> Consiste en un bucle por todas la filas verificando el número de
        cliente.
        <h3><a name="probar-onchangesearch"></a>Probar <i>@OnChangeSearch</i></h3>
        Hemos usado <i>@OnChangeSearch</i> en la referencia <i>factura</i> de
        <i>Pedido</i> para asignar automáticamente el cliente de la factura
        escogida al pedido actual cuando el usuario todavía no tiene cliente, o
        para verificar que el cliente de la factura y del pedido coinciden, si
        el pedido ya tiene cliente. Aquí se muestra el método de prueba en <i>PruebaPedido</i>:
        <pre><code class="java">public void testAlCambiarFactura() throws Exception {
    login("admin", "admin");
    execute("CRUD.new"); // Estamos creando un nuevo pedido
    assertValue("cliente.numero", ""); // por tanto no tiene cliente todavía
    execute("Sections.change", "activeSection=1");
    execute("Pedido.buscarFactura", // Busca la factura usando una lista
        "keyProperty=factura.numero");

    execute("List.orderBy", "property=cliente.numero"); // Ordena por cliente
    String numeroCliente1 = getValueInList(0, "cliente.numero"); // Memoriza..
    String anyoFactura1 = getValueInList(0, "anyo"); // ...los datos de la...
    String numeroFactura1 = getValueInList(0, "numero"); // ...primera factura
    execute("List.orderBy", "property=cliente.numero"); // Ordena por cliente
    String numeroCliente2 = getValueInList(0, "cliente.numero"); // Memoriza...
    String nombreCliente2 = getValueInList(0, "cliente.nombre"); // ...los datos de...
                                                                 // ...la última factura
    assertNotEquals("Han de ser facturas de diferentes clientes",
        numeroCliente1, numeroCliente2);// Las 2 facturas memorizadas no son la misma
    execute("ReferenceSearch.choose","row=0"); // La factura se escoge con la lista (1)
    execute("Sections.change", "activeSection=0");
    assertValue("cliente.numero", numeroCliente2); // Los datos del cliente
    assertValue("cliente.nombre", nombreCliente2); // se rellenan automáticamente (2)

    execute("Sections.change", "activeSection=1");
    setValue("factura.anyo", anyoFactura1); // Tratamos de poner una factura de...
    setValue("factura.numero", numeroFactura1); // ...otro cliente (3)

    assertError("Cliente Nº " + numeroCliente1 + " de la factura " + // Muestra...
        anyoFactura1 + "/" + numeroFactura1 + // ...un mensaje de error... (4)
        " no coincide con el cliente Nº " +
        numeroCliente2 + " del pedido actual");

    assertValue("factura.anyo", ""); // ...y reinicia los datos de la factura (5)
    assertValue("factura.numero", "");
    assertValue("factura.fecha", "");
}
</code></pre> Aquí probamos que nuestra acción <i>@OnChangeSearch</i> rellene
        los datos del cliente (3) al escoger una factura (2), y que si el
        cliente ya está establecido se muestre un mensaje de error (4) y la
        factura se borre de la vista (5). Fíjate como la primera vez usamos la
        lista (1) para escoger la factura y la segunda lo hacemos tecleando el
        año y el número (3).
        <h3><a name="adaptar-pruebafactura"></a>Adaptar <i>PruebaFactura</i></h3>
        Como en el caso de <i>PruebaPedido</i>,<i> PruebaFactura</i> también
        falla. Has de hacer unos pequeños ajustes para que funcione. Edita <i>testAnyadirPedidos()</i>
        de <i>PruebaFactura</i> y aplica los siguiente cambios:
        <pre><code class="java">public void testAnyadirPedidos() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=numero");
    execute("List.viewDetail", "row=0");
    execute("Sections.change", "activeSection=1");
    assertCollectionRowCount("pedidos", 0);
    // execute("Collection.add", // La acción estándar para añadir pedidos ya no se usa
    execute("Factura.anyadirPedidos", // En su lugar usamos nuestra propia acción
        "viewObject=xava_view_section1_pedidos");
    // seleccionarPrimerPedidoConEntregadoIgual("Entregado"); // Ahora todos los pedidos de la lista 
    // seleccionarPrimerPedidoConEntregadoIgual(""); // están entregados; esto ya no hace falta 	
    // execute("AddToCollection.add"); // En lugar de la acción estándar
    execute("AnyadirPedidosAFactura.add", "row=0"); // ...ahora tenemos la nuestra propia
    // assertError("¡ERROR! 1 elemento(s) NO añadido a Pedidos de Factura"); // Es
                  // imposible porque el usuario no puede escoger pedidos incorrectos
    assertMessage("1 elemento(s) añadido a Pedidos de Factura");
    assertCollectionRowCount("pedidos", 1);
    checkRowCollection("pedidos", 0);
    execute("Collection.removeSelected",
        "viewObject=xava_view_section1_pedidos");
    assertCollectionRowCount("pedidos", 0);
}
</code></pre> Ya no necesitamos el método <i>seleccionarPrimerPedidoConEntregadoIgual()</i>,
        por tanto podemos quitarlo de <i>PruebaFactura</i>:
        <pre><code class="java">// Quita seleccionarPrimerPedidoConEntregadoIgual() de PruebaFactura
// private void seleccionarPrimerPedidoConEntregadoIgual(String valor)
// throws Exception { ... }
</code></pre> Después de estos cambios <i>PruebaFactura</i> ha de funcionar.
        Sin embargo, todavía nos queda probar la nueva funcionalidad del módulo
        <i>Factura</i>.
        <h3><a name="probar-addaction"></a>Probar <i>@AddAction</i></h3>
        En esta lección anotamos la colección <i>pedidos</i> de <i>Factura</i>
        con <i>@AddAction</i> para refinar la lista de pedidos a ser añadidos a
        la colección. De esta forma solo los pedidos entregados del cliente de
        la factura actual y todavía sin facturar se mostraban. Vamos a probar
        esto, y al mismo tiempo, aprenderemos como refactorizar el código
        existente para poder reutilizarlo.&nbsp; <br>
        Primero queremos verificar que la lista para añadir pedidos solo
        contiene pedidos del cliente actual. El siguiente código muestra los
        cambios en <i> testAnyadirPedidos()</i> para conseguir esto:
        <pre><code class="java">public void testAnyadirPedidos() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=numero");
    execute("List.viewDetail", "row=0");
    String numeroCliente = getValue("cliente.numero"); // Tomamos nota del
    execute("Sections.change", "activeSection=1");  // cliente de la factura
    assertCollectionRowCount("pedidos", 0);
    execute("Factura.anyadirPedidos",
        "viewObject=xava_view_section1_pedidos");
    confirmarClienteEnTodasFilas(numeroCliente); // Confirmamos que todos los cliente en
                               // la lista coinciden con el cliente de la factura
    ...

}
</code></pre> Ahora hemos de escribir el método <i>confirmarClienteEnTodasFilas()</i>.
        Pero, espera un momento, ya hemos escrito este método en <i>PruebaPedido</i>.
        Estamos en <i>PruebaFactura</i> por tanto no podemos llamar a este
        método. Por fortuna tanto <i>PruebaFactura</i> como <i>PruebaPedido</i>
        heredan de <i> PruebaDocumentoComercial</i>, por lo tanto sólo tenemos
        que subir el método a la clase madre. Para hacer esto copia el método <i>confirmarClienteEnTodasFilas()</i>
        desde <i> PruebaPedido</i> a <i>PruebaDocumentoComercial</i>,
        cambiando <i>private</i> por <i>protected</i>, tal como se muestra:
        <pre><code class="java">abstract public class PruebaDocumentoComercial extends ModuleTestBase {

    protected void // Cambiamos de private a protected
        confirmarClienteEnTodasFilas(String numeroCliente) throws Exception {

        ...
		
    }

    ...
	
}
</code></pre> Ahora puedes quitar el método <i>confirmarClienteEnTodasFilas()</i>
        de <i>PruebaPedido</i>:
        <pre><code class="java">// Quita confirmarClienteEnTodasFilas() de PruebaPedido
// private void confirmarClienteEnTodasFilas(String numeroCliente)
//     throws Exception { ... }
</code></pre> Después de estos cambios el método <i>testAnyadirPedidos()</i>
        compila y funciona. No solo queremos comprobar que la lista de pedidos
        son del cliente correcto, sino también que están entregados. Nuestro
        primer impulso es copiar y pegar <i>confirmarClienteEnTodasFilas()</i>
        para crear un método <i>confirmarEntregadoEnTodasFilas()</i>. Sin
        embargo, resistimos la tentación, y en vez de eso vamos a crear un
        método reutilizable. Primero, copiamos y pegamos <i>confirmarClienteEnTodasFilas()</i>
        como <i>confirmarValorEnTodasFilas()</i>. Aquí puedes ver estos dos
        métodos en <i>PruebaDocumentoComercial</i>:
        <pre><code class="java">protected void confirmarClienteEnTodasFilas(String numeroCliente) throws Exception {
    assertListNotEmpty();
    int c = getListRowCount();
    for (int i=0; i&lt;c; i++) { 
        if (!numeroCliente.equals(
		    getValueInList(i, "cliente.numero"))) // Preguntamos por el cliente de forma fija
        {
            fail("Cliente en fila " + i + 
                " no es " + numeroCliente);
        }
    }
}
  
protected void confirmarValorEnTodasFilas(int columna, String valor) throws Exception {
    assertListNotEmpty();
    int c = getListRowCount();
    for (int i=0; i&lt;c; i++) {
        if (!valor.equals(
            getValueInList(i, columna))) // Preguntamos por la columna enviada como parámetro
        {
            fail("Columna " + columna + " en fila " + i + " no es " + valor);
        }
    }
}
</code></pre> Puedes ver como con unas ligeras modificaciones hemos convertido
        en un método genérico para preguntar por el valor de cualquier columna,
        no solo por la del número de cliente. Ahora hemos de quitar el código
        redundante, puedes, bien quitar <i>confirmarClienteEnTodasFilas()</i> o
        bien reimplementarlo usando el nuevo método. El siguiente código en <i>PruebaDocumentoComercial</i>
        muestra la última opción:<br>
        <pre><code class="java">protected void confirmarClienteEnTodasFilas(String numeroCliente) throws Exception {
    confirmarValorEnTodasFilas(3, numeroCliente); // Número de cliente está en la columna 3
}
</code></pre> Usemos <i>confirmarValorEnTodasFilas()</i> para verificar que la
        lista de pedidos contiene solo pedidos entregados. El siguiente código
        muestra la modificación necesaria en <i>testAnyadirPedidos()</i> de <i>PruebaFactura</i>.
        <pre><code class="java">public void testAnyadirPedidos() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=numero");
    execute("List.viewDetail", "row=0");
    String numeroCliente = getValue("cliente.numero");
    execute("Sections.change", "activeSection=1");
    assertCollectionRowCount("pedidos", 0);
    execute("Factura.anyadirPedidos",
        "viewObject=xava_view_section1_pedidos");
    confirmarClienteEnTodasFilas(numeroCliente);
    confirmarValorEnTodasFilas(12, "Entregado"); // Todas las celdas de la columna 12 
                                                // tienen 'Entregado'
    ...
	
}
</code></pre> Además, queremos que solo los pedidos sin factura se muestren en
        la lista. Una forma sencilla de hacerlo es verificando que después de
        añadir un pedido a la factura actual, la lista de pedidos tenga una
        entrada menos. El siguiente código muestra los cambios necesarios en <i>
          testAnyadirPedidos()</i> de <i>PruebaFactura</i> para hacer esto:
        <pre><code class="java">public void testAnyadirPedidos() throws Exception {

    ...

    confirmarClienteEnTodasFilas(numeroCliente);
    confirmarValorEnTodasFilas(12, "Entregado");
    int cantidadPedidos = getListRowCount(); // Tomamos nota de la cantidad de pedidos
    execute("AnyadirPedidosAFactura.add", "row=0"); // cuando se muestra la lista
    assertMessage("1 elemento(s) añadido a Pedidos de Factura");
    assertCollectionRowCount("pedidos", 1); // Se añadió un pedido
    execute("Factura.anyadirPedidos", // Mostramos la lista de pedidos otra vez
        "viewObject=xava_view_section1_pedidos");
    assertListRowCount(cantidadPedidos - 1); // Tenemos un pedido menos en la lista
    execute("AddToCollection.cancel");

    ...
	
}
</code></pre> Con el código de esta sección hemos probado la <i>@AddAction</i>
        de la colección <i> pedidos</i>, y al mismo tiempo hemos visto como no
        es necesario crear código genérico desde el principio, porque no es
        difícil convertir el código concreto en genérico bajo demanda.
        <h3><a name="probar-la-accion-para-anadir-elementos-a-la-coleccion"></a>Probar
          la acción para añadir elementos a la colección</h3>
        En esta lección también aprendimos como refinar la acción para añadir
        pedidos a la factura, ahora es el momento de escribir su correspondiente
        código de prueba. Recuerda que esta acción copia las líneas de los
        pedidos seleccionados a la factura actual. El siguiente código muestra
        los cambios en <i> testAnyadirPedidos()</i> de <i>PruebaFactura</i>
        para probar nuestra acción personalizada para añadir pedidos:
        <pre><code class="java">public void testAnyadirPedidos() throws Exception {

    ...

    String numeroCliente = getValue("cliente.numero");
    assertCollectionRowCount("detalles", 0); // Factura sin detalles para esta preuba
    assertValue("importeTotal", "0,00"); // Sin detalles el importe total es 0
    execute("Sections.change", "activeSection=1");
    assertCollectionRowCount("pedidos", 0);
    execute("Factura.anyadirPedidos", // Cuando mostramos la lista de pedidos (2) ...
        "viewObject=xava_view_section1_orders");
    confirmarClienteEnTodasFilas(numeroCliente);
    confirmarValorEnTodasFilas(12, "Entregado");
    String importeTotalPrimerPedido = getValueInList(0, 7); //..tomamos nota del importe
    int cantidadPedidos = getListRowCount();    // base del primer pedido de la lista (3)

    ...

    assertCollectionRowCount("pedidos", 1);
    execute("Sections.change", "activeSection=0");
    assertCollectionNotEmpty("detalles"); // Hay detalles, han sido copiados (4)
    assertValue("importeTotal", importeTotalPrimerPedido); // El importe total de la factura
    execute("Sections.change", "activeSection=1"); // coincide con el del
                                                   // pedido recién añadido (5)
    ...
	
}
</code></pre>Verificamos que la factura para esta prueba no tiene detalles. A
        continuación, quitamos las líneas de detalle de la factura (1), después
        añadimos un pedido (2), tomando nota de su importe total (3), entonces
        verificamos que la factura actual tiene detalles (4) y que su importe
        total es el mismo que el del pedido añadido (5).
        <div class="wiki" style="display: block;">El método <i>testAnyadirPedidos()</i>
          está acabado. Éste es su código definitivo:
          <pre><code class="java">public void testAnyadirPedidos() throws Exception {
    login("admin", "admin");
    assertListNotEmpty();
    execute("List.orderBy", "property=numero");
    execute("List.viewDetail", "row=0");
    String numeroCliente = getValue("cliente.numero");
    assertCollectionRowCount("detalles", 0);
    assertValue("importeTotal", "0,00");
    execute("Sections.change", "activeSection=1");
    assertCollectionRowCount("pedidos", 0);
    execute("Factura.anyadirPedidos",
        "viewObject=xava_view_section1_pedidos");
    confirmarClienteEnTodasFilas(numeroCliente);
    confirmarValorEnTodasFilas(12, "Entregado");
    String importeTotalPrimerPedido = getValueInList(0, 7);
    int cantidadPedidos = getListRowCount();
    execute("AnyadirPedidosAFactura.add", "row=0");
    assertMessage("1 elemento(s) añadido(s) a Pedidos de Factura");
    assertCollectionRowCount("pedidos", 1);
    execute("Sections.change", "activeSection=0");
    assertCollectionNotEmpty("detalles");
    assertValue("importeTotal", importeTotalPrimerPedido);
    execute("Sections.change", "activeSection=1");
    execute("Factura.anyadirPedidos",
        "viewObject=xava_view_section1_pedidos");
    assertListRowCount(cantidadPedidos - 1);
    execute("AddToCollection.cancel");
    checkRowCollection("pedidos", 0);
    execute("Collection.removeSelected",
        "viewObject=xava_view_section1_pedidos");
    assertCollectionRowCount("pedidos", 0);
}	
</code></pre> Hemos finalizado el código de las pruebas automáticas. Ahora
          puedes ejecutar todas las pruebas de tu proyecto. Han de salir en
          color verde.</div>
      </div>
      <h2 id="resumen">Resumen</h2>
      Has automatizado las pruebas de toda la funcionalidad de tu aplicación.
      Puede parecer que este código de prueba es mucho más largo y aburrido que
      el código real de la aplicación. Pero recuerda, el código de prueba es el
      tesoro más valioso que tienes. Quizás ahora no me creas, pero trata de
      hacer pruebas JUnit y una vez te hayan salvado la vida, ya no podrás
      desarrollar sin pruebas automáticas nunca más.<br>
      ¿Qué probar? No hagas pruebas exhaustivas al principio. Es mejor probar
      poco que no probar nada. Si tratas de hacer pruebas muy exhaustivas
      acabarás no haciendo pruebas en absoluto. Empieza haciendo algunas pruebas
      JUnit para tu código, y con cada nueva característica o nuevo arreglo
      añade nuevas pruebas. Al final, tendrás una suite de pruebas muy completa.
      En resumen, prueba poco, pero prueba siempre.<br>
      <br>
      <strong>¿Problemas con la lección? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/437013/"
          rel="nofollow">Pregunta en el foro</a></strong><strong></strong> </div>
  </body>
</html>
