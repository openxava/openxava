<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Lección 9: Lógica de negocio básica - OpenXava</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" style="display: block;">
      <h1 id="toc0"><a name="Leccion-5-Logica-de-negocio-basica"></a> <span id="breadcrumbs">
          <span id="openxava"> <a href="https://www.openxava.org/"> <span>o</span>pen<span>x</span>ava
              </a> </span> / <a href="index_es.html">documentación</a> / </span>
        Lección 9: Propiedades de Java</h1>
      <strong>Curso</strong>: <a class="wiki_link" href="getting-started_es.html">1.
        Primeros pasos</a> | <a class="wiki_link" href="basic-domain-model1_es.html">2.
        Modelo básico del dominio (1)</a> | <a class="wiki_link" href="basic-domain-model2_es.html">3.
        Modelo básico del dominio (2)</a> | <a class="wiki_link" href="refining-user-interface_es.html">4.
        Refinar la interfaz de usuario</a> | <a class="wiki_link" href="agile-development_es.html">5.
        Desarrollo ágil</a> | <a class="wiki_link" href="mapped-superclass-inheritance_es.html">6.
        Herencia de superclases mapeadas</a> | <a class="wiki_link" href="entity-inheritance_es.html">7.
        Herencia de entidades</a> | <a class="wiki_link" href="view-inheritance_es.html">8.
        Herencia de vistas</a> | <strong>9. Propiedades Java</strong> | <a class="wiki_link"

        href="total-properties-with-calculation_es.html">10. Propiedades de
        total con Calculation</a> | <a class="wiki_link" href="jpa-retrocalling-methods_es.html">11.
        Métodos de retrollamadas JPA</a> | <a class="wiki_link" href="validation_es.html">12.
        Validación avanzada</a> | <a class="wiki_link" href="refining-standard-behavior_es.html">13.
        Refinar el comportamiento predefinido</a> | <a class="wiki_link" href="business-logic-behavior_es.html">14.
        Comportamiento y lógica del negocio</a> | <a class="wiki_link" href="references-collections_es.html">15.
        Referencias y colecciones</a> | <a class="wiki_link" href="philosophy_es.html">A.
        Arquitectura y filosofía</a> | <a class="wiki_link" href="jpa_es.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_es.html">C.
        Anotaciones</a> | <a class="wiki_link" href="testing_es.html">D.
        Pruebas automáticas</a>
      <hr>
      <div id="toc">
        <h1 class="nopad">Tabla de contenidos</h1>
        <div style="margin-left: 1em;"><a href="#Leccion-5-Logica-de-negocio-basica">Lección
            9: Propiedades de Java<br>
          </a></div>
        <div style="margin-left: 2em;"><a href="#Propiedades-persistentes">Propiedades
            persistentes<br>
          </a></div>
        <div style="margin-left: 2em;"><a href="#Propiedades-calculadas">Propiedades
            calculadas</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Propiedad-calculada-simple">Propiedad
            calculada simple</a></div>
        <div style="margin-left: 3em;"><a href="#Propiedades-calculadas-Usar-DefaultValueCalculator">Usar
            @DefaultValueCalculator</a><a href="#Resumen"><br>
          </a></div>
        <div style="margin-left: 3em;"><a href="#Resumen">Resumen</a> </div>
      </div>
      Has convertido tu modelo del dominio en una aplicación web plenamente
      funcional. Esta aplicación ya es bastante útil de por sí, aunque aún
      puedes hacerle muchas mejoras. Transformemos pues tu aplicación en algo
      más serio, y de paso, aprendamos algunas cosas interesantes sobre
      OpenXava.<br>
      Empezaremos por añadir algo de lógica de negocio a tus entidades para
      hacer de tu aplicación algo más que un simple gestor de base de datos.<br>
      <h2><a name="Propiedades-persistentes"></a>Propiedades Persistentes</h2>
      Para entender bien algunos de los conceptos de esta lección has de saber
      cómo funcionan las propiedades en Java. La forma estándar de definir una
      propiedad en Java es:
      <pre><code class="java">// Propiedad
      
private int cantidad; // Tiene un campo

public int getCantidad() { // Un getter para devolver el valor del campo
    return cantidad;
}

public void setCantidad(int cantidad) { // Cambia el valor del campo
    this.cantidad = cantidad;
}
</code></pre>Esto se basa en la idea de que nunca deberiamos acceder al estado
      de un objeto (sus campos) directamente, sino siempre llamando a métodos.
      Esto es muy útil porque puedes cambiar la implementación de una propiedad
      sin afecta al codigo que la usa. Además, todas las herramientas, marcos de
      trabajo y librerias del ecosistema Java confían en esta norma (parte de
      las especificaciones JavaBeans). Por lo tanto, deberiamos usar esta
      convención siempre. Una propiedad en Java es un método getter (<i>getCantidad()</i>
      por ejemplo) y un método setter (<i>setCantidad(int cantidad)</i>) si la
      propiedad es modificable. De hecho, el campo (<i>private int cantidad</i>
      en este caso) no es necesario.<br>
      El problema de este enfoque es que es muy verboso y acabamos con nuestro
      código lleno de getters y setters que no aportan nada y hacen mucho ruido.
      Para resolver este problema usamos una librería llamada Lombok. Con Lombok
      puedes definir la propiedad <i>cantidad</i> de arriba de esta manera:
      <pre><code class="java">@Getter @Setter // Genera un método getter y uno setter
int cantidad; 
</code></pre><i>@Getter</i> y <i>@Setter</i> generan el getter y setter en el
      código compilado, por lo que cuando accedas a la propiedad has de usarlos,
      así:
      <pre><code class="java">int c = elObjeto.getCantidad(); // Nunca int c = elObjeto.cantidad 
elObjeto.setCantidad(c + 10); // Nunca elObjeto.cantidad = c + 10
</code></pre>Puedes declarar <i>@Getter</i> y <i>@Setter</i> a nivel de clase
      y así todos los campos tendrán getter y setter automáticamente. Y por
      supuesto, puedes escribir tu propio setter y getter si quieres usar tu
      propia lógica:
      <pre><code class="java">// @Data // NUNCA USES @Data
@Getter @Setter
public class Incidencia {

    int numero;
    String descripcion;
	
    public String getDescripcion() { // Tu propio getter sobrescribe el generado por Lombok
        if (descripcion == null) return "Todavía sin descripción";
        return descripcion;
    }

}
</code></pre>En este caso Lombok genera para ti <i>getNumero(), setNumero()</i>
      y <i>setDescripcion()</i> mientras que <i>getDescripcion()</i> es el que
      hemos escrito nosotros. Fíjate com nunca deberías usar la anotación <i>@Data</i>
      de Lombok, dado que produce bucles recursivos infinitos si tienes
      referencias recíprocas, algo bastante común en las aplicaciones de
      negocio.
      <h2 id="toc1"><a name="Propiedades-calculadas"></a>Propiedades calculadas</h2>
      Quizás la lógica de negocio más simple que puedes añadir a tu aplicación
      es una propiedad calculada. Las propiedades que has usado hasta ahora son
      persistentes, es decir, cada propiedad se almacena en una columna de una
      tabla de la base de datos. Una propiedad calculada es una propiedad que no
      almacena su valor en la base de datos, sino que se calcula cada vez que se
      accede a la propiedad. Observa la diferencia entre una propiedad
      persistente y una calculada:<br>
      <pre><code class="java">// Propiedad persistente
@Getter @Setter // Tiene getter y setter
int cantidad; // Tiene un campo, por tanto es persistente
 
// Propiedad calculada
public int getImporte() { // No tiene campo, ni setter, solo un getter
    return cantidad * precio; // con un cálculo
}
</code></pre> Las propiedades calculadas son reconocidas automáticamente por
      OpenXava. Puedes usarlas en vistas, listas tabulares o cualquier otra
      parte de tu código.<br>
      Vamos a usar propiedades calculadas para añadir el elemento “económico” a
      nuestra aplicación <em>Facturacion</em>. Porque, tenemos líneas de
      detalle, productos, cantidades. Pero, ¿qué pasa con el dinero?<br>
      <h3 id="toc2"><a name="Propiedades-calculadas-Propiedad-calculada-simple"></a>Propiedad
        calculada simple</h3>
      El primer paso será añadir una propiedad de importe a <em>Detalle</em>.
      Lo que queremos es que cuando el usuario elija un producto y teclee la
      cantidad el importe de la línea sea recalculado y mostrado al usuario:<br>
      <img src="files/business-logic_es010.png" alt="business-logic_es010.png" title="business-logic_es010.png"><br>
      Añadir esta funcionalidad a tu actual código es prácticamente añadir una
      propiedad calculada a <em>Detalle</em>. Simplemente añade el código
      siguiente a la clase <em>Detalle</em>:<br>
      <pre><code class="java">@Stereotype("DINERO")
@Depends("producto.numero, cantidad") // Cuando usuario cambie producto o cantidad
public BigDecimal getImporte() { // esta propiedad se recalculará y se redibujará
    if (producto == null || producto.getPrecio() == null) return BigDecimal.ZERO;
    return new BigDecimal(cantidad).multiply(producto.getPrecio());
}
</code></pre>Es tan solo poner el cálculo en <em>getImporte()</em> y usar <em>@Depends</em>
      para indicar a OpenXava que la propiedad <em>importe</em> depende de <em>producto.numero</em>
      y <em>cantidad</em>, así cada vez que el usuario cambia alguno de estos
      valores la propiedad se recalculará. Fíjate como en este caso usamos <i>producto</i>
      y no <i>getProducto()</i>, y <i>cantidad</i> en vez de <i>getCantidad()</i>,
      porque desde dentro de la clase sí que se puede acceder directamente a sus
      campos.<br>
      Ahora has de añadir esta nueva propiedad a la lista de propiedades
      mostradas en la colección <em>detalles</em> de <em>DocumentoComercial</em>:<br>
      <pre><code class="java">@ElementCollection
@ListProperties("producto.numero, producto.descripcion, cantidad, importe") // importe añadida
Collection&lt;Detalle&gt; detalles;
</code></pre> Nada más. Tan solo necesitas añadir el getter y modificar la lista
      de propiedades. Ahora puedes probar los módulos <em>Factura</em> y <em>Pedido</em>
      para ver la propiedad <em>importe</em> en acción.<br>
      <h3 id="toc3"><a name="Propiedades-calculadas-Usar-DefaultValueCalculator"></a>Usar
        <em>@DefaultValueCalculator</em></h3>
      La forma en que calculamos el importe de la línea de detalle no es la
      mejor. Tiene, al menos, dos inconvenientes. El primero es que el usuario
      puede querer tener la posibilidad de cambiar el precio unitario. Y
      segundo, si el precio de un producto cambia los importes de todas las
      facturas cambian también, y esto no es bueno.<br>
      Para evitar estos inconvenientes lo mejor es almacenar el precio de cada
      producto en cada línea de detalle. Añadamos pues una propiedad persistente
      <em>precioPorUnidad</em> a la clase <em>Detalle</em> y calculemos su
      valor desde <em>precio</em> de <em>Producto</em> usando un <em>@DefaultValueCalculator</em>.
      De tal forma que consigamos el efecto que puedes ver en la siguiente
      figura:<br>
      <img src="files/business-logic_es020.png" alt="business-logic_es020.png" title="business-logic_es020.png"><br>
      La lógica para calcular el valor inicial la tendremos en <em>CalculadorPrecioPorUnidad</em>
      que simplemente lee el precio del producto. Observa el código de este
      calculador:<br>
      <pre><code class="java">package com.tuempresa.facturacion.calculadores; // En el paquete calculadores
 
import org.openxava.calculators.*;
import com.tuempresa.facturacion.modelo.*;
import lombok.*;
 
import static org.openxava.jpa.XPersistence.*; //Para usar getManager()
 
public class CalculadorPrecioPorUnidad implements ICalculator {
 
    @Getter @Setter
    int numeroProducto;
 
    @Override
    public Object calculate() throws Exception {
        Producto producto = getManager() // getManager() de XPersistence
            .find(Producto.class, numeroProducto); // Busca el producto
        return producto.getPrecio();    // Retorna su precio
    }
 
}
</code></pre>
      <div class="wiki" style="display: block;">El siguiente paso es añadir la
        propiedad <em>precioPorUnidad</em>. Añade el siguiente código a la
        clase <em>Detalle</em>:<br>
      </div>
      <pre><code class="java">@DefaultValueCalculator(
    value=CalculadorPrecioPorUnidad.class, // Esta clase calcula el valor inicial
    properties=@PropertyValue(
        name="numeroProducto", // La propiedad numeroProducto del calculador...
        from="producto.numero") // ... se llena con el valor de producto.numero de la entidad
)
@Stereotype("DINERO")
BigDecimal precioPorUnidad; // Una propiedad persistente convencional
</code></pre>De esta forma cuando el usuario escoge un producto el campo de
      precio unitario se rellena con el precio del producto, pero dado que es
      una propiedad persistente, el usuario puede cambiar este valor. Y si en el
      futuro el precio del producto cambiara este precio unitario de la línea de
      detalle no cambiaría.<br>
      Esto implica que has de adaptar la propiedad calculada <em>importe</em>:<br>
      <pre><code class="java">@Stereotype("DINERO")
@Depends("precioPorUnidad, cantidad") // precioPorUnidad en vez de producto.numero
public BigDecimal getImporte() {
    if (precioPorUnidad == null) return BigDecimal.ZERO; // precioPorUnidad en vez de producto y producto.getPrecio()
    return new BigDecimal(cantidad).multiply(precioPorUnidad); // precioPorUnidad en vez de producto.getPrecio()
}
</code></pre> Ahora <em>getImporte()</em> usa <em>precioPorUnidad</em> como
      fuente en lugar de <em>producto.precio</em>.<br>
      Finalmente, debemos editar la entidad <em>DocumentoComercial</em> y
      modificar la lista de propiedades de la colección para mostrar la nueva
      propiedad:<br>
      <pre><code class="java">@ElementCollection
@ListProperties("producto.numero, producto.descripcion, cantidad, precioPorUnidad, importe") // precioPorUnidad añadida
private Collection&lt;Detalle&gt; detalles;
</code></pre> Prueba los módulos <em>Pedido</em> y <em>Factura</em> y podrás
      observar el nuevo comportamiento al añadir líneas de detalle.</div>
    <div class="wiki" style="display: block;">
      <h2 id="toc14"><a name="Resumen"></a>Resumen</h2>
      En esta lección has aprendido cómo definir una propiedad en Java, cómo es
      el funcionamiento de la librería Lombrok para trabajar con getters y
      setters y como crear y trabajar con propiedades calculadas y el uso de la
      anotación @DefaultValueCalculator a la hora de establecer cambios
      dinámicos. En la próxima lección, hablaremos sobre el uso de la anotación
      @Calculation, añadiremos propiedades a total, y como establecer valores
      por defecto desde un archivo de propiedades. <br>
      <br>
      <strong>¿Problemas con la lección? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/437013/"

          rel="nofollow">Pregunta en el foro</a></strong> <strong>¿Ha ido bien?
        <a class="wiki_link" href="total-properties-with-calculation_es.html">Ve
          a la lección 10</a></strong> </div>
  </body>
</html>
