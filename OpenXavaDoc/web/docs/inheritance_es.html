<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>openxava - inheritance_es</title>
    <link rel="stylesheet" href="static/style.css" type="text/css">
    <link rel="stylesheet" href="highlight/highlight.css">
    <script src="highlight/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <div class="wiki" id="content_view" style="display: block;">
      <div id="toc">
        <h1 class="nopad">Table of Contents</h1>
        <div style="margin-left: 1em;"><a href="#Leccion-4-Herencia">Lección 4:
            Herencia</a></div>
        <div style="margin-left: 2em;"><a href="#Heredar-de-una-superclase-mapeada">Heredar
            de una superclase mapeada</a></div>
        <div style="margin-left: 2em;"><a href="#Herencia-de-entidades">Herencia
            de entidades</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-de-entidades-Nueva-entidad-Pedido">Nueva
            entidad Pedido</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-de-entidades-CommercialDocument-como-entidad-abstracta">CommercialDocument
            como entidad abstracta</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-de-entidades-Factura-refactorizada-para-usar-herencia">Factura
            refactorizada para usar herencia</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-de-entidades-Crear-Pedido-usando-herencia">Crear
            Pedido usando herencia</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-de-entidades-Convencion-de-nombres-y-herencia">Convención
            de nombres y herencia</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-de-entidades-Asociar-Pedido-con-Factura">Asociar
            Pedido con Factura</a></div>
        <div style="margin-left: 2em;"><a href="#Herencia-de-vistas">Herencia de
            vistas</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-de-vistas-El-atributo-extendsView">El
            atributo extendsView</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-de-vistas-Vista-para-Factura-usando-herencia">Vista
            para Factura usando herencia</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-de-vistas-Vista-para-Pedido-usando-herencia">Vista
            para Pedido usando herencia</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-de-vistas-Usar-ReferenceView-y-CollectionView-para-refinar-vistas">Usar
            @ReferenceView y @CollectionView para refinar vistas</a></div>
        <div style="margin-left: 2em;"><a href="#Herencia-en-las-pruebas-JUnit">Herencia
            en las pruebas JUnit</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-en-las-pruebas-JUnit-Crear-una-prueba-de-modulo-abstracta">Crear
            una prueba de módulo abstracta</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-en-las-pruebas-JUnit-Prueba-base-abstracta-para-crear-pruebas-de-modulo-concretas">Prueba
            base abstracta para crear pruebas de módulo concretas</a></div>
        <div style="margin-left: 3em;"><a href="#Herencia-en-las-pruebas-JUnit-Anadir-nuevas-pruebas-a-las-pruebas-de-modulo-extendidas">Añadir
            nuevas pruebas a las pruebas de módulo extendidas</a></div>
        <div style="margin-left: 2em;"><a href="#Resumen">Resumen</a></div>
      </div>
      <strong>Curso</strong>: <a class="wiki_link" href="getting-started_es.html">1.
        Primeros pasos</a> | <a class="wiki_link" href="modeling_es.html">2.
        Modelar con Java</a> | <a class="wiki_link" href="testing_es.html">3.
        Pruebas automáticas</a> | <strong>4. Herencia</strong> | <a class="wiki_link"
        href="basic-business-logic_es.html">5. Lógica de negocio básica</a> | <a
        class="wiki_link" href="validation_es.html">6. Validación avanzada</a> |
      <a class="wiki_link" href="refining-standard-behavior_es.html">7. Refinar
        el comportamiento predefinido</a> | <a class="wiki_link" href="business-logic-behavior_es.html">8.
        Comportamiento y lógica de negocio</a> | <a class="wiki_link" href="references-collections_es.html">9.
        Referencias y colecciones</a> | <a class="wiki_link" href="philosophy_es.html">A.
        Arquitectura y filosofía</a> | <a class="wiki_link" href="jpa_es.html">B.
        Java Persistence API</a> | <a class="wiki_link" href="annotations_es.html">C.
        Anotaciones</a><br>
      <h1 id="toc0"><a name="Leccion-4-Herencia"></a>Lección 4: Herencia</h1>
      La herencia es una forma práctica de reutilizar el código en el mundo de
      la orientación a objetos. Usar herencia con JPA y OpenXava es tan fácil
      como hacerlo con puro Java. Vamos a usar la herencia para quitar el código
      repetitivo y aburrido, como la definición de los UUID. También, añadiremos
      una nueva entidad, <em>Pedido</em>, y usaremos la herencia para hacerlo
      con muy poco código. Además, aprenderás cuán práctico es usar herencia
      incluso para código de pruebas.<br>
      <h2 id="toc1"><a name="Heredar-de-una-superclase-mapeada"></a>Heredar de
        una superclase mapeada</h2>
      Las clases <em>Autor</em>, <em>Categoria</em> y <em>Factura</em> tienen
      algo de código en común. Este código es la definición del campo <em>oid</em>:<br>
      <pre><code class="java">@Id @GeneratedValue(generator="system-uuid") @Hidden
@GenericGenerator(name="system-uuid", strategy="uuid")
@Column(length=32)
private String oid;
 
public String getOid() {
    return oid;
}
 
public void setOid(String oid) {
    this.oid = oid;
}
</code></pre> Este código es exactamente el mismo para todas estas clases. Ya
      sabes que copiar y pegar es un pecado mortal, por eso tenemos que buscar
      una forma de quitar este código repetido y así evitar ir al infierno.<br>
      Una solución elegante en este caso es usar herencia. JPA permite varias
      formas de herencia. Una de ellas es heredar de una superclase mapeada. Una
      superclase mapeada es una clase Java con anotaciones de mapeo JPA, pero no
      es una entidad en sí. Su único objetivo es ser usada como clase base para
      definir entidades. Usemos una y verás su utilidad rápidamente.<br>
      Primero, movemos el código común a una clase marcada como <em>@MappedSuperclass</em>.
      La llamamos <em>Identificable</em>:<br>
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import javax.persistence.*;
import org.hibernate.annotations.*;
import org.openxava.annotations.*;
 
@MappedSuperclass // Marcada como una superclase mapeada en vez de como una entidad
public class Identificable {
 
    @Id @GeneratedValue(generator="system-uuid") @Hidden
    @GenericGenerator(name="system-uuid", strategy="uuid")
    @Column(length=32)
    private String oid; // La definición de propiedad incluye anotaciones de OpenXava y JPA
 
    public String getOid() {
        return oid;
    }
 
    public void setOid(String oid) {
        this.oid = oid;
    }
 
}
</code></pre> Ahora puedes definir las entidades <em>Autor, Categoria</em> y <em>Factura</em>
      de una manera más sucinta. Para ver un ejemplo aquí tienes el nuevo código
      para <em>Categoria</em>:<br>
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import javax.persistence.*;
 
@Entity
public class Categoria extends Identificable { // Extiende de Identificable
                        // por tanto no necesita tener una propiedad id
    @Column(length=50)
    private String descripcion;
 
    public String getDescripcion() {
        return descripcion;
    }
 
    public void setDescripcion(String descripcion) {
        this.descripcion = descripcion;
    }
 
}
</code></pre> La refactorización es extremadamente simple. <em>Categoria</em>
      ahora desciende de <em>Identificable</em> y hemos quitado el campo <em>oid</em>
      y los métodos <em>getOid()</em> y <em>setOid()</em>. De esta forma, no
      sólo tu código es más corto, sino también más elegante, porque estás
      declarando tu clase como identificable (el qué, no el cómo), y has quitado
      de tu clase de negocio un código que era un tanto técnico.<br>
      Ahora, puedes aplicar esta misma refactorización a las entidades <em>Autor</em>
      y <em>Factura</em>. Además, a partir de ahora extenderás la mayoría de
      tus entidades de la superclase mapeada <em>Identificable</em>.<br>
      Hemos creado nuestra propia clase <em>Identificable</em> para ver las
      ventajas de usar superclases mapeadas, sin embargo OpenXava te provee una
      clase <em>Identifiable</em> lista para usar que puedes encontrar en el
      paquete <em>org.openxava.model</em>. Por tanto, en tu próximo proyecto no
      has de escribir la clase <em>Identificable</em> otra vez, simplemente usa
      la incluida en OpenXava.<br>
      Has aprendido, pues, que una superclase mapeada es una clase normal y
      corriente con anotaciones de mapeo JPA que puedes usar como clase base
      para tus entidades. También has aprendido como usar una superclase mapeada
      para simplificar tu código.<br>
      <h2 id="toc2"><a name="Herencia-de-entidades"></a>Herencia de entidades</h2>
      Una entidad puede heredar de otra entidad. Esta herencia de entidades es
      una herramienta muy útil para simplificar tu modelo. Vamos a usarla para
      añadir una nueva entidad, <em>Pedido</em>, a tu aplicación <em>Facturacion</em>.<br>
      <h3 id="toc3"><a name="Herencia-de-entidades-Nueva-entidad-Pedido"></a>Nueva
        entidad Pedido</h3>
      Queremos añadir un nuevo concepto a la aplicación <em>Facturacion</em>:
      pedido. Mientras que una factura es algo que quieres cobrar a tu cliente,
      un pedido es algo que tu cliente te ha solicitado. Estos dos conceptos
      están fuertemente unidos, porque cobrarás por las cosas que tu cliente te
      ha pedido y tú le has servido.<br>
      Sería interesante poder tratar pedidos en tu aplicación y asociar estos
      pedidos con sus correspondientes facturas. Tal como muestra el siguiente
      diagrama UML:<br>
      <img src="files/inheritance_es010.png" alt="inheritance_es010.png" title="inheritance_es010.png"><br>
      Y con código Java:<br>
      <pre><code class="java">@Entity
public class Factura {
 
    @OneToMany(mappedBy="factura")
    private Collection&lt;Pedido&gt; pedidos;
    ...
}
 
@Entity
public class Pedido {
 
    @ManyToOne // Sin carga vaga (1)
    private Invoice invoice;
    ...
}
</code></pre> Es decir, una factura tiene varios pedidos y un pedido puede
      referenciar a una factura. Fíjate como no usamos inicialización vaga (lazy
      fetching) para la referencia <em>factura</em> (1), esto es por un bug de
      Hibernate cuando la referencia contiene la relación bidireccional (es
      decir, es la referencia declarada en el atributo <em>mappedBy</em> del <em>@OneToMany</em>).<br>
      ¿Cómo es <em>Pedido</em>? Bien, tiene un cliente, unas líneas de detalle
      con producto y cantidad, un año y un número. Algo así como esto:<br>
      <img src="files/inheritance_es020.png" alt="inheritance_es020.png" title="inheritance_es020.png"><br>
      Curiosamente, este diagrama UML es idéntico al diagrama de <em>Factura</em>.
      Es decir, para crear tu entidad <em>Pedido</em> puedes copiar y pegar la
      clase <em>Factura</em>, y asunto zanjado. Pero, ¡espera un momento!
      ¿“Copiar y pegar” no era un pecado mortal? Hemos de encontrar una forma de
      reutilizar <em>Factura</em> para <em>Pedido</em>.<br>
      <h3 id="toc4"><a name="Herencia-de-entidades-CommercialDocument-como-entidad-abstracta"></a>DocumentoComercial
        como entidad abstracta</h3>
      Una manera práctica de reutilizar el código de <em>Factura</em> para <em>Pedido</em>
      es usando herencia, además es una excusa perfecta para aprender lo fácil
      que es usar la herencia con JPA y OpenXava.<br>
      En la mayoría de las culturas orientadas a objetos has de observar el
      precepto sagrado <em>es un</em>. Esto significa que no podemos hacer que
      <em>Factura</em> herede de <em>Pedido</em>, porque una <em>Factura</em>
      no es un <em>Pedido</em>, y por la misma regla no podemos hacer que <em>Pedido</em>
      descienda de <em>Factura</em>. La solución para este caso es crear una
      clase base para ambos, <em>Pedido</em> y <em>Factura</em>. Llamaremos a
      esta clase <em>DocumentoComercial</em>.<br>
      Aquí tienes el diagrama UML para <em>DocumentoComercial</em>:<br>
      <img src="files/inheritance_es030.png" alt="inheritance_es030.png" title="inheritance_es030.png"><br>
      Y aquí tienes la misma idea expresada con Java:<br>
      <pre><code class="java">public class DocumentoComercial { ... }
public class Pedido extends DocumentoComercial { ... }
public class Factura extends DocumentoComercial { ... }
</code></pre> Empecemos a refactorizar el código actual. Primero, renombra
      (usando <em>Refactor &gt; Rename</em>) <em>Factura</em> como <em>DocumentoComercial</em>.
      Después, edita el código de <em>DocumentoComercial</em> para declararla
      como una clase abstracta, así:<br>
      <pre><code class="java">abstract public class DocumentoComercial // Añadimos el modificador abstract
</code></pre> Queremos crear instancias de <em>Factura</em> y <em>Pedido</em>,
      pero no queremos crear instancias de <em>DocumentoComercial</em>
      directamente, por eso la declaramos abstracta.<br>
      <h3 id="toc5"><a name="Herencia-de-entidades-Factura-refactorizada-para-usar-herencia"></a>Factura
        refactorizada para usar herencia</h3>
      Ahora, has de crear la entidad <em>Factura</em> extendiéndola de <em>DocumentoComercial</em>.
      Puedes ver el nuevo código de <em>Factura</em>:<br>
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import javax.persistence.*;
 
@Entity
public class Factura extends DocumentoComercial {
 
}
</code></pre> <em>Factura</em> tiene ahora un código bastante breve, de hecho
      el cuerpo de la clase está, por ahora, vacío.<br>
    </div>
    <div class="wiki" style="display: block;">Este nuevo código necesita un
      esquema de base de datos ligeramente diferente, ahora las facturas y los
      pedidos se almacenarán en la misma tabla (la tabla DocumentoComercial)
      usando una columna discriminador. Por tanto has de borrar las viejas
      tablas ejecutando las siguientes sentencias SQL:<br>
      <pre><code class="sql">drop table facturacion.factura_detalles;
drop table facturacion.factura;
</code></pre> Para ejecutar estas sentencias SQL, primero asegurate de que tu
      aplicación se esté ejecutando, después ve a la clase <i>DBManager</i> en
      <i>Facturacion/src/_run</i>, y con el botón derecho del ratón escoge <i>Run
        As &gt; Java Application</i>:<br>
      <img src="files/inheritance_es040.png" alt="inheritance_es040.png" title="inheritance_es040.png"><br>
      Después:<br>
      <img src="files/inheritance_es050.png" alt="inheritance_es050.png" title="inheritance_es050.png"><br>
      Reinicia la aplicación y ejecuta el módulo <em>Factura</em> desde tu
      navegador. Lanza también <em>PruebaFactura</em>. Tiene que salirte verde.<br>
      <h3 id="toc6"><a name="Herencia-de-entidades-Crear-Pedido-usando-herencia"></a>Crear
        Pedido usando herencia</h3>
      Gracias a <em>DocumentoComercial</em> el código para <em>Pedido</em> es
      más sencillo que el mecanismo de un sonajero:<br>
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import javax.persistence.*;
 
@Entity
public class Pedido extends DocumentoComercial {
 
}
</code></pre> Después de escribir la clase <em>Pedido</em>, aunque de momento
      esté vacía, ya puedes usar el módulo <em>Pedido</em> desde tu navegador.
      Sí, a partir de ahora crear una nueva entidad con una estructura parecida
      a <em>Factura</em>, es decir cualquier entidad para un documento
      comercial, es simple y rápido. Un buen uso de la herencia es una forma
      elegante de tener un código más simple.<br>
      El módulo <em>Pedido</em> funciona perfectamente, pero tiene un pequeño
      problema. El nuevo número de pedido lo calcula a partir del último número
      de factura, no de pedido. Esto es así porque el calculador para el
      siguiente número lee de la entidad <em>Factura</em>. Un solución obvia es
      mover la definición de la propiedad <em>numero</em> de <em>DocumentoComercial</em>
      a <em>Factura</em> y <em>Pedido</em>. Aunque, no lo vamos a hacer así,
      porque en la siguiente lección refinaremos la forma de calcular el número
      de documento, de momento simplemente haremos un pequeño ajuste en el
      código actual para que no falle. Edita la clase <em>CalculadorSiguienteNumeroParaAnyo</em>
      y en la consulta cambia “Factura” por “DocumentoComercial”, dejando el
      método <em>calculate()</em>, así:</div>
    <div class="wiki" style="display: block;">
      <pre><code class="java">public Object calculate() throws Exception {
    Query query = XPersistence.getManager().createQuery(
        "select max(f.numero) from " +
        "DocumentoComercial f " + // DocumentoComercial en vez de Factura
        "where f.anyo = :anyo");
    query.setParameter("anyo", anyo);
    Integer ultimoNumero = (Integer) query.getSingleResult();
    return ultimoNumero == null?1:ultimoNumero + 1;
}
</code></pre> Ahora buscamos el número máximo de cualquier tipo de documento
      comercial del año para calcular el nuevo número, por lo tanto la
      numeración es compartida para todos los tipos de documentos. Esto lo
      mejoraremos en la siguiente lección para separar la numeración para
      facturas y pedidos; y para tener un mejor soporte de entornos
      multiusuario.<br>
      <h3 id="toc7"><a name="Herencia-de-entidades-Convencion-de-nombres-y-herencia"></a>Convención
        de nombres y herencia</h3>
      Fíjate que no has necesitado cambiar el nombre de ninguna propiedad de <em>Factura</em>
      para hacer la refactorización. Esto es por el siguiente principio
      práctico: <em>No uses el nombre de clase en los nombres de miembro</em>,
      por ejemplo, dentro de una clase <em>Cuenta</em> no uses la palabra
      “Cuenta” en ningún método o propiedad:<br>
      <pre><code class="java">public class Cuenta { // No usaremos Cuenta en los nombres de los miembros
 
    private int numeroCuenta; // Mal, porque usa “cuenta”
    private int numero; // Bien, no usa “cuenta”
 
    public void cancelarCuenta() { } // Mal, porque usa “Cuenta”
    public void cancelar() { } // Bien, no usa “cuenta”
    ...
}
</code></pre> Usando esta nomenclatura puedes refactorizar la clase <em>Cuenta</em>
      en una jerarquía sin renombrar sus miembros, y además puedes escribir
      código polimórfico con <em>Cuenta</em>.<br>
      <h3 id="toc8"><a name="Herencia-de-entidades-Asociar-Pedido-con-Factura"></a>Asociar
        Pedido con Factura</h3>
      Hasta ahora, <em>Pedido</em> y <em>Factura</em> son exactamente iguales.
      Vamos a hacerles sus primeras extensiones, que va a ser asociar <em>Pedido</em>
      con <em>Factura</em>, como se muestra en el diagrama:<br>
      <img src="files/inheritance_es010.png" alt="inheritance_es010.png" title="inheritance_es010.png"><br>
      Solo necesitas añadir una referencia desde <em>Pedido</em> a <em>Factura</em>:<br>
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import javax.persistence.*;
 
@Entity
public class Pedido extends DocumentoComercial {
 
    @ManyToOne
    private Factura factura; // Referencia a factura añadida
 
    public Factura getFactura() {
        return factura;
    }
 
    public void setFactura(Factura factura) {
        this.factura = factura;
    }
 
}
</code></pre> Por otra parte en <em>Factura</em> añadimos una colección de
      entidades <em>Pedido</em>:<br>
      <pre><code class="java">package com.tuempresa.facturacion.modelo;
 
import java.util.*; // Añade este import para usar Collection
import javax.persistence.*;
 
@Entity
public class Factura extends DocumentoComercial {
 
    @OneToMany(mappedBy="factura")
    private Collection&lt;Pedido&gt; pedidos; // Colección de entidades Pedido añadida
 
    public Collection&lt;Pedido&gt; getPedidos() {
        return pedidos;
    }
 
    public void setPedidos(Collection&lt;Pedido&gt; pedidos) {
        this.pedidos = pedidos;
    }
 
}
</code></pre> Después de escribir este código tan simple, ya puedes probar
      estas, recién creadas, relaciones. Reinicia tu aplicación y abre tu
      navegador y explora los módulos <em>Pedido</em> y <em>Factura</em>.
      Fíjate como al final de la interfaz de usuario de <em>Pedido</em> tienes
      una referencia a <em>Factura</em>. El usuario puede usar esta referencia
      para asociar una factura al pedido actual. Por otra parte, si exploras el
      módulo <em>Factura</em>, verás una colección de pedidos al final. El
      usuario puede usarla para añadir pedidos a la factura actual.<br>
      Intenta añadir pedidos a la factura, y asociar una factura a un pedido.
      Funciona, aunque la interfaz de usuario es un poco fea, de momento.<br>
      <h2 id="toc9"><a name="Herencia-de-vistas"></a>Herencia de vistas</h2>
      La herencia no solo sirve para reutilizar código Java y mapeos, sino
      también para reutilizar la definición de la interfaz de usuario, las
      definiciones <em>@View</em>. Esta sección muestra como funciona la
      herencia de vistas.<br>
      <h3 id="toc10"><a name="Herencia-de-vistas-El-atributo-extendsView"></a>El
        atributo extendsView</h3>
      Tanto <em>Pedido</em> como <em>Factura</em> usan una interfaz de usuario
      generada por defecto con todos sus miembros uno por cada línea. Nota como
      la <em>@View</em> que hemos declarado en <em>DocumentoComercial</em> no
      se ha heredado. Es decir, si no defines una vista para la entidad se
      genera una por defecto, la <em>@View</em> de la entidad padre no se usa.
      Como se muestra aquí:<br>
      <pre><code class="java">@View(members = "a, b, c;") // Esta vista se usa para visualizar Padre, pero no para Hijo
public class Padre { ... }
 
public class Hijo extends Padre { ... } // Hijo se visualiza usando la vista
                                        // generada automáticamente, no la vista de Padre
</code></pre> Generalmente la vista de la entidad padre “tal cual” no es
      demasiado útil porque no contiene todas las propiedades de la entidad
      actual. Por tanto este comportamiento suele venir bien como comportamiento
      por defecto.<br>
      Aunque, en una entidad no trivial necesitas refinar la interfaz de usuario
      y quizás sea útil heredar (en lugar de copiar y pegar) la vista del padre.
      Puedes hacer esto usando el atributo <em>extendsView</em> en <em>@View</em>:<br>
      <pre><code class="java">@View(members = "a, b, c;") // Esta vista sin nombre es la vista DEFAULT
public class Padre { ... }
 
@View(name="A" members = "d", // Añade d a la vista heredada
    extendsView = "super.DEFAULT") // Extienda la vista por defecto de Padre
@View(name="B" members = "a, b, c; d") // La vista B es igual a la vista A
public class Hijo extends Padre { ... } // Hijo se visualiza usando la vista
                                        // generada automáticamente, no la vista de Padre
</code></pre> Usando <em>extendsView</em> los miembros a mostrar serán aquellos
      en la vista que extendemos más aquellos en <em>members</em> de la actual.<br>
      Vamos a usar esta característica para definir las vistas para <em>DocumentoComercial</em>,
      <em>Pedido</em> y <em>Factura</em>.<br>
      <h3 id="toc11"><a name="Herencia-de-vistas-Vista-para-Factura-usando-herencia"></a>Vista
        para Factura usando herencia</h3>
      Dado que la <em>@View</em> de <em>DocumentoComercial</em> no se hereda,
      la interfaz de usuario actual para <em>Invoice</em> es bastante fea:
      todos los miembros, uno por línea. Vamos a definir una interfaz de usuario
      mejor. Una vista parecida a la que ya teníamos, pero añadiendo una pestaña
      para pedidos, así:<br>
      <img src="files/inheritance_es060.png" alt="inheritance_es060.png" title="inheritance_es060.png"><br>
      Nota que ponemos todos los miembros de la parte de <em>DocumentoComercial</em>
      de <em>Factura</em> en la cabecera y la primera pestaña (datos), y la
      colección de pedidos en la otra pestaña. El siguiente código muestra la
      forma de definir esto sin herencia.<br>
      <pre><code class="java">@View( members=
    "anyo, numero, fecha;" +
    "datos {" +
        "cliente;" +
        "detalles;" +
        "observaciones" +
    "}" +
    "pedidos { pedidos } "
)
</code></pre> Puedes notar como todos los miembros, excepto la parte de <em>pedidos</em>,
      son comunes para todos los <em>DocumentoComercial</em>. Por lo tanto,
      vamos a mover esta parte común a <em>DocumentoComercial</em> y redefinir
      la vista usando herencia.<br>
      Quita el viejo <em>@View</em> de <em>DocumentoComercial</em>, y escribe
      esto:<br>
      <pre><code class="java">@View(members=
    "anyo, numero, fecha," + // Los miembros para la cabecera en una línea
    "datos {" + // Una pestaña 'datos' para los datos principales del documento
        "cliente;" +
        "detalles;" +
        "observaciones" +
    "}"
)
abstract public class DocumentoComercial extends Identifiable {
</code></pre> Esta vista indica como distribuir los datos comunes para todos los
      documentos comerciales. Ahora podemos redefinir la vista de <em>Factura</em>
      a partir de esta:<br>
      <pre><code class="java">import org.openxava.annotations.*; // Añade este import para usar @View
 
@Entity
@View(extendsView="super.DEFAULT", // Extiende de la vista de DocumentoComercial
    members="pedidos { pedidos }" // Añadimos pedidos dentro de una pestaña
)
public class Factura extends DocumentoComercial {
</code></pre> De esta forma declarar la vista para <em>Factura</em> es más
      corto, es más, la distribución común para <em>Pedido</em>, <em>Factura</em>
      y todos los demás posibles <em>DocumentoComercial</em> está en un único
      sitio, por tanto, si añades una nueva propiedad a <em>DocumentoComercial</em>
      solo has de tocar la vista de <em>DocumentoComercial</em>.<br>
      <h3 id="toc12"><a name="Herencia-de-vistas-Vista-para-Pedido-usando-herencia"></a>Vista
        para Pedido usando herencia</h3>
      Ahora que tienes una vista adecuada para <em>DocumentoComercial</em>,
      declarar una vista para <em>Pedido</em> es lo más fácil del mundo. La
      vista que queremos contiene toda la información del pedido, y su factura
      asociada en otra pestaña:<br>
      <img src="files/inheritance_es070.png" alt="inheritance_es070.png" title="inheritance_es070.png"><br>
      Para obtener este resultado, puedes definir la vista de <em>Pedido</em>
      extendiendo la vista por defecto de <em>DocumentoComercial</em>, y
      añadiendo la referencia a factura, así:<br>
      <pre><code class="java">import org.openxava.annotations.*; // Añade este import para usar @View
 
@Entity
@View(extendsView="super.DEFAULT", // Extiende de la vista de DocumentoComercial
    members="factura { factura } " // Añadimos factura dentro de una pestaña
)
public class Pedido extends DocumentoComercial {
</code></pre> Con esto conseguimos toda la información de <em>DocumentoComercial</em>
      más una pestaña con la factura.<br>
      <h3 id="toc13"><a name="Herencia-de-vistas-Usar-ReferenceView-y-CollectionView-para-refinar-vistas"></a>Usar
        @ReferenceView y @CollectionView para refinar vistas</h3>
      Queremos que cuando un pedido sea visualizado desde la interfaz de usuario
      de <em>Factura</em> la vista a usar sea simple, sin cliente ni factura,
      porque estos datos son redundantes en este caso:<br>
      <img src="files/inheritance_es080.png" alt="inheritance_es080.png" title="inheritance_es080.png"><br>
      Para obtener este resultado define una vista más simple en <em>Pedido</em>:<br>
      <pre><code class="java">@View( extendsView="super.DEFAULT", // La vista por defecto
    members="factura { factura } "
)
@View( name="SinClienteNiFactura", // Una vista llamada SinClienteNiFactura
    members=                       // que no incluye cliente ni factura
        "anyo, numero, fecha;" +   // Ideal para ser usada desde Factura
        "detalles;" +
        "observaciones"
)
public class Pedido extends DocumentoComercial {
</code></pre> Esta nueva vista definida en <em>Pedido</em> llamada <em>SinClienteNiFactura</em>
      puede ser referenciada desde <em>Factura</em> para visualizar elementos
      individuales de la colección <em>pedidos</em> usando <em>@CollectionView</em>:<br>
      <pre><code class="java">@OneToMany(mappedBy="factura")
@CollectionView("SinClienteNiFactura") // Esta vista se usa para visualizar pedidos
private Collection&lt;Pedido&gt; pedidos;
</code></pre> Y tan solo con este código la colección <em>pedidos</em> usará
      una vista más apropiada de <em>Factura</em> para visualizar elementos
      individuales.<br>
      Además, queremos que desde la interfaz de usuario de <em>Pedido</em> la
      factura no muestre el cliente y los pedidos, porque son datos redundantes
      en este caso. Para conseguirlo, vamos a definir una vista más simple en <em>Factura</em>:<br>
      <pre><code class="java">@View( extendsView="super.DEFAULT", // La vista por defecto
    members="pedidos { pedidos } "
)
@View( name="SinClienteNiPedidos", // Una vista llamada SinClienteNiPedidos
    members=                       // que no incluye cliente ni pedidos
        "anyo, numero, fecha;" +   // Ideal para usarse desde Pedido
        "detalles;" +
        "observaciones"
)
public class Factura extends DocumentoComercial {
</code></pre> Esta nueva vista definida en <em>Factura</em> llamada <em>SinClienteNiPedidos</em>
      puede ser referenciada desde <em>Pedido</em> para visualizar la
      referencia a <em>Factura</em> usando <em>@ReferenceView</em>:<br>
      <pre><code class="java">public class Pedido extends DocumentoComercial {
 
    @ManyToOne
    @ReferenceView("SinClienteNiPedidos") // Esta vista se usa para visualizar factura
    private Factura factura;
 
    ...
 
}
</code></pre> Ahora la referencia <em>factura</em> será visualizada desde <em>Pedido</em>
      sin incluir el cliente y los pedidos, por lo que tendrás la interfaz de
      usuario más simple:<br>
      <img src="files/inheritance_es090.png" alt="inheritance_es090.png" title="inheritance_es090.png"><br>
      <h2 id="toc14"><a name="Herencia-en-las-pruebas-JUnit"></a>Herencia en las
        pruebas JUnit</h2>
      <em>Factura</em> ha sido refactorizada para usar herencia y también hemos
      usado herencia para añadir una nueva entidad, <em>Pedido</em>. Además,
      esta entidad <em>Pedido</em> tiene relación con <em>Factura</em>. Lo
      cual es una nueva funcionalidad, por ende has de probar todas estas nuevas
      características.<br>
      Dado que <em>Factura</em> y <em>Pedido</em> tienen bastantes cosas en
      común (la parte de <em>DocumentoComercial</em>) podemos refactorizar las
      pruebas para usar herencia, y así eludir el dañino “copiar y pegar”
      también en tu código de prueba.<br>
      <h3 id="toc15"><a name="Herencia-en-las-pruebas-JUnit-Crear-una-prueba-de-modulo-abstracta"></a>Crear
        una prueba de módulo abstracta</h3>
      Si examinas la prueba para crear una factura, en el método <em>testCrear()</em>
      de <em>PruebaFactura</em>. Puedes notar que probar la creación de una
      factura es exactamente igual que probar la creación de un pedido. Porque
      ambos tienen año, número, fecha, cliente, detalles y observaciones. Por
      tanto, aquí la herencia es una buena herramienta para la reutilización de
      código.<br>
      Vamos a renombrar <em>PruebaFactura</em> como <em>PruebaDocumentoComercial</em>
      y entonces crearemos <em>PruebaFactura</em> y <em>PruebaPedido</em> a
      partir de él. Éste es el diagrama UML de esta idea:<br>
      <img src="files/inheritance_es100.png" alt="inheritance_es100.png" title="inheritance_es100.png"><br>
      Primero renombra tu actual clase <em>PruebaFactura</em> a <em>PruebaDocumentoComercial</em>,
      y después haz los cambios indicados en el siguiente código:<br>
      <pre><code class="java">package com.tuempresa.facturacion.pruebas;
 
import java.time.*;
import java.time.format.*;
import javax.persistence.*;
import org.openxava.tests.*;
import static org.openxava.jpa.XPersistence.*; 
 
abstract public class PruebaDocumentoComercial // Añade abstract a la definición de clase
    extends ModuleTestBase {
 
    private String numero;
 
    public PruebaDocumentoComercial(
        String nombrePrueba,
        String nombreModulo) // nombreModulo añadido como argumento en el constructor
    {
        super(nombrePrueba, "Facturacion", nombreModulo); // nombreModulo en vez de "Factura"
    }
 
    public void testCrear() throws Exception { … } // Como el original
 
    private void anyadirDetalles() throws Exception { … } // Como el original
 
    private String getNumero() {
        if (numero == null) {
            Query query = getManager().
                createQuery(
                    "select max(f.numero) "
                    + "from DocumentoComercial f " // Factura cambiada por DocumentoComercial
                    + "where f.anyo = :anyo");
            query.setParameter("anyo", Dates.getYear(new Date()));
            Integer ultimoNumero = (Integer) query.getSingleResult();
            if (ultimoNumero == null) ultimoNumero = 0;
            numero = Integer.toString(ultimoNumero + 1);
        }
        return numero;
    }
 
    private void borrar() throws Exception { … } // Como original
 
    private void verificarCreado() throws Exception { … } // Como original
 
    private void grabar() throws Exception { … } // Como original
 
    private void ponerOtrasPropiedades() throws Exception { … } // Como original
 
    private void escogerCliente() throws Exception { … } // Como original
 
    private void verificarValoresDefecto() throws Exception { … } // Como original
 
    private String getAnyoActual() { … } // Como original
 
    private String getFechaActual() { … } // Como original
 
}
</code></pre> Como ves has tenido que hacer unos pocos cambios para adaptar <em>PruebaDocumentoComercial</em>.
      Primero, la has declarado abstracta, de esta forma esta clase no es
      ejecutada por Eclipse como una prueba JUnit, es solo válida como clase
      base para crear pruebas, pero ella misma no es una prueba.<br>
      Otro cambio importante nos lo encontramos en el constructor, donde ahora
      tienes <em>nombreModulo</em> en vez de “Factura”, así puedes usar esta
      prueba para <em>Pedido</em>, <em>Factura</em> o cualquier otro módulo
      que quieras. El otro cambio es un simple detalle: has de cambiar “Factura”
      por “DocumentoComercial” en la consulta para obtener el siguiente número.<br>
      Ahora ya tienes una clase base lista para crear los módulos de prueba para
      <em>Pedido</em> y <em>Factura</em>. Hagámoslo sin más dilación.<br>
      <h3 id="toc16"><a name="Herencia-en-las-pruebas-JUnit-Prueba-base-abstracta-para-crear-pruebas-de-modulo-concretas"></a>Prueba
        base abstracta para crear pruebas de módulo concretas</h3>
      Crear tu primera versión para <em>PruebaFactura</em> y <em>PruebaPedido</em>
      es simplemente extender de <em>PruebaDocumentoComercial</em>. Nada más.
      Mira el código de <em>PruebaFactura</em>:<br>
      <pre><code class="java">package com.tuempresa.facturacion.pruebas;
 
public class PruebaFactura extends PruebaDocumentoComercial {
 
    public PruebaFactura(String nombrePrueba) {
        super(nombrePrueba, "Factura");
    }
 
}
</code></pre> Y <em>PruebaPedido</em>:<br>
      <pre><code class="java">package com.tuempresa.facturacion.pruebas;
 
public class PruebaPedido extends PruebaDocumentoComercial {
 
    public PruebaPedido(String nombrePrueba) {
        super(nombrePrueba, "Pedido");
    }
 
}
</code></pre> Ejecuta estas dos prueba y verás como <em>testCrear()</em>,
      heredado de <em>PruebaDocumentoComercial</em>, se ejecuta en ambos casos,
      contra su módulo correspondiente. Con esto estamos probando el
      comportamiento común para <em>Pedido</em> y <em>Factura</em>. Probemos
      ahora la funcionalidad particular de cada uno.<br>
      <h3 id="toc17"><a name="Herencia-en-las-pruebas-JUnit-Anadir-nuevas-pruebas-a-las-pruebas-de-modulo-extendidas"></a>Añadir
        nuevas pruebas a las pruebas de módulo extendidas</h3>
      Hasta ahora hemos probado como crear una factura y un pedido. En esta
      sección probaremos como añadir pedidos a una factura en el módulo <em>Factura</em>
      y como establecer la factura a un pedido en el módulo <em>Pedido</em>.<br>
      Para probar como añadir un pedido a una factura añade el método <em>testAnyadirPedidos()</em>
      a <em>PruebaFactura</em>:<br>
      <pre><code class="java">// Esta prueba confía en que al menos exista una factura y un pedido
public void testAnyadirPedidos() throws Exception {
    login("admin", "admin");
    assertListNotEmpty(); // Esta prueba confía en que ya existen facturas
    execute("List.orderBy", "property=numero"); // Para usar siempre el mismo pedido
    execute("List.viewDetail", "row=0"); // Va al modo detalle editando la primera factura
    execute("Sections.change", "activeSection=1"); // Cambia a la pestaña 1
    assertCollectionRowCount("pedidos", 0); // Esta factura no tiene pedidos
    execute("Collection.add", // Pulsa el botón para añadir un nuevo pedido, esto te lleva
        "viewObject=xava_view_section1_pedidos"); // a la lista de pedidos
    execute("AddToCollection.add", "row=0"); // Escoge el primer pedido de la lista
    assertCollectionRowCount("pedidos", 1); // El pedido se ha añadido a la factura
    checkRowCollection("pedidos", 0); // Marca el pedido, para borrarlo
    execute("Collection.removeSelected", // Borra el pedido recién añadido
        "viewObject=xava_view_section1_pedidos");
    assertCollectionRowCount("pedidos", 0); // El pedido ha sido borrado
}
</code></pre> En este caso asumimos que hay al menos una factura, y que la
      primera factura de la lista no tiene pedidos. Antes de ejecutar esta
      prueba, si no tienes facturas todavía, crea una sin pedidos, o si ya
      tienes facturas, asegúrate de que la primera no tiene pedidos.<br>
      Para probar como asignar una factura a un pedido añade el método <em>testPonerFactura()</em>
      a <em>PruebaPedido</em>:<br>
      <pre><code class="java">public void testPonerFactura() throws Exception {
    login("admin", "admin");
    assertListNotEmpty(); // Esta prueba confía en que existen pedidos
    execute("List.viewDetail", "row=0"); // Va a modo detalle editando la primera factura
    execute("Sections.change", "activeSection=1"); // Cambia a la pestaña 1
    assertValue("factura.numero", ""); // Este pedido todavía no tiene
    assertValue("factura.anyo", ""); // una factura asignada
    execute("Reference.search", // Pulsa en el botón para buscar la factura, esto te
        "keyProperty=factura.anyo"); // lleva a la lista de facturas
    String anyo = getValueInList(0, "anyo"); // Memoriza el año y el número de
    String numero = getValueInList(0, "numero"); // la primera factura de la lista
    execute("ReferenceSearch.choose", "row=0"); // Escoge la primera factura
    assertValue("factura.anyo", anyo); // Al volver al detalle del pedido verificamos
    assertValue("factura.numero", numero); // que la factura ha sido seleccionada
}
</code></pre> En este caso asumimos que hay al menos un pedido, y el primer
      pedido de la lista no tiene factura. Antes de ejecutar esta prueba, si no
      tienes pedidos, crea uno sin factura, o si ya tienes pedidos, asegúrate de
      que el primero no tiene factura.<br>
      Con esto ya tienes tus pruebas listas. Ejecútalas, y obtendrás el
      siguiente resultado:<br>
      <img src="files/inheritance_es110.png" alt="inheritance_es110.png" title="inheritance_es110.png"><br>
      Fíjate que la prueba base <em>PruebaDocumentoComercial</em> no se muestra
      porque es abstracta. Y <em>testCrear()</em> de <em>PruebaDocumentoComercial</em>
      se ejecuta para <em>PruebaFactura</em> y <em>PruebaPedido</em>.<br>
      No solo has adaptado tu código de pruebas al nuevo código de <em>Facturacion</em>,
      sino que también has aprendido como usar herencia en el mismo código de
      pruebas.<br>
      <h2 id="toc18"><a name="Resumen"></a>Resumen</h2>
      Esta lección te ha mostrado algunos ejemplos prácticos sobre como usar
      herencia con Java y JPA para simplificar tu código. Hemos usado la
      configuración por defecto de JPA para la herencia, aunque puedes refinar
      el comportamiento de JPA para la herencia con anotaciones como <em>@Inheritance</em>,
      <em>@DiscriminatorColumn</em>, <em>@DiscriminatorValue</em>, etc. Para
      aprender más acerca de la herencia en JPA puedes leer la documentación del
      <a class="wiki_link" href="jpa_es.html">apéndice B</a>.<br>
      <br>
      <strong><a class="wiki_link_ext" href="https://sourceforge.net/projects/openxava/files/openxava-course-source-code/openxava-course-source-code-lesson-4-inheritance_es.zip/download"
          rel="nofollow">Descargar código fuente de esta lección</a></strong><br>
      <br>
      <strong>¿Problemas con la lección? <a class="wiki_link_ext" href="http://sourceforge.net/p/openxava/discussion/437013/"
          rel="nofollow">Pregunta en el foro</a></strong> <strong>¿Ha ido bien?
        <a class="wiki_link" href="basic-business-logic_es.html">Ve a la lección
          5</a></strong> </div>
  </body>
</html>
